<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米米的博客</title>
  
  <subtitle>做了一点微小的工作</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangshuqiao.org/"/>
  <updated>2019-01-09T03:10:01.689Z</updated>
  <id>https://zhangshuqiao.org/</id>
  
  <author>
    <name>张书樵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是 CAT 等级？</title>
    <link href="https://zhangshuqiao.org/2019-01/%E4%BB%80%E4%B9%88%E6%98%AFCAT%E7%AD%89%E7%BA%A7%EF%BC%9F/"/>
    <id>https://zhangshuqiao.org/2019-01/什么是CAT等级？/</id>
    <published>2019-01-08T05:08:11.000Z</published>
    <updated>2019-01-09T03:10:01.689Z</updated>
    
    <content type="html"><![CDATA[<p>根据国际电子电工委员会 IEC1010-1 的定义，我们把电工工作的区域分为四个等级，分别称作 CAT I，CAT II，CAT III 和 CAT IV。CAT 等级是向下兼容的，也就是说，一块 CAT IV 的表用在 CAT I，CAT II，CAT III 下使用是完全安全的，但是一块 CAT I 的万用表用在 CAT II，CAT III 和 CAT IV 环境下使用就不保证安全了。</p><h3 id="CAT-等级对用户意味着什么"><a href="#CAT-等级对用户意味着什么" class="headerlink" title="CAT 等级对用户意味着什么"></a>CAT 等级对用户意味着什么</h3><p>CAT 等级意味着对客户的人身安全承诺，它不仅仅是耐高压！CAT 等级严格规定了电气工作人员在不同级别的电气环境中可能遇到的电气设备的类型以及在这样的区域中工作所使用的测量工具必须要遵循的安全标准。CAT 后面的电压数值则表示了他们能够收到电压冲击的上限。<br>例如，一个 CAT III 600V 的万用表，表示该表可以在 CAT I，II 和 III 区域安全使用，在这三个区域里如果该表收到最高 600V 的电压冲击，表不会对人体安全产生威胁，但是这款表在 CAT IV 域使用时，或者到 700V 的高压冲击的时候，就不能保证同样的安全了。CAT 等级是向下兼容的，也就是说，一块 CAT IV 的表用在 CAT I，CAT II，CAT III 下使用是完全安全的，但是一块 CAT I 的万用表用在 CAT II，CAT III 和 CAT IV 环境下使用就不保证安全了，表可能发生爆炸、燃烧威胁到你的安全。</p><h3 id="CAT-等级划分"><a href="#CAT-等级划分" class="headerlink" title="CAT 等级划分"></a>CAT 等级划分</h3><ul><li>CAT I：通过变压器或者类似设备连接到墙上插座的二次电气线路，例如电子仪器设备类。有保护措施的电子设备、任何高压、低压回路，如办公室内部的复印机等。</li><li>CAT II：通过电源线连接到室内插座的用电设备的一次电气线路，如移动式工具，家电等。家用电器、便携工具（电钻等）、家用插座，距离三类线路 10 米以上的插座或者距离四类线路 20 米以上的插座。</li><li>CAT III：直接连接到配电盘的大型设备的一次线路及配电盘与插座之间的电路线路（三相分配电路包括单个商业照明电路）。位置固定的设备，如多相马达、多相闸盒；大型建设物内部的照明设备、线路；工业现场（车间）的机床、电源配电盘等。</li><li>CAT IV：三相公用供电设备和室外供电线路设备。涉及到『初始连接』的设备，如电站的电力分配系统；电力仪表，前端过置保护，任何室外输电线路。</li></ul><p><img src="/images/2019-01/2ccd70dcb7a54444c2cfeb2fc78c23a3.png" alt=""></p><h3 id="如何理解-CAT-等级"><a href="#如何理解-CAT-等级" class="headerlink" title="如何理解 CAT 等级"></a>如何理解 CAT 等级</h3><p>CAT 等级有各自的工作电压和瞬时峰值电压。CAT 等级的工作电压分为：50V，150V，300V，600V，1000V。工作电压越高意味着能够承受的瞬时峰值电压也越高。<br>如下表所示：</p><table><thead><tr><th>等级</th><th>瞬时峰值</th></tr></thead><tbody><tr><td>CAT IV 600V</td><td>8kV impulse</td></tr><tr><td>CAT III 600V</td><td>6kV impulse</td></tr><tr><td>CAT III 1000V</td><td>8kV impulse</td></tr><tr><td>CAT II 600V</td><td>4kV impluse</td></tr><tr><td>CAT II 1000V</td><td>6kV impulse</td></tr></tbody></table><p>下图有更详细的数据：</p><p><img src="/images/2019-01/5e0693d4c540a6d44ba986dc647409cd.png" alt=""></p><h3 id="CAT-III-600V-比-CAT-II-1000V-更安全"><a href="#CAT-III-600V-比-CAT-II-1000V-更安全" class="headerlink" title="CAT III 600V 比 CAT II 1000V 更安全"></a>CAT III 600V 比 CAT II 1000V 更安全</h3><p>人们往往无法理解这一点，为什么只能承受 600V 电压的设备的比 1000V 更安全？<br>这里涉及到信号源阻抗的问题。信号源阻抗越大，CAT 等级越低。由表 1 可知，CAT III 等级的阻抗为 2 欧姆，CAT II 等级的阻抗时 12 欧姆，即 CAT II 等级的源阻抗是 CAT III 等级阻抗的 6 倍。所以，虽然 CAT III 等级的电压虽小，但阻抗也小，电流大，从而能够承受更高能量的信号，所以说 CAT III 600V 比 CAT II 1000V 安全。<br>同一个 CAT 等级下，工作电压越高，其安全等级也越高（同一 CAT 等级的源阻抗相同）。例如：CAT III 1000V（8kV 瞬时高发）比 CAT II 600V（6kV 瞬时高压）更安全。<br>如果您需要测试一个电力电路，你应该会用到一个 CAT III 600V 或 CAT IV 600V/CAT III 1000V 的仪表，配套 CAT IV-600V/CAT III-1000V 测试线和探头。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>问：PicoScope 的 CAT I 等级的高压探头 TA044 为什么配套 CAT III 1000V 等级的探头尖端？是不是厂家弄错了。<br>答：不是。Pico 所有的高压差分探头配套的都是 CAT III 等级的探头尖端。如下图所示。TA044 整体上是一个在 CAT I 环境中能够安全使用的设备，能够测量的最大单端电压 7kV。探头尖端采用的是工作电压 1000V 的 CAT III 等级，该等级下能够承受的瞬时最大尖峰电压是 8kV，所以 CAT III 等级的探头尖端 用起来更加安全。</p><p><img src="/images/2019-01/4fbf3af969c5f5b73093dbfd1600be96.png" alt=""></p><p>本文转载自：<a href="http://www.eepw.com.cn/article/274406.htm" target="_blank" rel="noopener">CAT 等级</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据国际电子电工委员会 IEC1010-1 的定义，我们把电工工作的区域分为四个等级，分别称作 CAT I，CAT II，CAT III 和 CAT IV。CAT 等级是向下兼容的，也就是说，一块 CAT IV 的表用在 CAT I，CAT II，CAT III 下使用是完
      
    
    </summary>
    
      <category term="技术" scheme="https://zhangshuqiao.org/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>成功召唤独角兽</title>
    <link href="https://zhangshuqiao.org/2019-01/%E6%88%90%E5%8A%9F%E5%8F%AC%E5%94%A4%E7%8B%AC%E8%A7%92%E5%85%BD/"/>
    <id>https://zhangshuqiao.org/2019-01/成功召唤独角兽/</id>
    <published>2019-01-02T17:30:28.000Z</published>
    <updated>2019-01-04T11:53:07.023Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2019-01/Unicorn.png" alt=""></p><blockquote><p>当你的代码出现未定义行为时，你会得到一个 <code>segmentation fault</code> 和一堆损坏的数据。当 Jeff Dean 的代码出现未定义行为时，一个独角兽会踏着彩虹从天而降并给每个人提供免费的冰激凌。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2019-01/Unicorn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你的代码出现未定义行为时，你会得到一个 &lt;code&gt;segmentation fault&lt;/code&gt; 和一堆损坏的数据。当 Jeff D
      
    
    </summary>
    
      <category term="幽默" scheme="https://zhangshuqiao.org/categories/%E5%B9%BD%E9%BB%98/"/>
    
    
      <category term="GitHub" scheme="https://zhangshuqiao.org/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>炉石卡组代码解析</title>
    <link href="https://zhangshuqiao.org/2018-12/%E7%82%89%E7%9F%B3%E5%8D%A1%E7%BB%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://zhangshuqiao.org/2018-12/炉石卡组代码解析/</id>
    <published>2018-12-22T13:51:38.000Z</published>
    <updated>2018-12-31T13:23:23.347Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章 <a href="/2018-12/Base64 编码的原理与实现 /">Base64 编码的原理与实现</a> 中，讲到了 Base64 编码的诸多用处，例如编码图片以嵌入 HTML 代码。如果你对此有所了解，同时还是一个炉石玩家，就不难发现，暴雪推出的卡组代码功能，本质上就是用一个 Base64 编码的字符串来存储卡组信息。毕竟，你有时会见到以 <code>=</code> 或者 <code>==</code> 结尾的卡组代码，这正是 Base64 编码的典型特征。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当把卡组代码粘贴到炉石传说时，客户端将忽略以 <code>#</code> 字符开头的任何行，这就提供了在卡组代码中插入注释的可能性。一个例外是在卡组代码最前面的，以 <code>###</code> 开头的第一行。如果可以的话，它将被用作套牌名称。你可以从炉石中复制一套卡组到文本编辑器看看效果。<br>没有被注释的那一行，包含了除套牌名称外的所有信息。玩家在各大论坛、社区分享卡组时，也往往只需要这一行卡组代码。</p><h2 id="DBF-ID"><a href="#DBF-ID" class="headerlink" title="DBF ID"></a>DBF ID</h2><p>为了了解编码的机制，我们需要先介绍 DBF ID。这是每张炉石卡牌（包括可收集卡牌、衍生卡牌、冒险模式专属卡牌、英雄皮肤等）的唯一标识符——是的，这也是能够卡出下图这种 BUG 的原因。皮肤被标记为了一张紫卡。</p><p><img src="/images/2018-12/tyrande.png" alt=""></p><p>而炉石卡组代码正是使用 DBF ID 来表示每张卡牌。DBF ID 可在游戏文件中找到。更加方便的方法是通过<a href="https://hearthstonejson.com" target="_blank" rel="noopener">HearthstoneJSON</a>，这上面提供了相关 API。你也可以在这个网站上直接下载最新的 <code>cards.collectible.json</code>，这里面包含了所有可收集卡牌的信息，例如各种语言的卡牌名称、描述等。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><strong> 除非另有说明，否则后面的每个值都是一个整数，编码为无符号的<a href="https://en.wikipedia.org/wiki/Variable-length_quantity" target="_blank" rel="noopener">varint</a>。</strong><br>如前所述，卡组代码是 Base64 编码的字节串。我们先来解码它。许多编程语言都可以做到这一点，以最好的语言 $PHP 为例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$deckstring = <span class="string">"AAEBAaoIBJsDoxTCrgLBiQMN/gXiDP8P5hausAKlvgL4vwL5vwKW7wKm7wKMhQPzigP2igMA"</span>;</span><br><span class="line"><span class="comment"># 这是一个非常有趣的萨满卡组</span></span><br><span class="line">$binary = base64_decode($deckstring);</span><br><span class="line">$hex = bin2hex($binary);</span><br><span class="line"><span class="comment"># 对于这个卡组，$hex="00010101aa08049b03a314c2ae02c189030dfe05e20cff0fe616aeb002a5be02f8bf02f9bf0296ef02a6ef028c8503f38a03f68a0300"</span></span><br></pre></td></tr></table></figure></p><p>这样就能得到初步解码后的十六进制字符串。如果你不是很擅长编程，也可以搜索一些现成的 Base64 解码工具，看看它是如何工作的。<br>将这个十六进制字符串按每两个元素切割，再把它们从 16 进制字符串转化为整型。也就是说，它们可以是 00-ff，即 0-255。一种实现的方法是这样：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$arr = str_split($hex, <span class="number">2</span>);</span><br><span class="line">$arr = array_map(<span class="string">"hexdec"</span>, $arr);</span><br></pre></td></tr></table></figure></p><p><code>$arr</code> 是一个由整数组成的数组。更具体的来说，就是 varint。我们还需要进一步的解码，才能读取出有用的信息：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_varint</span><span class="params">(&amp;$data)</span> </span>&#123;</span><br><span class="line">    $shift = <span class="number">0</span>;</span><br><span class="line">    $result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        $c = array_shift($data);</span><br><span class="line">        $result |= ($c &amp; <span class="number">0x7f</span>) &lt;&lt; $shift;</span><br><span class="line">        $shift += <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ($c &amp; <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 <code>array_shift</code> 会将数组的第一个元素移出数组，并返回它的值。在其它的编程语言中，类似的方法可能被叫做 <code>lpop</code>，<code>pop</code>，<code>shift</code> 等等。而 <code>|</code>，<code>&amp;</code>，<code>&lt;&lt;</code> 等都是位运算的运算符。<code>read_varint</code> 函数完成了解码过程，如果有兴趣的话可以试试用 C 或 Python 实现它。<br>不断地执行 <code>read_varint($arr)</code>，直到取完 <code>$arr</code> 中的元素，就能把内容全部解码出来。</p><p>根据作用，我们可以把解码后的卡组代码分为两个部分：元数据块和卡牌块。</p><a id="more"></a><h3 id="元数据块"><a href="#元数据块" class="headerlink" title="元数据块"></a>元数据块</h3><p>在 <code>$arr</code> 中，前五个元素分别为：</p><ul><li>保留字节 0x00</li><li>版本号（固定为 1）</li><li>模式（1 为狂野，2 为标准）</li><li>使用英雄卡牌的数量（固定为 1）</li><li>使用的英雄卡牌的类型（长度不确定，一般是 1-3 位）</li></ul><p>可见卡组代码以字节 0x00 开头。然后是编码版本号，目前始终为 1。虽然这五个元素并没有官方名称，不过从作用上可以看作元数据。<br>还有一点是，所谓『英雄卡牌的类型』就是你所使用的英雄皮肤。这个参数必不可少。英雄的职业决定了套牌所用的职业，但是套牌表面上是为英雄制作的，而不是为一个职业。如果卡组代码指定的英雄是皮肤而不是默认的英雄，那么在你复制卡组时，系统就会选择使用皮肤而不是默认英雄（前提是你买了这个皮肤）。<br><strong> 关于英雄的注意事项：</strong> 尽管它是一个数组，但它是用于 <em> 初始英雄 </em>，而不是 <em> 可打出的英雄牌 </em>（如冰封王座的 DK）。</p><h3 id="卡牌块"><a href="#卡牌块" class="headerlink" title="卡牌块"></a>卡牌块</h3><p>在元数据块之后，继续读取 <code>$arr</code> 的元素，那么接下来就轮到卡牌块了。它按以下顺序分为三对长度 + 数组的组合：</p><ul><li>卡组中存在一张的卡</li><li>卡组中存在两张的卡</li><li>卡组中存在 n 张的卡</li></ul><p><strong> 每对都有一个前导 varint，指定数组中的项目数。</strong> 这种结构的目标是使卡组代码尽可能紧凑。<strong> 如前所述，每张卡都用 varint 型的 DBF ID 表示。</strong></p><p>所谓『卡组中存在 n 张的卡』，指的是卡组中的所有其他卡牌。此数组是一个 varint 对组成的列表，每一对的第一个元素表示 DBF ID，第二个元素是该卡牌在卡组中出现的次数。它 <strong> 应该 </strong> 只包含在牌组中至少出现三次的牌，因而意味着它（在这种情况下）对于构筑卡组应当是空的（毕竟一张卡至多只能带两张）；但理论上它也可以包含有一张的卡和有两张的卡。</p><p>尽管最终排序无关紧要，但卡牌仍会在各自所在的数组中，按 DBF ID 的升序进行排序，以便始终为相同的卡组生成相同的卡组代码。我们称所有按照这种方式排列卡牌列表（包括英雄）的卡组代码为规范的卡组代码。下面的参考实现应该已经可以生成规范的卡组代码。</p><h2 id="一种实现"><a href="#一种实现" class="headerlink" title="一种实现"></a>一种实现</h2><p>看代码可能比文字描述更加直观。下面的 <code>parse_deck()</code> 函数就会按照前面介绍的方法，依次读取元数据块和卡牌块的信息。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse_deck</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    $reserve = read_varint($data);</span><br><span class="line">    <span class="keyword">if</span> ($reserve != <span class="number">0</span>) &#123;</span><br><span class="line">        printf(<span class="string">"Invalid deckstring"</span>);</span><br><span class="line">        <span class="keyword">die</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $version = read_varint($data);</span><br><span class="line">    <span class="keyword">if</span> ($version != <span class="number">1</span>) &#123;</span><br><span class="line">        printf(<span class="string">"Unsupported deckstring version %s"</span>, $version);</span><br><span class="line">        <span class="keyword">die</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $format = read_varint($data);</span><br><span class="line">    $heroes = [];</span><br><span class="line">    $num_heroes = read_varint($data);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $num_heroes; $i++) &#123;</span><br><span class="line">        $heroes[] = read_varint($data);</span><br><span class="line">    &#125;</span><br><span class="line">    $cards = [];</span><br><span class="line">    $num_cards_x1 = read_varint($data);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $num_cards_x1; $i++) &#123;</span><br><span class="line">        $card_id = read_varint($data);</span><br><span class="line">        $cards[] = [$card_id, <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    $num_cards_x2 = read_varint($data);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $num_cards_x2; $i++) &#123;</span><br><span class="line">        $card_id = read_varint($data);</span><br><span class="line">        $cards[] = [$card_id, <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    $num_cards_xn = read_varint($data);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $num_cards_xn; $i++) &#123;</span><br><span class="line">        $card_id = read_varint($data);</span><br><span class="line">        $count = read_varint($data);</span><br><span class="line">        $cards[] = [$card_id, $count];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [$cards, $heroes, $format];</span><br><span class="line">&#125;</span><br><span class="line">parse_deck($arr);</span><br></pre></td></tr></table></figure></p><p>这时，再通过建立 DBF ID 与卡牌对应关系的数据库，就能够实现在游戏外导入、导出和编辑卡组的功能了。不论是官方的 <a href="https://hs.blizzard.cn/cards" target="_blank" rel="noopener">卡牌工具</a>，还是第三方平台（如旅法师营地）的<a href="https://www.iyingdi.com/web/tools/hearthstone/decks" target="_blank" rel="noopener">套牌编辑</a> 功能，原理都是相似的。<br>所有代码已开源：<a href="https://github.com/stevenjoezhang/Hearthstone-Deck" target="_blank" rel="noopener">Hearthstone-Deck</a><br>其他语言的实现方式可以在 <a href="https://github.com/HearthSim" target="_blank" rel="noopener">HearthSim</a> 的官方 GitHub 账户下找到。</p><p>博主搭建的 API：<a href="https://api.galaxymimi.com/deck/" target="_blank" rel="noopener">炉石传说卡组</a></p><p>拓展阅读：<br><a href="https://2heng.xin/2018/12/12/embed-hearthstone-deck-with-iframe" target="_blank" rel="noopener">在网页上展示你的炉石卡组吧</a><br><a href="https://www.darkerror.com/2018/05/hearth-stone-deck-string-decoding" target="_blank" rel="noopener">炉石传说卡组代码生成机制</a><br><a href="https://hearthsim.info/docs/deckstrings" target="_blank" rel="noopener">Hearthstone Deckstrings</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章 &lt;a href=&quot;/2018-12/Base64 编码的原理与实现 /&quot;&gt;Base64 编码的原理与实现&lt;/a&gt; 中，讲到了 Base64 编码的诸多用处，例如编码图片以嵌入 HTML 代码。如果你对此有所了解，同时还是一个炉石玩家，就不难发现，暴雪推出的卡组代码功能，本质上就是用一个 Base64 编码的字符串来存储卡组信息。毕竟，你有时会见到以 &lt;code&gt;=&lt;/code&gt; 或者 &lt;code&gt;==&lt;/code&gt; 结尾的卡组代码，这正是 Base64 编码的典型特征。&lt;/p&gt;
&lt;h2 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h2&gt;&lt;p&gt;当把卡组代码粘贴到炉石传说时，客户端将忽略以 &lt;code&gt;#&lt;/code&gt; 字符开头的任何行，这就提供了在卡组代码中插入注释的可能性。一个例外是在卡组代码最前面的，以 &lt;code&gt;###&lt;/code&gt; 开头的第一行。如果可以的话，它将被用作套牌名称。你可以从炉石中复制一套卡组到文本编辑器看看效果。&lt;br&gt;没有被注释的那一行，包含了除套牌名称外的所有信息。玩家在各大论坛、社区分享卡组时，也往往只需要这一行卡组代码。&lt;/p&gt;
&lt;h2 id=&quot;DBF-ID&quot;&gt;&lt;a href=&quot;#DBF-ID&quot; class=&quot;headerlink&quot; title=&quot;DBF ID&quot;&gt;&lt;/a&gt;DBF ID&lt;/h2&gt;&lt;p&gt;为了了解编码的机制，我们需要先介绍 DBF ID。这是每张炉石卡牌（包括可收集卡牌、衍生卡牌、冒险模式专属卡牌、英雄皮肤等）的唯一标识符——是的，这也是能够卡出下图这种 BUG 的原因。皮肤被标记为了一张紫卡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-12/tyrande.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而炉石卡组代码正是使用 DBF ID 来表示每张卡牌。DBF ID 可在游戏文件中找到。更加方便的方法是通过&lt;a href=&quot;https://hearthstonejson.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HearthstoneJSON&lt;/a&gt;，这上面提供了相关 API。你也可以在这个网站上直接下载最新的 &lt;code&gt;cards.collectible.json&lt;/code&gt;，这里面包含了所有可收集卡牌的信息，例如各种语言的卡牌名称、描述等。&lt;/p&gt;
&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 除非另有说明，否则后面的每个值都是一个整数，编码为无符号的&lt;a href=&quot;https://en.wikipedia.org/wiki/Variable-length_quantity&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;varint&lt;/a&gt;。&lt;/strong&gt;&lt;br&gt;如前所述，卡组代码是 Base64 编码的字节串。我们先来解码它。许多编程语言都可以做到这一点，以最好的语言 $PHP 为例：&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$deckstring = &lt;span class=&quot;string&quot;&gt;&quot;AAEBAaoIBJsDoxTCrgLBiQMN/gXiDP8P5hausAKlvgL4vwL5vwKW7wKm7wKMhQPzigP2igMA&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 这是一个非常有趣的萨满卡组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$binary = base64_decode($deckstring);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$hex = bin2hex($binary);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 对于这个卡组，$hex=&quot;00010101aa08049b03a314c2ae02c189030dfe05e20cff0fe616aeb002a5be02f8bf02f9bf0296ef02a6ef028c8503f38a03f68a0300&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样就能得到初步解码后的十六进制字符串。如果你不是很擅长编程，也可以搜索一些现成的 Base64 解码工具，看看它是如何工作的。&lt;br&gt;将这个十六进制字符串按每两个元素切割，再把它们从 16 进制字符串转化为整型。也就是说，它们可以是 00-ff，即 0-255。一种实现的方法是这样：&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$arr = str_split($hex, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$arr = array_map(&lt;span class=&quot;string&quot;&gt;&quot;hexdec&quot;&lt;/span&gt;, $arr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$arr&lt;/code&gt; 是一个由整数组成的数组。更具体的来说，就是 varint。我们还需要进一步的解码，才能读取出有用的信息：&lt;br&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read_varint&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&amp;amp;$data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $shift = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $result = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $c = array_shift($data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $result |= ($c &amp;amp; &lt;span class=&quot;number&quot;&gt;0x7f&lt;/span&gt;) &amp;lt;&amp;lt; $shift;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $shift += &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ($c &amp;amp; &lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;array_shift&lt;/code&gt; 会将数组的第一个元素移出数组，并返回它的值。在其它的编程语言中，类似的方法可能被叫做 &lt;code&gt;lpop&lt;/code&gt;，&lt;code&gt;pop&lt;/code&gt;，&lt;code&gt;shift&lt;/code&gt; 等等。而 &lt;code&gt;|&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;，&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 等都是位运算的运算符。&lt;code&gt;read_varint&lt;/code&gt; 函数完成了解码过程，如果有兴趣的话可以试试用 C 或 Python 实现它。&lt;br&gt;不断地执行 &lt;code&gt;read_varint($arr)&lt;/code&gt;，直到取完 &lt;code&gt;$arr&lt;/code&gt; 中的元素，就能把内容全部解码出来。&lt;/p&gt;
&lt;p&gt;根据作用，我们可以把解码后的卡组代码分为两个部分：元数据块和卡牌块。&lt;/p&gt;
    
    </summary>
    
      <category term="电子游戏" scheme="https://zhangshuqiao.org/categories/%E7%94%B5%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="PHP" scheme="https://zhangshuqiao.org/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Command Line Russian Roulette</title>
    <link href="https://zhangshuqiao.org/2018-12/Command%20Line%20Russian%20Roulette/"/>
    <id>https://zhangshuqiao.org/2018-12/Command Line Russian Roulette/</id>
    <published>2018-12-16T08:58:38.000Z</published>
    <updated>2018-12-25T07:54:44.033Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018-12/Strip-Roulette-russe-650-finalenglish.jpg" alt=""></p><p>来源：<a href="http://www.commitstrip.com/en/2014/05/16/russian-roulette" target="_blank" rel="noopener">Russian roulette</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2018-12/Strip-Roulette-russe-650-finalenglish.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.commitstrip.com/en/2014/05/16/
      
    
    </summary>
    
      <category term="幽默" scheme="https://zhangshuqiao.org/categories/%E5%B9%BD%E9%BB%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Base64 编码的原理与实现</title>
    <link href="https://zhangshuqiao.org/2018-12/Base64%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangshuqiao.org/2018-12/Base64编码的原理与实现/</id>
    <published>2018-12-12T08:21:01.000Z</published>
    <updated>2018-12-25T13:56:35.712Z</updated>
    
    <content type="html"><![CDATA[<p>在数据传输的时候，并不是所有的字符都可以受到支持，很多时候只能传输可见字符，对于不可见字符的传输需要经过特殊处理，这就是 Base64 产生的原因。Base64 编码是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 $2^6=64$，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。在 Base64 中的可打印字符包括字母 A-Z、a-z、数字 0-9，这样共有 62 个字符，此外两个可打印符号在不同的系统中而不同。一些如 uuencode 的其他编码方法，和之后 BinHex 的版本使用不同的 64 字符集来代表 6 个二进制数字，但是不被称为 Base64。<br>Base64 常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。用 Base64 编码图片也是互联网上常见的做法。</p><p>Base64 的字符索引如下表所示：</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table><p>这是一个根据上表进行编码的例子：</p><p><img src="/images/2018-12/1.png" alt=""></p><p>如果要编码的字节数不能被 3 整除，最后会多出 1 个或 2 个字节，那么可以使用下面的方法进行处理：先使用 0 字节值在末尾补足，使其能够被 3 整除，然后再进行 Base64 的编码。在编码后的 Base64 文本后加上一个或两个 = 号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2 个 byte）时，最后一个 6 位的 Base64 字节块有四位是 0 值，最后附加上两个等号；如果最后剩余一个八位字节（1 个 byte）时，最后一个 6 位的 Base 字节块有两位是 0 值，最后附加一个等号。可以参考下面的例子：</p><p><img src="/images/2018-12/2.png" alt=""></p><a id="more"></a><p>这是一个用 Python 实现 Base64 编码的脚本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myBase64Encode</span><span class="params">(preCoding)</span>:</span></span><br><span class="line">    charTable = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span> <span class="comment"># 字符表</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> len(preCoding) &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>  <span class="comment"># 字符串为空则返回空</span></span><br><span class="line">    lackCharNums = <span class="number">3</span> - len(preCoding) % <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> lackCharNums == <span class="number">3</span> : lackCharNums = <span class="number">0</span> <span class="comment"># 整除说明不缺字符</span></span><br><span class="line">    <span class="comment"># 待转换字符不是 3 的倍数的情况补全它</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lackCharNums) :</span><br><span class="line">        preCoding = preCoding + <span class="string">b'\x00'</span></span><br><span class="line">    result = <span class="string">''</span> <span class="comment"># 用于保存最终结果的 str 数据</span></span><br><span class="line">    rp = <span class="string">''</span> <span class="comment"># 处理补全字符时的暂存变量</span></span><br><span class="line">    <span class="comment"># 每三个字符处理一轮</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(preCoding) / <span class="number">3</span>)):</span><br><span class="line">        threeChar = preCoding[i * <span class="number">3</span> : i * <span class="number">3</span> + <span class="number">3</span>] <span class="comment"># 取三个字符出来</span></span><br><span class="line">        tCode = <span class="string">''</span> <span class="comment"># 用于存放三个字符拼接后的二进制数值 文本形式</span></span><br><span class="line">        pCode = <span class="string">''</span> <span class="comment"># 暂存变量</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>) :</span><br><span class="line">            pCode = bin(threeChar[j])[<span class="number">2</span> :]  <span class="comment"># 把省略的 0 补上</span></span><br><span class="line">            lackZeroNums = <span class="number">8</span> - len(pCode) <span class="comment"># 省略的 0 的个数</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(lackZeroNums):</span><br><span class="line">                pCode = <span class="string">'0'</span> + pCode</span><br><span class="line">            tCode = tCode + pCode</span><br><span class="line">        pCode = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>): <span class="comment"># 每 6 位一个字符</span></span><br><span class="line">            pCode = tCode[j * <span class="number">6</span> : j * <span class="number">6</span> + <span class="number">6</span>]</span><br><span class="line">            rp = rp + charTable[int(pCode, <span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># 处理补全的 00 字符</span></span><br><span class="line">        result = rp[: len(rp) - lackCharNums]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(lackCharNums):</span><br><span class="line">            result = result + <span class="string">'='</span></span><br><span class="line">    <span class="keyword">return</span> bytes(result, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myBase64Decode</span><span class="params">(encodedBin)</span> :</span></span><br><span class="line">    charTable = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span> <span class="comment"># 字符表</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 如果字符不是 4 的倍数 返回空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(encodedBin) % <span class="number">4</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"> </span><br><span class="line">    tCode = <span class="string">''</span> <span class="comment"># 用于存放最终的二进制文本字符串</span></span><br><span class="line">    pCpde = <span class="string">''</span> <span class="comment"># 暂存变量</span></span><br><span class="line">    <span class="comment"># 遍历 encodedBin 每一个字符</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> encodedBin:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(charTable)): <span class="comment"># 找到表中对应坐标</span></span><br><span class="line">            <span class="keyword">if</span> chr(i) == charTable[j]:</span><br><span class="line">                pCode = bin(j)[<span class="number">2</span> :]  <span class="comment"># 转二进制去除开头的 0b</span></span><br><span class="line">                lackZeroNums = <span class="number">6</span> - len(pCode) <span class="comment"># 省略的 0 的个数</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(lackZeroNums):</span><br><span class="line">                    pCode = <span class="string">'0'</span> + pCode</span><br><span class="line">                tCode = tCode + pCode</span><br><span class="line">    pCode = <span class="string">''</span></span><br><span class="line">    result = <span class="string">''</span> <span class="comment"># 储存最终结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(tCode) / <span class="number">8</span>)):</span><br><span class="line">        pCode = tCode[i * <span class="number">8</span> : i * <span class="number">8</span> + <span class="number">8</span>]</span><br><span class="line">        result = result + chr(int(pCode, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> bytes(result, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">print(myBase64Encode(<span class="string">b"helloworld"</span>))</span><br><span class="line">print(myBase64Decode(<span class="string">b"aGVsbG93b3JsZA=="</span>))</span><br></pre></td></tr></table></figure></p><p>浏览器中可以直接调用相关的 API：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> 文件 base64——直接拖进来 < span class="tag">&lt;/<span class="name">title</span>&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">    word-break: break-all;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    event.preventDefault();</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    event.preventDefault();</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">"drop"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="actionscript">    reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.insertAdjacentHTML(<span class="string">"afterBegin"</span>, <span class="string">'&lt;p&gt;'</span> + e.target.result + <span class="string">'&lt;/p&gt;'</span>); </span></span><br><span class="line"><span class="actionscript">        <span class="comment">//base64 encoded file data!</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">    reader.readAsDataURL(event.dataTransfer.files[0]);</span></span><br><span class="line"><span class="undefined">    event.preventDefault();</span></span><br><span class="line"><span class="actionscript">&#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这是加载 Base64 编码的图片的方法。这可以将图片硬编码到网页中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Base64 Encode 编码实现 1x1px 透明 (黑白) 图片 < span class="tag">&lt;/<span class="name">title</span>&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 以下是透明图片 < span class="tag">&lt;/<span class="name">h1</span>&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 以下是黑色图片 < span class="tag">&lt;/<span class="name">h1</span>&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>拓展阅读：<br><a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64</a><br><a href="https://www.52pojie.cn/thread-831202-1-1.html" target="_blank" rel="noopener">Base64 编码原理及脚本的简单实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据传输的时候，并不是所有的字符都可以受到支持，很多时候只能传输可见字符，对于不可见字符的传输需要经过特殊处理，这就是 Base64 产生的原因。Base64 编码是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 $2^6=64$，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。在 Base64 中的可打印字符包括字母 A-Z、a-z、数字 0-9，这样共有 62 个字符，此外两个可打印符号在不同的系统中而不同。一些如 uuencode 的其他编码方法，和之后 BinHex 的版本使用不同的 64 字符集来代表 6 个二进制数字，但是不被称为 Base64。&lt;br&gt;Base64 常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。用 Base64 编码图片也是互联网上常见的做法。&lt;/p&gt;
&lt;p&gt;Base64 的字符索引如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是一个根据上表进行编码的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-12/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要编码的字节数不能被 3 整除，最后会多出 1 个或 2 个字节，那么可以使用下面的方法进行处理：先使用 0 字节值在末尾补足，使其能够被 3 整除，然后再进行 Base64 的编码。在编码后的 Base64 文本后加上一个或两个 = 号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2 个 byte）时，最后一个 6 位的 Base64 字节块有四位是 0 值，最后附加上两个等号；如果最后剩余一个八位字节（1 个 byte）时，最后一个 6 位的 Base 字节块有两位是 0 值，最后附加一个等号。可以参考下面的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-12/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zhangshuqiao.org/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://zhangshuqiao.org/tags/Python/"/>
    
      <category term="HTML" scheme="https://zhangshuqiao.org/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>历史上的今天</title>
    <link href="https://zhangshuqiao.org/2018-12/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E4%BB%8A%E5%A4%A9/"/>
    <id>https://zhangshuqiao.org/2018-12/历史上的今天/</id>
    <published>2018-12-06T10:38:36.000Z</published>
    <updated>2018-12-25T08:45:27.134Z</updated>
    
    <content type="html"><![CDATA[<p>如果要在网页上显示一些随机的语句，获得一些人生的经验，你会选择什么？<br>也许，<a href="https://hitokoto.cn" target="_blank" rel="noopener">一言</a>是一个很好的选择，它可以提供一些动漫中的台词，或是网络上的各种小段子。<br>在前面的文章 <a href="/2018-05 / 有趣的 Linux 命令行工具">有趣的 Linux 命令行工具</a> 中提到的 <code>fortune</code> 命令或许也可以满足需求，<code>pure-ftpd</code> 就可以设置在连接成功时显示随机的来自 <code>fortune</code> 的语句。<br>那除此之外呢？历史上的今天是一个不错的方案。当你访问一些门户网站的首页，有时会看到这样的栏目。它也是一些百科全书网站，比如维基百科的传统。事实上，在 Mac 上就自带了一个小型的『历史上的今天』数据库，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/share/calendar/calendar.history</span><br></pre></td></tr></table></figure></p><p>就可以看到。<br>这篇文章将介绍如何搭建一个提供『历史上的今天』信息的 API。</p><h2 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h2><p>首先，建立 MySQL 数据库，用于存储爬取的信息。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dbname;</span><br><span class="line"># 建立数据库，dbname 保持一致即可</span><br><span class="line"><span class="keyword">USE</span> dbname;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">event</span> (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">type</span> <span class="built_in">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">year</span> <span class="built_in">varchar</span>(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="built_in">date</span> <span class="built_in">varchar</span>(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  info <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">QUIT;</span><br></pre></td></tr></table></figure></p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>数据来源是维基百科，使用 Python 爬取数据，并存入数据库中。代码中的 <code>username</code>、<code>password</code> 和 <code>dbname</code> 分别是你的登录用户名、密码和数据库名。数据表名默认是 event，也可以自行修改。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">typeList = [<span class="string">"大事记"</span>, <span class="string">"出生"</span>, <span class="string">"逝世"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">savedb</span><span class="params">(data)</span>:</span></span><br><span class="line">    conn = pymysql.connect(host = <span class="string">"127.0.0.1"</span>, user = <span class="string">"username"</span>, password = <span class="string">"password"</span>, db = <span class="string">"dbname"</span>, charset = <span class="string">"utf8"</span>)</span><br><span class="line">    print(conn)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cur.execute(<span class="string">"insert into event values(null,%s,%s,%s,%s)"</span>, data)</span><br><span class="line">    <span class="keyword">except</span> pymysql.err.InternalError:</span><br><span class="line">        print(<span class="string">"\033[31mERROR: Incorrect string value.\033[0m"</span>, data)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"failed.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">            myfile.write(str(data) + <span class="string">"\n"</span>)</span><br><span class="line">    <span class="keyword">except</span> pymysql.err.DataError:</span><br><span class="line">        print(<span class="string">"\033[31mERROR: Data too long.\033[0m"</span>, data)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"failed.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">            myfile.write(str(data) + <span class="string">"\n"</span>)</span><br><span class="line">    cur.connection.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDateList</span><span class="params">()</span>:</span></span><br><span class="line">    list = []</span><br><span class="line">    date = datetime.date(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">366</span>):</span><br><span class="line">        date_str = str(date.month) + <span class="string">"月"</span> + str(date.day) + <span class="string">"日"</span></span><br><span class="line">        list.append(date_str)</span><br><span class="line">        date += datetime.timedelta(days = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInfo</span><span class="params">(html, type, date)</span>:</span></span><br><span class="line">    flag = re.compile(<span class="string">"(&lt;h2&gt;&lt;span id=.*&lt;span class=\"mw-headline\"id=.*?"</span> + typeList[type] + <span class="string">"[\s\S]*?&lt;/ul&gt;\s*?)&lt;h2&gt;"</span>).search(html)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        bsObj = BeautifulSoup(flag.group(<span class="number">1</span>), <span class="string">"html.parser"</span>).findAll(<span class="string">"li"</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> bsObj:</span><br><span class="line">            match = re.compile(<span class="string">"((^ 前 |^)\d&#123;1,4&#125; 年)：([\s\S]*$)"</span>).match(li.get_text())</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                year = match.group(<span class="number">1</span>)</span><br><span class="line">                info = re.sub(<span class="string">"\[\d&#123;1,&#125;\]"</span>, <span class="string">""</span>, match.group(<span class="number">3</span>).strip())</span><br><span class="line">                data = (type, year, date, info)</span><br><span class="line">                print(data)</span><br><span class="line">                savedb(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    list = getDateList()</span><br><span class="line">    <span class="keyword">for</span> date <span class="keyword">in</span> list:</span><br><span class="line">        print(date)</span><br><span class="line">        url = <span class="string">"https://zh.wikipedia.org/zh-cn/%s"</span> % date</span><br><span class="line">        <span class="comment">#url ="https://api.galaxymimi.com/proxy/?url=https://zh.wikipedia.org/zh-cn/%s"% date</span></span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        getInfo(r.text, <span class="number">0</span>, date)  <span class="comment"># 大事记</span></span><br><span class="line">        getInfo(r.text, <span class="number">1</span>, date)  <span class="comment"># 出生</span></span><br><span class="line">        getInfo(r.text, <span class="number">2</span>, date)  <span class="comment"># 逝世</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>这里的两个 <code>except</code> 分别处理的是特殊字符（非 UTF-8 范围）和内容长度超出的问题。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>比较简单的方式是按照 json 格式进行输出，这里给出一种使用 PHP 的方案。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $mysqli = <span class="keyword">new</span> mysqli(<span class="string">"localhost"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>, <span class="string">"dbname"</span>);</span><br><span class="line">    <span class="comment">/* 检查连接 */</span></span><br><span class="line">    <span class="keyword">if</span> (mysqli_connect_errno()) &#123;</span><br><span class="line">        printf(<span class="string">"Connect failed: %s\n"</span>, mysqli_connect_error());</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    $date = $_GET[<span class="string">'date'</span>] ? $mysqli-&gt;real_escape_string($_GET[<span class="string">'date'</span>]) : date(<span class="string">"m 月 d 日"</span>);</span><br><span class="line">    $type = $_GET[<span class="string">'type'</span>] ? (int)$mysqli-&gt;real_escape_string($_GET[<span class="string">'type'</span>]) : <span class="number">0</span>;</span><br><span class="line">    $count = $_GET[<span class="string">'count'</span>] ? (int)$mysqli-&gt;real_escape_string($_GET[<span class="string">'count'</span>]) : <span class="number">1</span>;</span><br><span class="line">    $result = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">/* 创建一个预编译 SQL 语句 */</span></span><br><span class="line">    <span class="keyword">if</span> ($stmt = $mysqli-&gt;prepare(<span class="string">"select * from `event` where `date` = ? and `type` = ? order by RAND() limit ?"</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 对于参数占位符进行参数值绑定 */</span></span><br><span class="line">        $stmt-&gt;bind_param(<span class="string">"dii"</span>, $date, $type, $count);</span><br><span class="line">        <span class="comment">/* 执行查询 */</span></span><br><span class="line">        $stmt-&gt;execute();</span><br><span class="line">        <span class="comment">/* 将查询结果绑定到变量 */</span></span><br><span class="line">        $stmt-&gt;bind_result($id, $type, $year, $date, $info);</span><br><span class="line">        <span class="comment">/* 获取查询结果值 */</span></span><br><span class="line">        <span class="keyword">while</span> ($stmt-&gt;fetch()) &#123;</span><br><span class="line">            $arr = <span class="keyword">array</span>(<span class="string">'year'</span> =&gt; $year, <span class="string">'info'</span> =&gt; $info);</span><br><span class="line">            $result[] = $arr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">echo</span> json_encode($result, JSON_UNESCAPED_UNICODE);</span><br><span class="line">        <span class="comment">/* 关闭语句句柄 */</span></span><br><span class="line">        $stmt-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关闭连接 */</span></span><br><span class="line">    $mysqli-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>同样将 <code>username</code>、<code>password</code> 和 <code>dbname</code> 根据情况替换，就可以访问了。</p><p>项目地址：<a href="https://github.com/stevenjoezhang/TodayInHistory-Crawler" target="_blank" rel="noopener">TodayInHistory-Crawler</a>，可以打包下载所有文件。</p><p>博主搭建的 API：<a href="https://api.galaxymimi.com/today/?type=0" target="_blank" rel="noopener">历史上的今天</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果要在网页上显示一些随机的语句，获得一些人生的经验，你会选择什么？&lt;br&gt;也许，&lt;a href=&quot;https://hitokoto.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一言&lt;/a&gt;是一个很好的选择，它可以提供一些动漫中的台词，或是网络上的
      
    
    </summary>
    
      <category term="程序设计" scheme="https://zhangshuqiao.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Python" scheme="https://zhangshuqiao.org/tags/Python/"/>
    
      <category term="MySQL" scheme="https://zhangshuqiao.org/tags/MySQL/"/>
    
      <category term="PHP" scheme="https://zhangshuqiao.org/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>十二月天象</title>
    <link href="https://zhangshuqiao.org/2018-12/%E5%8D%81%E4%BA%8C%E6%9C%88%E5%A4%A9%E8%B1%A1/"/>
    <id>https://zhangshuqiao.org/2018-12/十二月天象/</id>
    <published>2018-12-02T13:11:36.000Z</published>
    <updated>2019-01-05T10:17:34.411Z</updated>
    
    <content type="html"><![CDATA[<p>即将到来的 12 月天宇将先后上演『金星最亮』『双子座流星雨极大』『水星西大距』和『小熊座流星雨极大』等多部天象大片，天文爱好者们千万不要错过。</p><h2 id="火星合海王星"><a href="#火星合海王星" class="headerlink" title="火星合海王星"></a>火星合海王星</h2><p>2018 年 12 月 7 日入夜后西南方天空将可观赏到火星合海王星的天象，火星将至海王星北面 0.04 度（相当于 2 角分）的近距离通过，位于宝瓶座。火星视亮度 + 0.1 等，海王星 + 7.9 等，需用小型望远镜观测。</p><p><img src="/images/2018-12/mars.png" alt=""></p><h2 id="双子座流星雨极大期"><a href="#双子座流星雨极大期" class="headerlink" title="双子座流星雨极大期"></a>双子座流星雨极大期</h2><p>每到岁末，双子座流星雨（Geminids，00004 GEM）都会如期而至。作为北半球三大流星雨之一，它的流量非常稳定，并且全球绝大多数地区的公众都有机会观测到它。今年双子座流星雨的观测条件不错，预报的极大值出现在 12 月 14 日晚 20 时 30 分，天顶每时出现率 ZHR 为 120。</p><p>辐射点在 12 月 14 日入夜后自东北偏东方升起，即入夜后就有机会见到双子座流星出现。今年月相接近上弦，但对观测影响不大，尤其是后半夜观测条件很好，但要注意防寒保暖。</p><p><img src="/images/2018-12/Comet_holmes_and_Geminid121307.jpg" alt=""></p><h2 id="水星西大距"><a href="#水星西大距" class="headerlink" title="水星西大距"></a>水星西大距</h2><p>12 月 15 日，今年最后一次水星西大距将上演。如果大气透明度足够高，在此后几天的日出前，用肉眼或借助双筒望远镜均可在黎明前的东方低空寻觅到水星的神秘身影。</p><p><img src="/images/2018-12/mercury.png" alt=""></p><p>水星的视运动是这样的：东大距 → 半轮 → 近日点 → 留 → 下合 → 极长视直径 → 留 → 降交点 → 半轮 → 西大距 → 远日点 → 极短视直径 → 上合 → 升交点 → 东大距，周期是 116 日（水星的会合周期），而水星东大距 → 西大距平均间隔为 41 天。这次水星西大距，日出时位于东南方天空，与太阳的最大角距为 21 度，亮度约 - 0.5 等，是今年观测水星的第四次最佳时机。</p><h2 id="小熊座流星雨"><a href="#小熊座流星雨" class="headerlink" title="小熊座流星雨"></a>小熊座流星雨</h2><p>小熊座流星雨（Ursids，00015 URS）往往是全年精彩天象的收官之作，该流星雨的活动期为 12 月 17 日至 12 月 26 日。天文预报显示，今年该流星雨极大可能出现在 12 月 22 日 4 时 53 分。</p><p><img src="/images/2018-12/Murahashi1.jpg" alt=""></p><p>小熊座流星雨在 1949 年和 1986 年曾出现过两次爆发，但今年没有爆发的预期，届时每小时最大天顶流量为 10 颗左右，而且极大正好赶上满月，观测条件不是太好。</p><blockquote><p>部分图片来自维基百科，采用 CC BY-SA 3.0 许可证，作者为 Brocken Inaglory 以及 Brian Murahashi 和 Jim Albers。部分图片来自 Stellarium，该软件为开源软件，采用 GPL3.0 协议。</p></blockquote><p>拓展阅读：<a href="https://www.skyandtelescope.com/astronomy-news/spot-decembers-ursid-meteors" target="_blank" rel="noopener">Can You Spot December’s Ursid Meteors?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;即将到来的 12 月天宇将先后上演『金星最亮』『双子座流星雨极大』『水星西大距』和『小熊座流星雨极大』等多部天象大片，天文爱好者们千万不要错过。&lt;/p&gt;
&lt;h2 id=&quot;火星合海王星&quot;&gt;&lt;a href=&quot;#火星合海王星&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="物理" scheme="https://zhangshuqiao.org/categories/%E7%89%A9%E7%90%86/"/>
    
    
      <category term="天文" scheme="https://zhangshuqiao.org/tags/%E5%A4%A9%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Safari 顶栏彩虹效果</title>
    <link href="https://zhangshuqiao.org/2018-11/Safari%E9%A1%B6%E6%A0%8F%E5%BD%A9%E8%99%B9%E6%95%88%E6%9E%9C/"/>
    <id>https://zhangshuqiao.org/2018-11/Safari顶栏彩虹效果/</id>
    <published>2018-11-27T05:53:11.000Z</published>
    <updated>2018-12-15T16:55:14.609Z</updated>
    
    <content type="html"><![CDATA[<p>从 OS X Yosemite 系统开始，Safari 浏览器的顶部工具栏加入了类似 iOS 中的半透明毛玻璃效果。Safari 会自动根据页面的颜色来显示工具栏的毛玻璃特效颜色，而通过 CSS 中的 <code>body:before</code> 类，我们可以对其进行定制。具体代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">2147483647</span>;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(-99.99px);</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(124deg,</span><br><span class="line">        #FF0000,</span><br><span class="line">        #FF7F00,</span><br><span class="line">        #FFFF00,</span><br><span class="line">        #7FFF00,</span><br><span class="line">        #00FF00,</span><br><span class="line">        #00FF7F,</span><br><span class="line">        #00FFFF,</span><br><span class="line">        #007FFF,</span><br><span class="line">        #0000FF,</span><br><span class="line">        #7F00FF,</span><br><span class="line">        #FF00FF,</span><br><span class="line">        #FF007F,</span><br><span class="line">        #FF0000);</span><br><span class="line">        <span class="attribute">animation</span>: rainbow <span class="number">15s</span> ease infinite;</span><br><span class="line">        <span class="attribute">background-size</span>: <span class="number">1000%</span> <span class="number">1000%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> rainbow &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0%</span> <span class="number">80%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">100%</span> <span class="number">20%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0%</span> <span class="number">80%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将它们添加到页面中的 <code>&lt;style&gt;</code> 标签内，并在 <code>&lt;body&gt;</code> 中加入适当的内容。当使用 Safari 浏览器打开时，<strong> 略微向下滚动页面 </strong>，便可以看到顶部栏出现炫酷的彩虹效果。快去试试吧！<br><strong> 注意：一些老旧浏览器不能正确识别 <code>transform</code>，会导致彩色条挡住 <code>&lt;body&gt;</code>，<code>-webkit-min-device-pixel-ratio</code> 可以防止这一问题。</strong><br>GitHub 项目地址：<a href="https://github.com/koole/rainbowsafari" target="_blank" rel="noopener">rainbowsafari</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 OS X Yosemite 系统开始，Safari 浏览器的顶部工具栏加入了类似 iOS 中的半透明毛玻璃效果。Safari 会自动根据页面的颜色来显示工具栏的毛玻璃特效颜色，而通过 CSS 中的 &lt;code&gt;body:before&lt;/code&gt; 类，我们可以对其进行定
      
    
    </summary>
    
      <category term="Web开发" scheme="https://zhangshuqiao.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Mac" scheme="https://zhangshuqiao.org/tags/Mac/"/>
    
      <category term="CSS" scheme="https://zhangshuqiao.org/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>国际单位制基本单位的重新定义</title>
    <link href="https://zhangshuqiao.org/2018-11/%E5%9B%BD%E9%99%85%E5%8D%95%E4%BD%8D%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%E7%9A%84%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89/"/>
    <id>https://zhangshuqiao.org/2018-11/国际单位制基本单位的重新定义/</id>
    <published>2018-11-22T02:58:01.000Z</published>
    <updated>2019-01-04T09:21:26.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国际单位制以一组基本单位为基础，所有其他单位都是用基本单位建立起来的。麦克斯韦最初提出一致单位制的概念时，列出了三个可用的基本单位：质量、长度及时间单位。之后，吉奥尔吉提倡加入电的基本单位。理论上，电流、电势、电阻、电荷等物理量的单位都可以做基本单位，当选定其中一个做基本单位后，其余的电单位都可以通过物理定律从基本单位推导得出；国际单位制最终选择了使用电流。后期又加入了三个分别量度物质的量、温度及发光强度的基本单位。<br>国际单位制希望其单位定义的基准是源自于对自然的测量。但此单位制于 1799 在法国被引入时，由当时技术上的限制，因此利用了米原器与千克原器做为米与千克的定义。<br>1960 年，米的定义被改写为由特定光源所发出的光波长（后又改为根据真空光速定义），因此米定义的基准也成为了对自然测量的结果。现今，只留下了千克还是以人造的物品做为定义的基准。<br><strong>2018 年 11 月 16 日，第 26 届国际计量大会一致通过了新国际单位制基本单位定义的提案。新的定义将于 2019 年 5 月 20 日生效。</strong><br>国际度量衡局提案，除了光速以外，下列所示的四个自然常数也应被定义为确定的数值：</p><ul><li>普朗克常数 $h=6.62607015\times10^{−34}(J\cdot s)$</li><li>基本电荷 $e=1.602176634\times10^{−19}(C)$</li><li>玻尔兹曼常数 $k=1.380649\times10^{−23}(J\cdot K^{−1})$</li><li>阿伏伽德罗常量 $N_A=6.02214076\times10^{23}(mol^{−1})$</li></ul><p>这些常数在 2006 年版的 SI 指南就已经出现，但在此版本中后三个常数被定义为『由实验所得的常数』，而不是直接的『定义常数』。<br>国际度量衡局也提案，以下这些自然常数的数值应继续保持不变。</p><ul><li>光速 $c=299,792,458(m\cdot s^{-1})$</li><li>铯 133 原子基态超精细能级分裂频率 $\Delta\nu(^{133}Cs)_{hfs}=9,192,631,770(Hz)$</li><li>频率为 $540\times10^{12}Hz$ 辐射的发光效率 $K_{cd}=683(lm\cdot W^{-1})$</li></ul><p>这是以上七个定义改写为以基本单位表示的形式：</p><ul><li>$\Delta\nu(^{133}Cs)_{hfs}=9,192,631,770(s^{−1})$</li><li>$c=299,792,458(m\cdot s^{−1})$</li><li>$h=6.62607015\times10^{−34}(kg\cdot m^2\cdot s^{−1})$</li><li>$e=1.602176634\times10^{−19}(A\cdot s)$</li><li>$k=1.380649\times10^{−23}(kg\cdot m^2\cdot K^{−1}\cdot s^{−2})$</li><li>$N_A=6.02214076\times1023(mol^{−1})$</li><li>$K_{cd}=683(cd\cdot sr\cdot s^3\cdot kg^{−1}\cdot m^{−2})$</li></ul><p>此外国际度量衡局也要求：</p><ul><li>目前千克的定义应废除并使国际千克原器退休</li><li>目前安培的定义应废除</li><li>目前开尔文的定义应废除</li><li>目前摩尔的定义应修改</li></ul><p>这些改变会影响到基本单位的定义，但对于导出单位的表达形式则不会有所影响。</p><a id="more"></a><h2 id="改变历史"><a href="#改变历史" class="headerlink" title="改变历史"></a>改变历史</h2><p>我们可以回顾国际单位制基本单位定义的改变历史。</p><h3 id="米"><a href="#米" class="headerlink" title="米"></a>米</h3><p>最初（1793 年）：从北极至赤道经过巴黎的子午线长度的一千万分之一。（法国政府）<br>过渡（1799 年）：国际米原器的长度。<br>过渡（1960 年）：氪 - 86 原子在 $2p^{10}$ 和 $5d^5$ 量子能级之间跃迁所发出的电磁波在真空中的波长的 1,650,763.73 倍。<br>目前（1983 年）：光在 $\frac{1}{299,792,458}$ 秒内在真空中行进的距离。</p><h3 id="千克"><a href="#千克" class="headerlink" title="千克"></a>千克</h3><p>最初（1793 年）：最初法文名为 grave，定义为在冰点下体积为一立方分米的纯水的重量（质量）。（法国政府）<br>目前（1889 年）：国际千克原器的质量。<br>未来（2019 年）：由精确的普朗克常数 $h=6.62607015\times10^{−34}(kg\cdot m^2\cdot s^{−1})$、米和秒所定义。</p><h3 id="秒"><a href="#秒" class="headerlink" title="秒"></a>秒</h3><p>最初（中世纪）：一天时长的 86,400 分之一。<br>过渡（1956 年）：1900 年 1 月 0 日历书时 12 时算起的回归年时长的 $\frac{1}{31,556,925.9747}$。<br>目前（1967 年）：铯 - 133 原子基态的两个超精细能级之间跃迁所对应的辐射周期时长的 9,192,631,770 倍。</p><h3 id="安培"><a href="#安培" class="headerlink" title="安培"></a>安培</h3><p>最初（1881 年）：CGS 电磁单位制中电流单位的十分之一。CGS 电流单位的定义是，在半径为 1 厘米、长度为 1 厘米的圆弧上流通，并在圆心产生 1 奥斯特电场的电流。（国际电工委员会）<br>目前（1946 年）：在真空中相距 1 米的两根横截面为圆形、粗度可忽略不计的无限长平行直导线，各通上相等的恒定电流，当两根导线之间每米长度所受力为 $2\times10^{−7}$ 牛顿时，各导线上的电流定义为 1 安培。<br>未来（2019 年）：由新的元电荷 $e=1.602176634\times10^{−19}(A\cdot s)$ 和秒所定义。</p><h3 id="开尔文"><a href="#开尔文" class="headerlink" title="开尔文"></a>开尔文</h3><p>最初（1743 年）：摄氏温标将 0°C 和 100°C 分别定义为水的熔点和沸点。<br>过渡（1954 年）：273.16K 定义为水的三相点（0.01°C）。<br>目前（1967 年）：水的三相点热力学温度的 $\frac{1}{273.16}$。<br>未来（2019 年）：由新的玻尔兹曼常数 $k=1.380649\times10^{−23}(kg\cdot m^2\cdot K^{−1}\cdot s^{−2})$、千克、米和秒所定义。</p><h3 id="摩尔"><a href="#摩尔" class="headerlink" title="摩尔"></a>摩尔</h3><p>最初（1900 年）：物质的克数等于其分子量时的数量。（国际原子量委员会）<br>目前（1967 年）：物质所含的粒子数量相等于 0.012 千克碳 - 12 所含的原子数量。<br>未来（2019 年）：1 摩尔包含 $6.02214076×10^{23}$ 个基本实体，这一数字是新的阿伏伽德罗常数。</p><h3 id="坎德拉"><a href="#坎德拉" class="headerlink" title="坎德拉"></a>坎德拉</h3><p>最初（1946 年）：整个辐射体在铂凝固温度下的亮度，定义为 60 新坎德拉每平方厘米。<br>目前（1979 年）：频率为 $5.4×10^{14}$ 赫兹的单色光源在特定方向辐射强度为 $\frac{1}{683}W/sr$ 时的发光强度。</p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>由于定义的变化，这些单位之间的依赖关系也发生了改变。</p><p><img src="/images/2018-11/Unit_relations_in_the_old_SI.svg" alt=""><br><img src="/images/2018-11/Unit_relations_in_the_new_SI.svg" alt=""></p><h2 id="不确定度"><a href="#不确定度" class="headerlink" title="不确定度"></a>不确定度</h2><p>同样，由于定义的变化，一些物理量的不确定度也发生了改变。例如，真空磁导率 $\mu_0$ 将不再具有定义值 $4\pi\times10^{-7}m\cdot kg\cdot s^{-2}\cdot A^{-2}$，水的三相点温度也不再严格地等于 273.16K。下表给出了它们在改动后的影响：</p><div style="overflow-x: scroll !important; white-space: nowrap;"><table><thead><tr><th>Constant</th><th>Symbol</th><th>Relation to directly measured and fixed constants (Previous)</th><th>Significant factor(s) in uncertainty (Previous)</th><th>Relative uncertainty (Previous)</th><th>Relation to directly measured and fixed constants (2019)</th><th>Significant factor(s) in uncertainty (2019)</th><th>Relative uncertainty (2019)</th></tr></thead><tbody><tr><td>Mass of IPK</td><td>$m(\mathcal{K})$</td><td>1&nbsp;kg</td><td>None</td><td>Exact</td><td>$m(\mathcal{K})$</td><td>$m(\mathcal{K})$</td><td>$1.2 \times 10^{-8} = u_\text{r}(m(\mathcal{K}))$</td></tr><tr><td>Planck constant</td><td>$h$</td><td>$\frac{8 \alpha}{c \mu_0 K_\text{J}^2}$</td><td>$K_\text{J}^2$</td><td>$1.2 \times 10^{-8} \approx 2 u_\text{r}(K_\text{J})$</td><td>$6.62607015\times10^{-34} kg\cdot m^2\cdot s^{−1}$</td><td>None</td><td>Exact</td></tr><tr><td>Josephson constant</td><td>$K_\text{J}$</td><td>$K_\text{J}$</td><td>$K_\text{J}$</td><td>$6.1 \times 10^{-9} = u_\text{r}(K_\text{J})$</td><td>$\frac{2 e}{h}$</td><td>None</td><td>Exact</td></tr><tr><td>Von Klitzing constant</td><td>$R_\text{K}$</td><td>$\frac{c \mu_0}{2 \alpha}$</td><td>$\alpha$</td><td>$2.3 \times 10^{-10} = u_\text{r}(\alpha)$</td><td>$\frac{h}{e^2}$</td><td>None</td><td>Exact</td></tr><tr><td>Elementary charge</td><td>$e$</td><td>$\frac{4 \alpha}{c \mu_0 K_\text{J}}$</td><td>$K_\text{J}$</td><td>$6.1 \times 10^{-9} \approx u_\text{r}(K_\text{J})$</td><td>$1.602176634\times10^{-19} A\cdot s$</td><td>None</td><td>Exact</td></tr><tr><td>Magnetic constant</td><td>$\mu_0$</td><td>$4\pi\times10^{-7} m\cdot kg\cdot s^{−2}\cdot A^{−2} $</td><td>None</td><td>Exact</td><td>$\frac{2 h \alpha}{c e^2}$</td><td>$\alpha$</td><td>$2.3 \times 10^{-10} = u_\text{r}(\alpha)$</td></tr><tr><td>Vacuum permittivity</td><td>$\varepsilon_0$</td><td>$\frac{1}{c^2 \mu_0}$</td><td>None</td><td>Exact</td><td>$\frac{e^2}{2 h c \alpha}$</td><td>$\alpha$</td><td>$2.3 \times 10^{-10} = u_\text{r}(\alpha)$</td></tr><tr><td>Impedance of free space</td><td>$Z_0$</td><td>$c \mu_0$</td><td>None</td><td>Exact</td><td>$\frac{2 h \alpha}{e^2}$</td><td>$\alpha$</td><td>$2.3 \times 10^{-10} = u_\text{r}(\alpha)$</td></tr><tr><td>Electron mass</td><td>$m_\text{e}$</td><td>$\frac{16 R_{\infty}}{c^2 \alpha \mu_0 K_\text{J}^2}$</td><td>$K_\text{J}^2$</td><td>$1.2 \times 10^{-8} \approx 2 u_\text{r}(K_\text{J})$</td><td>$\frac{2 h R_{\infty}}{c \alpha^2}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Electron molar mass</td><td>$M(\text{e})$</td><td>$A_\text{r}(\text{e}) M_\text{u}$</td><td>$A_\text{r}(\text{e})$</td><td>$2.9 \times 10^{-11} = u_\text{r}(A_\text{r}(\text{e}))$</td><td>$\frac{2 h R_{\infty} N_\text{A}}{c \alpha^2}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Unified atomic mass unit or dalton</td><td>\begin{align*}m_u &amp; = 1u \\ &amp; = 1Da\end{align*}</td><td>$\frac{16 R_{\infty}}{c^2 \alpha \mu_0 K_\text{J}^2 A_\text{r}(\text{e})}$</td><td>$K_\text{J}^2$</td><td>$1.2 \times 10^{-8} \approx 2 u_\text{r}(K_\text{J})$</td><td>$\frac{2 h R_{\infty}}{c \alpha^2 A_\text{r}(\text{e})}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Molar mass constant</td><td>$M_\text{u}$</td><td>$0.001kg\cdot mol^{−1}$</td><td>None</td><td>Exact</td><td>$\frac{2 h R_{\infty} N_\text{A}}{c \alpha^2 A_\text{r}(\text{e})}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Avogadro constant</td><td>$N_\text{A}$</td><td>$\frac{c^2 \alpha \mu_0 K_\text{J}^2 A_\text{r}(\text{e}) M_\text{u}}{16 R_{\infty}}$</td><td>$K_\text{J}^2$</td><td>$1.2 \times 10^{-8} \approx 2 u_\text{r}(K_\text{J})$</td><td>$6.02214076\times10^{23} mol^{−1}$</td><td>None</td><td>Exact</td></tr><tr><td>Atomic mass of carbon-12</td><td>$m(^{12}\text{C})$</td><td>$\frac{192 R_{\infty}}{c^2 \alpha \mu_0 K_\text{J}^2 A_\text{r}(\text{e})}$</td><td>$K_\text{J}^2$</td><td>$1.2 \times 10^{-8} \approx 2 u_\text{r}(K_\text{J})$</td><td>$\frac{24 h R_{\infty}}{c \alpha^2 A_\text{r}(\text{e})}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Molar mass of carbon-12</td><td>$M(^{12}\text{C})$</td><td>$0.012kg\cdot mol^{−1}$</td><td>None</td><td>Exact</td><td>$\frac{24 h R_{\infty} N_\text{A}}{c \alpha^2 A_\text{r}(\text{e})}$</td><td>$\alpha^2$</td><td>$4.7 \times 10^{-10} \approx 2 u_\text{r}(\alpha)$</td></tr><tr><td>Faraday constant</td><td>$F$</td><td>$\frac{c \alpha^2 K_\text{J} A_\text{r}(\text{e}) M_\text{u}}{4 R_{\infty}}$</td><td>$K_\text{J}, \alpha^2$</td><td>$6.2 \times 10^{-9} \approx u_\text{r}(K_\text{J})$</td><td>$e N_\text{A}$</td><td>None</td><td>Exact</td></tr><tr><td>Temperature of triple point of water</td><td>$T_\text{TPW}$</td><td>273.16 K</td><td>None</td><td>Exact</td><td>$T_\text{TPW}$</td><td>$T_\text{TPW}$</td><td>$5.7 \times 10^{-7} = u_\text{r}(T_\text{TPW})$</td></tr><tr><td>Molar gas constant</td><td>$R$</td><td>$R$</td><td>$R$</td><td>$5.7 \times 10^{-7} = u_\text{r}(R)$</td><td>$k N_\text{A}$</td><td>None</td><td>Exact</td></tr><tr><td>Boltzmann constant</td><td>$k$</td><td>$\frac{16 R R_{\infty}}{c^2 \alpha \mu_0 K_\text{J}^2 A_\text{r}(\text{e}) M_\text{u}}$</td><td>$R$</td><td>$5.7 \times 10^{-7} \approx u_\text{r}(R)$</td><td>$1.380649\times10^{-23} kg\cdot m^2\cdot K^{−1} \cdot s^{−2}$</td><td>None</td><td>Exact</td></tr><tr><td>Stefan–Boltzmann constant</td><td>$\sigma$</td><td>$\frac{256 \pi^5 R^4 R_{\infty}^4}{15 c^7 \alpha^7 \mu_0 K_\text{J}^2 A_\text{r}(\text{e})^4 M_\text{u}^4}$</td><td>$R^4$</td><td>$2.3 \times 10^{-6} \approx 4 u_\text{r}(R)$</td><td>$\frac{2 \pi^5 k^4}{15 h^3 c^2}$</td><td>None</td><td>Exact</td></tr></tbody></table><p></p></div><br>注：其中，$c$ 为光速（speed of light），$\alpha$ 为精细结构常数（fine-structure constant），$R_\infty$ 为里德伯常量（Rydberg constant）。<p></p><p>参考文章：<br><a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units" target="_blank" rel="noopener">Redefinition of SI base units</a><br><a href="https://en.wikipedia.org/wiki/International_System_of_Units" target="_blank" rel="noopener">国际单位制</a></p><p>拓展阅读：<br><a href="https://mp.weixin.qq.com/s/bYIHtP3B33rPAHYWIvNatQ" target="_blank" rel="noopener">刚刚，『千克』被重新定义！大 K 从此成为历史</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;国际单位制以一组基本单位为基础，所有其他单位都是用基本单位建立起来的。麦克斯韦最初提出一致单位制的概念时，列出了三个可用的基本单位：质量、长度及时间单位。之后，吉奥尔吉提倡加入电的基本单位。理论上，电流、电势、电阻、电荷等物理量的单位都可以做基本单位，当选定其中一个做基本单位后，其余的电单位都可以通过物理定律从基本单位推导得出；国际单位制最终选择了使用电流。后期又加入了三个分别量度物质的量、温度及发光强度的基本单位。&lt;br&gt;国际单位制希望其单位定义的基准是源自于对自然的测量。但此单位制于 1799 在法国被引入时，由当时技术上的限制，因此利用了米原器与千克原器做为米与千克的定义。&lt;br&gt;1960 年，米的定义被改写为由特定光源所发出的光波长（后又改为根据真空光速定义），因此米定义的基准也成为了对自然测量的结果。现今，只留下了千克还是以人造的物品做为定义的基准。&lt;br&gt;&lt;strong&gt;2018 年 11 月 16 日，第 26 届国际计量大会一致通过了新国际单位制基本单位定义的提案。新的定义将于 2019 年 5 月 20 日生效。&lt;/strong&gt;&lt;br&gt;国际度量衡局提案，除了光速以外，下列所示的四个自然常数也应被定义为确定的数值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普朗克常数 $h=6.62607015\times10^{−34}(J\cdot s)$&lt;/li&gt;
&lt;li&gt;基本电荷 $e=1.602176634\times10^{−19}(C)$&lt;/li&gt;
&lt;li&gt;玻尔兹曼常数 $k=1.380649\times10^{−23}(J\cdot K^{−1})$&lt;/li&gt;
&lt;li&gt;阿伏伽德罗常量 $N_A=6.02214076\times10^{23}(mol^{−1})$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些常数在 2006 年版的 SI 指南就已经出现，但在此版本中后三个常数被定义为『由实验所得的常数』，而不是直接的『定义常数』。&lt;br&gt;国际度量衡局也提案，以下这些自然常数的数值应继续保持不变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光速 $c=299,792,458(m\cdot s^{-1})$&lt;/li&gt;
&lt;li&gt;铯 133 原子基态超精细能级分裂频率 $\Delta\nu(^{133}Cs)_{hfs}=9,192,631,770(Hz)$&lt;/li&gt;
&lt;li&gt;频率为 $540\times10^{12}Hz$ 辐射的发光效率 $K_{cd}=683(lm\cdot W^{-1})$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是以上七个定义改写为以基本单位表示的形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\Delta\nu(^{133}Cs)_{hfs}=9,192,631,770(s^{−1})$&lt;/li&gt;
&lt;li&gt;$c=299,792,458(m\cdot s^{−1})$&lt;/li&gt;
&lt;li&gt;$h=6.62607015\times10^{−34}(kg\cdot m^2\cdot s^{−1})$&lt;/li&gt;
&lt;li&gt;$e=1.602176634\times10^{−19}(A\cdot s)$&lt;/li&gt;
&lt;li&gt;$k=1.380649\times10^{−23}(kg\cdot m^2\cdot K^{−1}\cdot s^{−2})$&lt;/li&gt;
&lt;li&gt;$N_A=6.02214076\times1023(mol^{−1})$&lt;/li&gt;
&lt;li&gt;$K_{cd}=683(cd\cdot sr\cdot s^3\cdot kg^{−1}\cdot m^{−2})$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外国际度量衡局也要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目前千克的定义应废除并使国际千克原器退休&lt;/li&gt;
&lt;li&gt;目前安培的定义应废除&lt;/li&gt;
&lt;li&gt;目前开尔文的定义应废除&lt;/li&gt;
&lt;li&gt;目前摩尔的定义应修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些改变会影响到基本单位的定义，但对于导出单位的表达形式则不会有所影响。&lt;/p&gt;
    
    </summary>
    
      <category term="物理" scheme="https://zhangshuqiao.org/categories/%E7%89%A9%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>在网页上实现 3D Touch 效果</title>
    <link href="https://zhangshuqiao.org/2018-11/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E5%AE%9E%E7%8E%B03D%20Touch%E6%95%88%E6%9E%9C/"/>
    <id>https://zhangshuqiao.org/2018-11/在网页上实现3D Touch效果/</id>
    <published>2018-11-18T12:52:12.000Z</published>
    <updated>2018-12-26T06:43:59.757Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018-11/3d_touch_cover_.jpg" alt=""></p><p>2016 年 9 月 14 日凌晨，iOS 10 正式版开始向用户推送更新，而 iOS 10 搭载的 Safari10 亦带来了不少新特性，其中就有 3D Touch 事件的支持（官方文档<a href="https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html" target="_blank" rel="noopener">《What’s New in Safari 10》</a>）。</p><h2 id="Force-Touch-与-3D-Touch"><a href="#Force-Touch-与-3D-Touch" class="headerlink" title="Force Touch 与 3D Touch"></a>Force Touch 与 3D Touch</h2><p>说到 3D Touch 不能不提与之相似的 Force Touch。Force Touch 是苹果公司在 2014 年 9 月公布的一项压力敏感屏幕技术，最早用于 Apple Watch，可识别轻点、轻按两种操作。随后 Force Touch 于 2015 年 9 月在 iPhone 6S 上得到改进并更名为 3D Touch，提供了更高灵敏度的触控力度识别、及更强的触感反馈，支持轻点、轻按及重按三个维度。</p><p>支持 3D Touch 的设备，目前有 iPhone 6S、iPhone 6S Plus、iPhone 7 以及 iPhone 7 Plus（注：截止 2018 年，还要加上 iPhone 8 和 iPhone X 等）。这是后文的硬件要求。</p><h2 id="感受-3D-Touch"><a href="#感受-3D-Touch" class="headerlink" title="感受 3D Touch"></a>感受 3D Touch</h2><p>3D Touch 最为典型的交互有 Quick Actions 和 Peek and Pop 两种。在 APP 图标上重按呼出一组快捷操作菜单，这即是典型的 Quick Actions：</p><p><img src="/images/2018-11/quick_actions.jpg" alt=""></p><p>而使用 Peek and Pop 则可以快速地对内容进行预览，以及后续的其他操作：</p><p><img src="/images/2018-11/peek_and_pop.jpg" alt=""></p><p>如上图所示，在系统的邮件 APP 中，以一定的力度按压邮件列表中的某一项，会触发 Peek 弹出一个内容预览窗口（在 Peek 状态下上滑还能触发 Quick Actions 调出一些快捷操作项哦），如果继续加大按压力度，则会触发 Pop 进入邮件内容界面，这整个过程就称之为 Peek and Pop。</p><p>除了邮件 APP 以外，信息、照片等多个系统 APP 以及一些第三方 APP（如微信、Facebook、Twitter 等）也都很好的支持了 Peek and Pop 这种 3D Touch 交互形式。</p><h2 id="网页中的-3D-Touch"><a href="#网页中的-3D-Touch" class="headerlink" title="网页中的 3D Touch"></a>网页中的 3D Touch</h2><p>要在网页中实现 3D Touch，需要用到以下两个知识点：</p><ul><li><p>touch.force<br>在 touch 对象中包含有一个名为 <code>force</code> 的只读属性，它的取值从 0 到 1，表示的是触碰点的按压力度，0 表示没有检测到压力，而 1 则是设备能识别出的最大压力。</p></li><li><p>touchforcechange<br><code>touchforcechange</code> 是 Safari 10 新增的事件，该事件会在按压力度改变时被触发。</p></li></ul><p>（注：在 MacOS Safari 上也有与之对应的 <code>webkitmouseforcechanged</code> 事件，该事件会在支持 Force Touch 的 Trackpad 上反应出按压力度值 force 的变化，但本文仅讨论手机设备的情况）</p><h2 id="实现-3D-Touch-效果"><a href="#实现-3D-Touch-效果" class="headerlink" title="实现 3D Touch 效果"></a>实现 3D Touch 效果</h2><p>要实现 3D Touch 效果，关键在于实时地获取 touch.force 的值。而由于网页上的 3D Touch 很大程度上受限于设备及浏览器的支持情况，因此我们划分以下 3 种情况，分别来看看要如何实现：</p><ul><li><p>支持 3D Touch 且升级到了 iOS 10 的设备<br>在这种最为理想的情况下，只需要监听 touchforcechange 事件即可获取到 force 的当前值，将 force 值的变化以适当的形式反馈在界面上以实现 3D Touch 效果。</p></li><li><p>支持 3D Touch 但系统版本低于 iOS 10 的设备<br>这种情况虽然无法监听 touchforcechange 事件，但 Touch 对象的 force 属性仍然可以反应出正确的按压力度，可以巧妙地设置一个定时器，以轮询的方式获取 force 的当前值。</p></li><li><p>不支持 3D Touch 的设备<br>这种情况下 touch.force 的取值始终为 0，虽然可以用长按的交互形式来代替，但建议还是以优雅降级的方式，索性就不处理了吧。</p></li></ul><h2 id="一个-3D-Touch-的例子"><a href="#一个-3D-Touch-的例子" class="headerlink" title="一个 3D Touch 的例子"></a>一个 3D Touch 的例子</h2><p>看到这里你肯定想说 “Shut up and show me the code…”。好的，那我们来看一个例子，在这个示例页面，用支持 3D Touch 的设备按压蓝色按钮可以将树懒兄逗笑哦，嘿嘿嘿～</p><a id="more"></a><p><img src="/images/2018-11/demo.png" alt=""></p><p>你可扫描以上二维码，或<a href="http://jdc.jd.com/demo/3d-touch" target="_blank" rel="noopener">戳我进行预览</a>，<strong> 注意请使用 iOS Safari 浏览器进行访问！使用 iOS Safari 浏览器！！使用 iOS Safari 浏览器！！！</strong> 重要的事情要说三遍，因为目前微信 WebView 并不支持 3D Touch。</p><p>实现思路其实比较简单，根据刚刚说到的知识，我们分别监听 touchforcechange、touchstart、touchend、touchcancel 事件：</p><ul><li>在 touchstart 事件中，启动一个定时器轮询地去获取 touch.force 的值；</li><li>在 touchforcechange 事件中获取当前 touch.force 的值，并清除 touchstart 事件中设置的定时器，因为支持 touchforcechange 事件的话就没必要轮询了；</li><li>在 touchend 及 touchcancel 事件中把 touch.force 重置为 0，并清除定时器。</li></ul><p>而树懒兄大笑的动画则用的是以下这张雪碧图，根据当前 touch.force 值来设置 background-position 以显示对应的动画帧来实现的。</p><p><img src="/images/2018-11/sloth.png" alt=""></p><p>你可以访问这个 <a href="https://github.com/hihuimin/3d-touch" target="_blank" rel="noopener">Github 项目</a> 来查看源码，核心代码位于 ThreeDTouch.js，该文件封装了一个名为 ThreeDTouch 的类，事例化时传入一个 DOM 对象即可在 callback 中获取到按压力度值的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3D Touch 事件处理器，传入要监听的 DOM 对象，在 callback 回调中获取当前 force 值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123; HTMLElement &#125; el - 要监听的 DOM 对象</span></span><br><span class="line"><span class="comment"> * @param &#123; Function &#125; callback - 带有 force 值的回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThreeDTouch</span>(<span class="params">el, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.el = el</span><br><span class="line">    <span class="keyword">this</span>.callback = callback</span><br><span class="line">    <span class="keyword">this</span>._bindEvents()</span><br><span class="line">&#125;</span><br><span class="line">ThreeDTouch.prototype = &#123;</span><br><span class="line">    <span class="comment">// 绑定相关 touch 事件</span></span><br><span class="line">    _bindEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> events = [<span class="string">'touchforcechange'</span>, <span class="string">'touchstart'</span>, <span class="string">'touchend'</span>, <span class="string">'touchcancel'</span>]</span><br><span class="line">        events.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.el.addEventListener(event, <span class="keyword">this</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 分派 touch 事件</span></span><br><span class="line">    handleEvent: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (ev.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'touchforcechange'</span>:</span><br><span class="line">                <span class="keyword">this</span>._touchForceDidChange(ev)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'touchstart'</span>:</span><br><span class="line">                <span class="keyword">this</span>._touchDidStart(ev)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'touchend'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'touchcancel'</span>:</span><br><span class="line">                <span class="keyword">this</span>._touchDidEnd(ev)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//force 值改变时</span></span><br><span class="line">    _touchForceDidChange: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> force = ev.touches[<span class="number">0</span>].force</span><br><span class="line">        <span class="keyword">this</span>.callback(force)</span><br><span class="line">        clearTimeout(<span class="keyword">this</span>.timeoutId) <span class="comment">// 支持 touchforcechange 的话则取消轮询</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _touchDidStart: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> touch = ev.touches[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>._checkForce(touch)</span><br><span class="line">    &#125;,</span><br><span class="line">    _touchDidEnd: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callback(<span class="number">0</span>)</span><br><span class="line">        clearTimeout(<span class="keyword">this</span>.timeoutId)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 轮询地获取 force 值</span></span><br><span class="line">    _checkForce: <span class="function"><span class="keyword">function</span>(<span class="params">touch</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callback(touch.force)</span><br><span class="line">        <span class="keyword">this</span>.timeoutId = setTimeout(<span class="keyword">this</span>._checkForce.bind(<span class="keyword">this</span>, touch), <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文转载自：<a href="https://aotu.io/notes/2016/09/28/3d-touch" target="_blank" rel="noopener">在网页上实现 3D Touch 效果 - 凹凸实验室</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018-11/3d_touch_cover_.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2016 年 9 月 14 日凌晨，iOS 10 正式版开始向用户推送更新，而 iOS 10 搭载的 Safari10 亦带来了不少新特性，其中就有 3D Touch 事件的支持（官方文档&lt;a href=&quot;https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《What’s New in Safari 10》&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;Force-Touch-与-3D-Touch&quot;&gt;&lt;a href=&quot;#Force-Touch-与-3D-Touch&quot; class=&quot;headerlink&quot; title=&quot;Force Touch 与 3D Touch&quot;&gt;&lt;/a&gt;Force Touch 与 3D Touch&lt;/h2&gt;&lt;p&gt;说到 3D Touch 不能不提与之相似的 Force Touch。Force Touch 是苹果公司在 2014 年 9 月公布的一项压力敏感屏幕技术，最早用于 Apple Watch，可识别轻点、轻按两种操作。随后 Force Touch 于 2015 年 9 月在 iPhone 6S 上得到改进并更名为 3D Touch，提供了更高灵敏度的触控力度识别、及更强的触感反馈，支持轻点、轻按及重按三个维度。&lt;/p&gt;
&lt;p&gt;支持 3D Touch 的设备，目前有 iPhone 6S、iPhone 6S Plus、iPhone 7 以及 iPhone 7 Plus（注：截止 2018 年，还要加上 iPhone 8 和 iPhone X 等）。这是后文的硬件要求。&lt;/p&gt;
&lt;h2 id=&quot;感受-3D-Touch&quot;&gt;&lt;a href=&quot;#感受-3D-Touch&quot; class=&quot;headerlink&quot; title=&quot;感受 3D Touch&quot;&gt;&lt;/a&gt;感受 3D Touch&lt;/h2&gt;&lt;p&gt;3D Touch 最为典型的交互有 Quick Actions 和 Peek and Pop 两种。在 APP 图标上重按呼出一组快捷操作菜单，这即是典型的 Quick Actions：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11/quick_actions.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而使用 Peek and Pop 则可以快速地对内容进行预览，以及后续的其他操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11/peek_and_pop.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在系统的邮件 APP 中，以一定的力度按压邮件列表中的某一项，会触发 Peek 弹出一个内容预览窗口（在 Peek 状态下上滑还能触发 Quick Actions 调出一些快捷操作项哦），如果继续加大按压力度，则会触发 Pop 进入邮件内容界面，这整个过程就称之为 Peek and Pop。&lt;/p&gt;
&lt;p&gt;除了邮件 APP 以外，信息、照片等多个系统 APP 以及一些第三方 APP（如微信、Facebook、Twitter 等）也都很好的支持了 Peek and Pop 这种 3D Touch 交互形式。&lt;/p&gt;
&lt;h2 id=&quot;网页中的-3D-Touch&quot;&gt;&lt;a href=&quot;#网页中的-3D-Touch&quot; class=&quot;headerlink&quot; title=&quot;网页中的 3D Touch&quot;&gt;&lt;/a&gt;网页中的 3D Touch&lt;/h2&gt;&lt;p&gt;要在网页中实现 3D Touch，需要用到以下两个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;touch.force&lt;br&gt;在 touch 对象中包含有一个名为 &lt;code&gt;force&lt;/code&gt; 的只读属性，它的取值从 0 到 1，表示的是触碰点的按压力度，0 表示没有检测到压力，而 1 则是设备能识别出的最大压力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;touchforcechange&lt;br&gt;&lt;code&gt;touchforcechange&lt;/code&gt; 是 Safari 10 新增的事件，该事件会在按压力度改变时被触发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（注：在 MacOS Safari 上也有与之对应的 &lt;code&gt;webkitmouseforcechanged&lt;/code&gt; 事件，该事件会在支持 Force Touch 的 Trackpad 上反应出按压力度值 force 的变化，但本文仅讨论手机设备的情况）&lt;/p&gt;
&lt;h2 id=&quot;实现-3D-Touch-效果&quot;&gt;&lt;a href=&quot;#实现-3D-Touch-效果&quot; class=&quot;headerlink&quot; title=&quot;实现 3D Touch 效果&quot;&gt;&lt;/a&gt;实现 3D Touch 效果&lt;/h2&gt;&lt;p&gt;要实现 3D Touch 效果，关键在于实时地获取 touch.force 的值。而由于网页上的 3D Touch 很大程度上受限于设备及浏览器的支持情况，因此我们划分以下 3 种情况，分别来看看要如何实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持 3D Touch 且升级到了 iOS 10 的设备&lt;br&gt;在这种最为理想的情况下，只需要监听 touchforcechange 事件即可获取到 force 的当前值，将 force 值的变化以适当的形式反馈在界面上以实现 3D Touch 效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持 3D Touch 但系统版本低于 iOS 10 的设备&lt;br&gt;这种情况虽然无法监听 touchforcechange 事件，但 Touch 对象的 force 属性仍然可以反应出正确的按压力度，可以巧妙地设置一个定时器，以轮询的方式获取 force 的当前值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不支持 3D Touch 的设备&lt;br&gt;这种情况下 touch.force 的取值始终为 0，虽然可以用长按的交互形式来代替，但建议还是以优雅降级的方式，索性就不处理了吧。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一个-3D-Touch-的例子&quot;&gt;&lt;a href=&quot;#一个-3D-Touch-的例子&quot; class=&quot;headerlink&quot; title=&quot;一个 3D Touch 的例子&quot;&gt;&lt;/a&gt;一个 3D Touch 的例子&lt;/h2&gt;&lt;p&gt;看到这里你肯定想说 “Shut up and show me the code…”。好的，那我们来看一个例子，在这个示例页面，用支持 3D Touch 的设备按压蓝色按钮可以将树懒兄逗笑哦，嘿嘿嘿～&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="https://zhangshuqiao.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://zhangshuqiao.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用示波器播放 Bad Apple!!</title>
    <link href="https://zhangshuqiao.org/2018-11/%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%B3%A2%E5%99%A8%E6%92%AD%E6%94%BEBad%20Apple!!/"/>
    <id>https://zhangshuqiao.org/2018-11/使用示波器播放Bad Apple!!/</id>
    <published>2018-11-14T02:09:01.000Z</published>
    <updated>2018-11-19T05:06:57.251Z</updated>
    
    <content type="html"><![CDATA[<p>本视频于某次物理竞赛集训时拍摄于华中科技大学，音频为后期加上。<br>为了对上音轨，前后各有一段黑屏，这是 feature 而非 bug。</p><video src="/files/badapple.mp4" preload="metadata" controls playsinline="" poster="/images/2018-11/flandre_scarlet.jpg" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"><br>Your browser does not support the video tag<br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本视频于某次物理竞赛集训时拍摄于华中科技大学，音频为后期加上。&lt;br&gt;为了对上音轨，前后各有一段黑屏，这是 feature 而非 bug。&lt;/p&gt;
&lt;video src=&quot;/files/badapple.mp4&quot; preload=&quot;metadata&quot; controls pl
      
    
    </summary>
    
      <category term="物理" scheme="https://zhangshuqiao.org/categories/%E7%89%A9%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Telnet 观看 Nyancat 动画</title>
    <link href="https://zhangshuqiao.org/2018-11/%E7%94%A8Telnet%E8%A7%82%E7%9C%8BNyancat%E5%8A%A8%E7%94%BB/"/>
    <id>https://zhangshuqiao.org/2018-11/用Telnet观看Nyancat动画/</id>
    <published>2018-11-08T14:36:23.000Z</published>
    <updated>2018-12-22T18:31:35.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在知乎上看到一个关于 VPS 有趣的用途的问题，<a href="https://www.zhihu.com/question/24284566/answer/27291403" target="_blank" rel="noopener">其中一个回答</a>提到了可以搭建 Telnet 服务器，成功运行后别人用 Telnet 连接你的主机将会看到 Nyancat 动画。大致效果如图所示：</p><p><img src="/images/2018-11/nyancat.png" alt=""></p><p>然而，回答中给出的 Demo 已经失效，<code>telnet nyancat.dakko.us</code> 会返回一个 <code>Connection refused</code> 错误。不过值得庆幸的是，这个项目的官方网站 <a href="http://nyancat.dakko.us" target="_blank" rel="noopener">Nyan Cat Telnet Server</a> 和<a href="https://github.com/klange/nyancat" target="_blank" rel="noopener">GitHub 项目地址</a>都还可以正常访问，因此可以尝试重新把它搭起来。你可以查看博主建立的镜像：<code>telnet zsq.im 8081</code>，这是按以下方法搭建好的结果。</p><h2 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h2><p>在命令行执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/klange/nyancat.git</span><br><span class="line"><span class="built_in">cd</span> nyancat</span><br><span class="line">make &amp;&amp; <span class="built_in">cd</span> src</span><br><span class="line">mv nyancat usr/<span class="built_in">local</span>/bin <span class="comment">#or make install</span></span><br></pre></td></tr></table></figure></p><p>这时，通过 <code>nyancat</code> 或 <code>nyancat -t</code> 命令就可以查看效果。接下来把 Telnet 配置好就行了。</p><h2 id="配置-Telnet"><a href="#配置-Telnet" class="headerlink" title="配置 Telnet"></a>配置 Telnet</h2><p>使用包管理工具安装 <code>xinetd</code>，例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install xinetd</span><br></pre></td></tr></table></figure></p><p>然后在 <code>/etc/xinetd.d</code> 目录下新建文件 <code>nyancat</code>，内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    flags          = REUSE</span><br><span class="line">    socket_type    = stream</span><br><span class="line">    <span class="built_in">wait</span>           = no</span><br><span class="line">    user           = root</span><br><span class="line">    group          = root</span><br><span class="line">    server         = /usr/<span class="built_in">local</span>/bin/nyancat</span><br><span class="line">    server_args    = -t</span><br><span class="line">    log_on_failure += USERID</span><br><span class="line">    <span class="built_in">disable</span>        = no</span><br><span class="line">    instances      = 10</span><br><span class="line">    per_source     = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>instances</code> 和 <code>per_source</code> 限制了总的连接数和单个 IP 的连接数，以防止资源滥用（其实并没有什么用，DDOS 攻击该来还是会来）。<br>接下来，重启 <code>xinetd</code> 服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart xinetd</span><br></pre></td></tr></table></figure></p><p>这时，你就可以通过 <code>telnet localhost</code> 查看是否一切正常。如果没有问题，配置防火墙开放 23 端口，就可以从公网访问了。试试用 Telnet 连接你的主机，效果是不是非常酷炫？<br>不过，博主在实践中发现，开放 telnet 的 23 端口可能会产生大量异常流量。解决方法是修改 telnet 的端口号，编辑 <code>/etc/services</code>，找到 telnet，将 23 改为一个你喜欢的数字（比如 8081）；或者直接关闭这个服务，在 <code>nyancat</code> 中设置 <code>disable: yes</code> 即可。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>俗话说，有光的地方就有 Bad Apple!!。很久以前的一篇文章 <a href="/2017-12 / 近期完成的数个游戏及应用 /">近期完成的数个游戏及应用</a> 中，就提到博主成功使用 HTML 页面播放 Bad Apple!! 字符画。目前，博主正在尝试搭建一个可以播放 Bad Apple!! 的 Telnet 服务器，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在知乎上看到一个关于 VPS 有趣的用途的问题，&lt;a href=&quot;https://www.zhihu.com/question/2428
      
    
    </summary>
    
      <category term="技术" scheme="https://zhangshuqiao.org/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zhangshuqiao.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Heavens Above 爬虫的实现</title>
    <link href="https://zhangshuqiao.org/2018-10/Heavens%20Above%E7%88%AC%E8%99%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangshuqiao.org/2018-10/Heavens Above爬虫的实现/</id>
    <published>2018-10-23T03:00:19.000Z</published>
    <updated>2018-12-22T18:14:04.707Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.heavens-above.com" target="_blank" rel="noopener">Heavens Above</a> 是一个天文数据库网站，可以查询到诸如卫星过境的很多信息。虽然数据很全面，但是检索方式非常繁琐，在网站上需要依次打开多个链接进行比对，难以迅速地获取需要的信息。故博主决定写一个爬虫，以直观地展现所有数据。由于 Heavens Above 采取了大量的反爬虫措施，例如校验 Cookie、限制单个 IP 的访问次数等，因此必须严格地模拟浏览器请求，才能正确爬取数据。</p><p><img src="/images/2018-10/iss.png" alt=""></p><p>博主也参考了大量 GitHub 上已有的 Heavens Above 爬虫项目，不过它们大部分失去维护，停留在数年前，已经不再适用。具体的逻辑还是要自行测试。</p><p>项目地址：<a href="https://github.com/stevenjoezhang/heavens-above" target="_blank" rel="noopener">heavens-above</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.heavens-above.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Heavens Above&lt;/a&gt; 是一个天文数据库网站，可以查询到诸如卫星过境的很多信息。虽然数据很全面，但是检索方式非常繁琐，在
      
    
    </summary>
    
      <category term="程序设计" scheme="https://zhangshuqiao.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="GitHub" scheme="https://zhangshuqiao.org/tags/GitHub/"/>
    
      <category term="天文" scheme="https://zhangshuqiao.org/tags/%E5%A4%A9%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Thanks for inventing Javascript</title>
    <link href="https://zhangshuqiao.org/2018-10/Thanks%20for%20inventing%20Javascript/"/>
    <id>https://zhangshuqiao.org/2018-10/Thanks for inventing Javascript/</id>
    <published>2018-10-20T08:48:17.000Z</published>
    <updated>2018-12-19T04:07:06.967Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018-10/thanks-for-inventing-javascript.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2018-10/thanks-for-inventing-javascript.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="幽默" scheme="https://zhangshuqiao.org/categories/%E5%B9%BD%E9%BB%98/"/>
    
    
      <category term="JavaScript" scheme="https://zhangshuqiao.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCV 进行星轨的后期处理</title>
    <link href="https://zhangshuqiao.org/2018-10/%E4%BD%BF%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E6%98%9F%E8%BD%A8%E7%9A%84%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>https://zhangshuqiao.org/2018-10/使用OpenCV进行星轨的后期处理/</id>
    <published>2018-10-10T11:33:26.000Z</published>
    <updated>2018-12-16T15:06:19.264Z</updated>
    
    <content type="html"><![CDATA[<p>贴上代码，稍后填坑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addImage</span><span class="params">(img1_path, img2_path, alpha = <span class="number">0.5</span>)</span>:</span></span><br><span class="line">    img1 = cv2.imread(img1_path)</span><br><span class="line">    img = cv2.imread(img2_path)</span><br><span class="line">    h, w, _ = img1.shape</span><br><span class="line">    beta = <span class="number">1</span> - alpha</span><br><span class="line">    gamma = <span class="number">0</span></span><br><span class="line">    img_add = cv2.addWeighted(img1, alpha, img2, beta, gamma)</span><br><span class="line">    <span class="keyword">return</span> img_add</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    img_root = <span class="string">''</span> <span class="comment"># 这里写你的文件夹路径，比如：/home/youname/data/img/ 注意最后一个文件夹要有斜杠 </span></span><br><span class="line">    fps = <span class="number">24</span> <span class="comment"># 保存视频的 FPS，可以适当调整</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以用(*'DVIX') 或(*'X264')，如果都不行先装 ffmepg: sudo apt install ffmepg</span></span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*<span class="string">'MJPG'</span>)</span><br><span class="line">    videoWriter = cv2.VideoWriter(<span class="string">'saveVideo.mp4v'</span>, fourcc, fps, (<span class="number">3168</span>, <span class="number">4752</span>))<span class="comment"># 最后一个是保存图片的尺寸</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">99</span>):</span><br><span class="line">        <span class="comment">#frame = cv2.imread(img_root+str(i+1)+'.jpg')</span></span><br><span class="line">        frame = addImage(<span class="string">'IMG_3866.jpg'</span>, <span class="string">'IMG_3869.jpg'</span>)</span><br><span class="line">        videoWriter.write(frame)</span><br><span class="line">    videoWriter.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    folder = input(<span class="string">" 请输入照片所在文件夹 "</span>) <span class="keyword">or</span> <span class="string">'.'</span></span><br><span class="line">    prefix = input(<span class="string">" 请输入照片前缀 "</span>) <span class="keyword">or</span> <span class="string">'IMG_'</span></span><br><span class="line">    suffix = input(<span class="string">" 请输入照片后缀 "</span>) <span class="keyword">or</span> <span class="string">'jpg'</span></span><br><span class="line">    digits = int(input(<span class="string">" 请输入照片序号位数 "</span>) <span class="keyword">or</span> <span class="number">4</span>)</span><br><span class="line">    start = int(input(<span class="string">" 请输入第一张照片序号 "</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">    end = int(input(<span class="string">" 请输入最后一张照片序号 "</span>) <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">    fps = int(input(<span class="string">" 请输入视频帧率 "</span>) <span class="keyword">or</span> <span class="number">24</span>)</span><br><span class="line">    fpp = int(input(<span class="string">" 请输入每张照片持续的帧数 "</span>) <span class="keyword">or</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    imgArray = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">        imgPath = folder + <span class="string">"/"</span> + prefix + i + <span class="string">"."</span> + suffix</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(imgPath):</span><br><span class="line">            imgArray.append(imgPath)</span><br><span class="line"></span><br><span class="line">    h, w, _ = imgArray[<span class="number">0</span>].shape</span><br><span class="line">    fourcc = cv2.VideoWriter_fourcc(*<span class="string">'MJPG'</span>)</span><br><span class="line">    videoWriter = cv2.VideoWriter(<span class="string">'saveVideo.mp4v'</span>, fourcc, fps, (w, h))</span><br><span class="line">    frame = cv2.imread(imgArray[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#videoWriter.write(frame)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(imgArray)):</span><br><span class="line">        <span class="comment">#frame = cv2.imread(img_root+str(i+1)+'.jpg')</span></span><br><span class="line">        frame = addImage(frame, imgArray[i], i / (i + <span class="number">1</span>))</span><br><span class="line">        videoWriter.write(frame)</span><br><span class="line">        print(i + <span class="string">'/'</span> + (i + <span class="number">1</span>))</span><br><span class="line">    videoWriter.release()</span><br></pre></td></tr></table></figure></p><p>参考文章：<br><a href="https://blog.csdn.net/zh_jessica/article/details/77992578" target="_blank" rel="noopener">Python-OpenCV 图像叠加 or 图像混合加权</a><br><a href="https://blog.csdn.net/aa846555831/article/details/53070314" target="_blank" rel="noopener">python + opencv 将图片保存为视频</a></p><p>拓展阅读：<a href="http://www.imgzone.cn/article-377-1.html" target="_blank" rel="noopener">叠加法星轨的拍摄及后期方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;贴上代码，稍后填坑。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
      <category term="程序设计" scheme="https://zhangshuqiao.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Python" scheme="https://zhangshuqiao.org/tags/Python/"/>
    
      <category term="天文" scheme="https://zhangshuqiao.org/tags/%E5%A4%A9%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>古惑狼游戏牵扯出的硬件 bug</title>
    <link href="https://zhangshuqiao.org/2018-10/%E5%8F%A4%E6%83%91%E7%8B%BC%E6%B8%B8%E6%88%8F%E7%89%B5%E6%89%AF%E5%87%BA%E7%9A%84%E7%A1%AC%E4%BB%B6bug/"/>
    <id>https://zhangshuqiao.org/2018-10/古惑狼游戏牵扯出的硬件bug/</id>
    <published>2018-10-04T00:41:46.000Z</published>
    <updated>2018-12-25T08:49:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>It’s kind of painful to re-live this one. As a programmer, you learn to blame your code first, second, and third… and somewhere around 10,000th you blame the compiler. Well down the list after that, you blame the hardware.<br>回想起这个 bug，仍然让我感觉有些痛苦。作为一个程序员，在发现 bug 时，你学会了首先在自己代码中找问题，一次、两次、三次…… 或许在测试一万次之后，你会把问题归咎于编译器。只有在这所有的都不起作用之后，你才会把问题归咎于硬件。</p><p>This is my hardware bug story.<br>这是我遭遇硬件 bug 的故事。</p><p>Among other things, I wrote the memory card (load/save) code for Crash Bandicoot. For a swaggering game coder, this is like a walk in the park; I expected it would take a few days. I ended up debugging that code for six weeks. I did other stuff during that time, but I kept coming back to this bug – a few hours every few days. It was agonizing.<br>抛开别的不说，我曾为古惑狼（Crash Bandicoot，PS1 游戏）写存储卡（读写）代码。对于一个自大的游戏程序员，这就像是在公园里散步一样轻松愉快；我预计只要几天就可以写完。我最终用了六个礼拜把那些代码调试完毕。在此期间我也做过一些其他的事情，但却一直绕不开这个 bug——每几天内就要花上好几个小时来处理。这个 bug 实在烦人。</p><p>The symptom was that you’d go to save your progress and it would access the memory card, and almost all the time, it worked normally… But every once in a while the write or read would time out… for no obvious reason. A short write would often corrupt the memory card. The player would go to save, and not only would we not save, we’d wipe their memory card. D’Oh.<br>这个 bug 的症状是，当你需要保存你的进度时，代码会访问存储卡，而大部分情况下没有什么问题… 但是偶尔读写会超时… 没有任何明显的原因。一个简短的写入经常毁掉存储卡。玩家要保存进度，我们不仅不保存，还擦除他们存储卡上的全部东西。天哪。</p><p>After a while, our producer at Sony, Connie Booth, began to panic. We obviously couldn’t ship the game with that bug, and after six weeks I still had no clue what the problem was. Via Connie we put the word out to other PlayStation 1 developers – had anybody seen anything like this? Nope. Absolutely nobody had any problems with the memory card system.<br>过了一段时间，我们在 Sony 的制作人 Connie Booth 慌了。我们显然不能发布带有这个 bug 游戏，而六个星期之后我对于问题出在哪一点线索都没有。通过 Connie 我们向其他 PS1 开发者求助：有没有人出现过像我们这样的情况？没有。绝对没有任何人在存储卡系统上出现任何问题。</p><p>About the only thing you can do when you run out of ideas debugging is divide and conquer: keep removing more and more of the errant program’s code until you’re left with something relatively small that still exhibits the problem. You keep carving parts away until the only stuff left is where the bug is.<br>在你绞尽脑汁之后，你能做的唯一一个调试方法就是分而治之：一点点去除错误程序中的代码，直到留下的代码相对很少，但仍然表现出问题。像雕刻一样去除没有问题的代码，留下的就是你的 bug 所在。</p><a id="more"></a><p>The challenge with this in the context of, say, a video game is that it’s very hard to remove pieces. How do you still run the game if you remove the code that simulates gravity in the game? Or renders the characters?<br>在这样的背景下挑战在于，视频游戏是很难去除某一部分的。在你删除模拟重力或者显示字符的代码后，如何运行游戏？</p><p>What you have to do is replace entire modules with stubs that pretend to do the real thing, but actually do something completely trivial that can’t be buggy. You have to write new scaffolding code just to keep things working at all. It is a slow, painful process.<br>你必须做的是用一个假装做真正的事情，但实际上只是做很简单的不会出现 bug 事情的东西来替换掉整个模块。你必须写新的支撑代码来让这些玩意正常工作。这是一个缓慢而痛苦的过程。</p><p>Long story short: I did this. I kept removing more and more hunks of code until I ended up, pretty much, with nothing but the startup code – just the code that set up the system to run the game, initialized the rendering hardware, etc. Of course, I couldn’t put up the load/save menu at that point because I’d stubbed out all the graphics code. But I could pretend the user used the (invisible) load/save screen and asked to save, then write to the card.<br>长话短说：我做完了。我移除了大片大片的代码，相当多，只留下了初始化代码——就是准备游戏运行系统，初始化渲染硬件等等。当然，我不能显示加载 / 保存菜单，因为我掐掉了所有的图像代码。但是我能够假装用户使用（不可见的）加载 / 保存屏幕并且请求保存，然后写入卡中。</p><p>I ultimately ended up with a pretty small amount of code that exhibited the problem – but still randomly! Most of the time, it would work, but every once in a while, it would fail. Almost all of the actual Crash Bandicoot code had been removed, but it still happened. This was really baffling: the code that remained wasn’t really doing anything.<br>我最终以一个带有这个 bug 的很少量的代码结束——但问题仍然随机出现！在大多数情况下没啥问题，但是偶尔会失效。基本上所有古惑狼游戏的实际代码都被移除了，但问题还是会复现。这实在是莫名其妙：留下来的代码基本上都没做什么事。</p><p>At some moment – it was probably 3 am – a thought entered my mind. Reading and writing (I/O) involves precise timing. Whether you’re dealing with a hard drive, a compact flash card, a Bluetooth transmitter – whatever – the low-level code that reads and writes has to do so according to a clock.<br>在那时——估计是凌晨 3 点——一个想法蹦了出来。读写（I/O）涉及精确定时。无论是硬盘、存储卡、蓝牙发送器——随便啥——做读写的底层代码都是根据时钟来的。</p><p>The clock lets the hardware device – which isn’t directly connected to the CPU – stay in sync with the code the CPU is running. The clock determines the baud rate – the rate at which data is sent from one side to the other. If the timing gets messed up, the hardware or the software – or both – get confused. This is really, really bad, and usually results in data corruption.<br>时钟让不直接连接到 CPU 的硬件设备和 CPU 运行的代码同步。时钟决定了波特率——数据从一头传到另一头的速率。如果计时有什么问题，硬件或者软件或者两者都会乱七八糟的。这真的，真的很糟糕，并且通常导致数据损坏。</p><p>What if something in our setup code was messing up the timing somehow? I looked again at the code in the test program for timing-related stuff, and noticed that we set the programmable timer on the PlayStation 1 to 1 kHz (1000 ticks/second). This is relatively fast; it was running at something like 100 Hz in its default state when the PlayStation 1 started up. Most games, therefore, would have this timer running at 100 Hz.<br>如果我们的初始化代码以某种方式弄乱了计时会怎么样？我又看了一遍测试程序中和计时有关的代码，并注意到我们将 PS1 上的可编程计时器设置到了 1kHz（1000 跳每秒）。这是比较快了，当 PS1 启动的时候，默认状态大概是 100Hz。因此，大多数游戏将他们的计时器设置为 100Hz。</p><p>Andy, the lead (and only other) developer on the game, set the timer to 1 kHz so that the motion calculations in Crash Bandicoot would be more accurate. Andy likes overkill, and if we were going to simulate gravity, we ought to do it as high-precision as possible!<br>这个游戏的带头（和除我外的唯一）开发者 Andy，将计时器设置为 1kHz，使得古惑狼的动作计算更加准确。Andy 喜欢简单粗暴的做法，如果我们要模拟重力，我们应该尽可能的提高精度！</p><p>But what if increasing this timer somehow interfered with the overall timing of the program, and therefore with the clock used to set the baud rate for the memory card?<br>然而如果提高计时器频率莫名其妙的干扰了整个程序的计时，故而将这个计时器设置到存储卡的波特率上会怎样呢？</p><p>I commented the timer code out. I couldn’t make the error happen again. But this didn’t mean it was fixed; the problem only happened randomly. What if I was just getting lucky?<br>我将计时器代码注释掉。然后我就无法复现这个 bug 了。但是这并不表示 bug 被修复了，这个问题是随机发生的。万一我只是运气好呢？</p><p>As more days went on, I kept playing with my test program. The bug never happened again. I went back to the full Crash Bandicoot code base, and modified the load/save code to reset the programmable timer to its default setting (100 Hz) before accessing the memory card, then put it back to 1 kHz afterwards. We never saw the read/write problems again.<br>几天过去了，我还是在玩我的测试程序。Bug 没有再出现。我又回到完整的古惑狼游戏代码中，修改了加载 / 保存代码，在访问存储卡之前将可编程计时器重置为默认设置（100Hz），之后设置回 1kHz。从此之后没有发现问题再次出现。</p><p>But why?<br>但是… 为什么？</p><p>I returned repeatedly to the test program, trying to detect some pattern to the errors that occurred when the timer was set to 1 kHz. Eventually, I noticed that the errors happened when someone was playing with the PlayStation 1 controller. Since I would rarely do this myself – why would I play with the controller when testing the load/save code? – I hadn’t noticed it. But one day one of the artists was waiting for me to finish testing – I’m sure I was cursing at the time – and he was nervously fiddling with the controller. It failed. “Wait, what? Hey, do that again!”<br>我重新回到测试程序上，试着检测当计时器设置为 1kHz 时出现的那些错误的模式。终于，我注意到这些错误出现在使用 PS1 手柄的人身上。因为我自己很少这样做，所以我没有注意到（为啥我要在测试加载 / 保存代码的时候用手柄）。但是有一天我们的美工等我去完成测试（我确定那时候我在爆粗口），而他紧张的摆弄着手柄。卡损坏了。『等下，怎么回事？喂，再来一次！』</p><p>Once I had the insight that the two things were correlated, it was easy to reproduce: start writing to memory card, wiggle controller, corrupt memory card. Sure looked like a hardware bug to me.<br>一旦我发现了这两件事是联系着的，就很容易重现 bug：开始写入存储卡，动一下手柄，存储卡损坏。在我看来这完全是硬件 bug。</p><p>I went back to Connie and told her what I’d found. She relayed this to one of the hardware engineers who had designed the PlayStation 1.”Impossible,”she was told.”This cannot be a hardware problem.” I told her to ask if I could speak with him.<br>我去找 Connie 告诉他我的发现。她转述给设计过 PS1 的硬件工程师。她被告知：『不可能，这不可能是硬件问题。』我跟她说问一下我能不能直接和硬件工程师交流。</p><p>He called me and, in his broken English and my (extremely) broken Japanese, we argued. I finally said, “just let me send you a 30-line test program that makes it happen when you wiggle the controller.” He relented. This would be a waste of time, he assured me, and he was extremely busy with a new project, but he would oblige because we were a very important developer for Sony. I cleaned up my little test program and sent it over.<br>那个工程师给我打电话了，我们争论了起来——他用着他的烂英语，我用着我更烂的日语。我最后说：『我给你一个 30 行的测试程序，让你在动手柄的时候能够出现这问题。』他答应了。『这是浪费时间』，他向我保证，而他正忙于一个新项目，但因为我们是 Sony 的重要开发者，他会帮忙看看的。我整理了这个测试程序，然后发送给了他。</p><p>The next evening (we were in LA and he was in Tokyo, so it was evening for me when he came in the next day) he called me and sheepishly apologized. It was a hardware problem.<br>第二天晚上（我们在洛杉矶，而他在东京，所以对于我来说是晚上而他是到了第二天），他给我打电话，很难为情地向我道歉。这确实是个硬件问题。</p><p>I’ve never been totally clear on what the exact problem was, but my impression from what I heard back from Sony HQ was that setting the programmable timer to a sufficiently high clock rate would interfere with things on the motherboard near the timer crystal. One of these things was the baud rate controller for the memory card, which also set the baud rate for the controllers. I’m not a hardware guy, so I’m pretty fuzzy on the details.<br>我还是没有完全搞清楚问题到底在哪，但是我的印象中，从 Sony 总部的反馈听到的是，如果将可编程计时器设置到足够高的时钟频率，会影响到主板上时钟晶振附近的一些东西。这些东西之一就是存储卡的波特率控制器，而它同时也设置手柄的波特率。我不是搞硬件的，所以对于细节我相当模糊。</p><p>But the gist of it was that crosstalk between individual parts on the motherboard, and the combination of sending data over both the controller port and the memory card port while running the timer at 1 kHz would cause bits to get dropped… and the data lost… and the card corrupted.<br>但是主旨是主板上两个独立部分的串扰，以及手柄接口和存储卡接口数据发送的结合在 1kHz 的时钟频率下会导致丢位，从而数据丢失，以致卡损坏。</p><p>This is the only time in my entire programming life that I’ve debugged a problem caused by quantum mechanics.<br>这是我整个编程生涯中，唯一一次因为量子力学而 debug 的问题。</p><p>Footnotes for posterity:<br>后记：</p><p>A few people have pointed out that this bug really wasn’t a product of quantum mechanical effects, any more than any other bug is. Of course I was being hyperbolic mentioning quantum mechanics. But this bug did feel different to me, in that the behavior was – at least at the level of the source code – non-deterministic.<br>有小部分人指出这个 bug 实际上不是量子力学的副效应，在这点上和其它 bug 也没什么不同。当然我提到量子力学确实是夸张了。不过这个 bug 给我的感觉很不相同，特别是它的行为——至少在源代码层面上——不是很具有确定性。</p><p>Some people have said I should have taken more electronics classes. That is absolutely true; I consider myself a “full stack” programmer, but my stack really only goes down to hand-writing assembly code, not to playing with transistors. Perhaps some day I will learn more about the “bare metal”…<br>有人说我应该学习更多的电子线路课程。这当然没毛病；我自称『全栈工程师』，但我的技术栈只开到了手写汇编代码，而没有涉及晶体管之类。也许有一天我会更多地了解『裸金属』。</p><p>Finally, a few have questioned whether a better development methodology would have prevented this kind of bug in the first place. I don’t think so, but it’s possible. I use test-driven development for some coding tasks these days, but it’s doubtful we could have usefully applied these techniques given the constraints of the systems and tools we were using.<br>最后，一些人质疑一种更好的开发方法是否能够首先防止这种错误。我不这么认为，但这是可能的。我现在使用测试驱动开发来完成某些编码任务，但考虑到我们使用的系统和工具的限制，我们可以有效地应用这些技术。</p><p>本文翻译自：<a href="https://www.quora.com/Programming-Interviews/Whats-the-hardest-bug-youve-debugged/answer/Dave-Baggett" target="_blank" rel="noopener">What’s the hardest bug you’ve debugged?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;It’s kind of painful to re-live this one. As a programmer, you learn to blame your code first, second, and third… and somewhere around 10,000th you blame the compiler. Well down the list after that, you blame the hardware.&lt;br&gt;回想起这个 bug，仍然让我感觉有些痛苦。作为一个程序员，在发现 bug 时，你学会了首先在自己代码中找问题，一次、两次、三次…… 或许在测试一万次之后，你会把问题归咎于编译器。只有在这所有的都不起作用之后，你才会把问题归咎于硬件。&lt;/p&gt;
&lt;p&gt;This is my hardware bug story.&lt;br&gt;这是我遭遇硬件 bug 的故事。&lt;/p&gt;
&lt;p&gt;Among other things, I wrote the memory card (load/save) code for Crash Bandicoot. For a swaggering game coder, this is like a walk in the park; I expected it would take a few days. I ended up debugging that code for six weeks. I did other stuff during that time, but I kept coming back to this bug – a few hours every few days. It was agonizing.&lt;br&gt;抛开别的不说，我曾为古惑狼（Crash Bandicoot，PS1 游戏）写存储卡（读写）代码。对于一个自大的游戏程序员，这就像是在公园里散步一样轻松愉快；我预计只要几天就可以写完。我最终用了六个礼拜把那些代码调试完毕。在此期间我也做过一些其他的事情，但却一直绕不开这个 bug——每几天内就要花上好几个小时来处理。这个 bug 实在烦人。&lt;/p&gt;
&lt;p&gt;The symptom was that you’d go to save your progress and it would access the memory card, and almost all the time, it worked normally… But every once in a while the write or read would time out… for no obvious reason. A short write would often corrupt the memory card. The player would go to save, and not only would we not save, we’d wipe their memory card. D’Oh.&lt;br&gt;这个 bug 的症状是，当你需要保存你的进度时，代码会访问存储卡，而大部分情况下没有什么问题… 但是偶尔读写会超时… 没有任何明显的原因。一个简短的写入经常毁掉存储卡。玩家要保存进度，我们不仅不保存，还擦除他们存储卡上的全部东西。天哪。&lt;/p&gt;
&lt;p&gt;After a while, our producer at Sony, Connie Booth, began to panic. We obviously couldn’t ship the game with that bug, and after six weeks I still had no clue what the problem was. Via Connie we put the word out to other PlayStation 1 developers – had anybody seen anything like this? Nope. Absolutely nobody had any problems with the memory card system.&lt;br&gt;过了一段时间，我们在 Sony 的制作人 Connie Booth 慌了。我们显然不能发布带有这个 bug 游戏，而六个星期之后我对于问题出在哪一点线索都没有。通过 Connie 我们向其他 PS1 开发者求助：有没有人出现过像我们这样的情况？没有。绝对没有任何人在存储卡系统上出现任何问题。&lt;/p&gt;
&lt;p&gt;About the only thing you can do when you run out of ideas debugging is divide and conquer: keep removing more and more of the errant program’s code until you’re left with something relatively small that still exhibits the problem. You keep carving parts away until the only stuff left is where the bug is.&lt;br&gt;在你绞尽脑汁之后，你能做的唯一一个调试方法就是分而治之：一点点去除错误程序中的代码，直到留下的代码相对很少，但仍然表现出问题。像雕刻一样去除没有问题的代码，留下的就是你的 bug 所在。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://zhangshuqiao.org/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>关于黎曼猜想</title>
    <link href="https://zhangshuqiao.org/2018-09/%E5%85%B3%E4%BA%8E%E9%BB%8E%E6%9B%BC%E7%8C%9C%E6%83%B3/"/>
    <id>https://zhangshuqiao.org/2018-09/关于黎曼猜想/</id>
    <published>2018-09-25T02:48:48.000Z</published>
    <updated>2018-12-25T08:49:43.798Z</updated>
    
    <content type="html"><![CDATA[<p>前几日关于黎曼猜想（Riemann Hypothesis）被证明的消息在网络上炒得沸沸扬扬，菲尔兹奖、阿贝尔奖双料得主 Michael Francis Atiyah 爵士声称他证明了这个困扰了数学界 160 年的问题，且其目的是为了研究精细结构常数。然而，在他公布了他的 Simple Proof 后，却不被学界所看好，甚至遭到了一些尖锐的批评。毕竟，这篇只有五页纸的文章，刨去介绍等内容，并没有展示太多的细节；其证明过程，又依赖于一个存疑的 Todd function。如果如证明中所说，黎曼猜想真的指向了精细结构常数，这对于由第一性原理出发构建物理学体系将有极大的启发性，其结果无疑是令人激动的。但是经过计算，却发现文中所声称的极限存在问题，整个理论的正确性难以得到证实。<br>有鉴于此，博主研究该证明过程的计划搁置了（毕竟没有什么价值，大概可以用来提升读 Paper 的能力 #捂脸），还是写篇文章介绍下黎曼猜想本身吧。</p><h2 id="猜想的提出"><a href="#猜想的提出" class="headerlink" title="猜想的提出"></a>猜想的提出</h2><p>时间回到 1859 年，著名的德国数学家波恩哈德 · 黎曼（Bernhard Riemann）在他的论文《Über die Anzahl der Primzahlen unter einer gegebenen Größe》中提及了这个著名的猜想。黎曼本人在数学界颇有建树，但他却并没有试图对论文中的猜想给出证明。<br>这个猜想是关于黎曼 $\zeta$ 函数的，该函数的定义为：<br>$$\zeta(s)=\frac{1}{1^s}+\frac{1}{2^s}+\frac{1}{3^s}+\frac{1}{4^s}+\cdots$$<br>注意，$\zeta$ 函数必须经过解析延拓，才能在全复平面上有定义，稍后将给出解析延拓的过程。<br>而黎曼猜想就是：$\zeta(s)$ 的所有非平凡零点的实部均为 $\frac{1}{2}$。</p><h2 id="zeta-函数的解析延拓"><a href="#zeta-函数的解析延拓" class="headerlink" title="$\zeta$ 函数的解析延拓"></a>$\zeta$ 函数的解析延拓</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在中学数学中，我们所接触到的函数都是实变函数，即从实数集到实数集的映射，写为 $f:\mathbb{R}\rightarrow\mathbb{R}$。在接触了虚数单位 i 和复数后，就可以开始定义复变函数，即复数集到复数集的映射，写为 $f:\mathbb{C}\rightarrow\mathbb{C}$。实变函数的定义域被限制在了实轴上，而为了表示出一个与之对应的复变函数，就需要扩充其定义域到复平面上。这样，可以定义出复数域上的各种函数：指数、对数、三角函数等。由于复数的性质，还需要根据枝点规定割线、单值分支等，来确定出函数值。而原本定义域只在复平面上某一区域的复变函数，经过严格的数学推导（例如级数展开等），也可以扩充其定义域。这时，解析延拓的办法应运而生。对于 $\zeta(s)$ 函数而言，非常明显，当 $s$ 取在实轴上（即作为实变函数时），若 $s\le 1$，其函数值发散；而 $s&gt;1$ 时收敛。特别的，$s=1$ 时为调和级数，而 $s=2$ 时由高斯最早计算出了其函数值 $\frac{\pi^2}{6}$。<br>在复数域上，可以证明，$\zeta(s)$ 在 $Re(s)&gt;1$ 上解析。接下来，我们需要将其定义域扩展到全复平面；之前的级数定义将不在对 $Re(s)&lt;1$ 的情况使用，因为它不收敛，无法采用 Cauchy 和。</p><h3 id="梅林变换"><a href="#梅林变换" class="headerlink" title="梅林变换"></a>梅林变换</h3><p>梅林（Mellin）变换是一个积分变换，它把一个正实数域 $\mathbb{R}^+$ 上的函数变换为一个复数域 $\mathbb{C}$ 上的函数。设 $f:\mathbb{R}^+\rightarrow\mathbb{C}$ 是一个函数，定义：<br>$$\mathcal{M}f(z)=\int_0^{+\infty}f(s)s^z\frac{ds}{s}$$<br>称 $\mathcal{M}f:\mathbb{C}\rightarrow\mathbb{C}$ 为 $f$ 的梅林变换。<br>取 $f(s)$ 为 $f_\lambda (s)=e^{-\lambda s}$，则有：<br>\begin{align*}<br>\mathcal{M}f(z)&amp;=\int_0^{+\infty}e^{-\lambda s}s^z\frac{ds}{s}\\<br>&amp;=\lambda^{-z}\int_0^{+\infty}e^{-s}s^{z-1}ds\\<br>&amp;=\lambda^{-z}\Gamma(z)<br>\end{align*}<br>这里的 $\Gamma(z)$ 就是一般数理方程中会涉及到的 $\Gamma$ 函数，其性质不再赘述。<br>记住以上结论，取 $\lambda=\pi n^2$，继续构造函数：<br>$$f(s)=\sum_{n=1}^{\infty}f_{\pi n^2}(s)=\sum_{n=1}^{\infty}e^{-\pi n^2 s}$$<br>注意到梅林变换是线性的，这时，<br>\begin{align*}<br>\mathcal{M}f(z)&amp;=\sum_{n=1}^{\infty}\mathcal{M}f_{\pi n^2}(z)\\<br>&amp;=\sum_{n=1}^{\infty}(\pi n^2)^{-z}\Gamma(z)\\<br>&amp;=\pi^{-z}\sum_{n=1}^{\infty}n^{-2z}\Gamma(z)\\<br>&amp;=\pi^{-z}\zeta(2z)\Gamma(z)<br>\end{align*}<br>最后一个等号使用了 $\zeta$ 函数的原始定义。考虑到：<br>$$\mathcal{M}f(z)=\int_0^{+\infty}(\sum_{n=1}^{\infty}e^{-\pi n^2 s})s^{z-1}ds$$<br>于是，利用 $\mathcal{M}f(z)$ 的两个等价表达式，我们得到了一个重要结论：<br>$$\pi^{-z}\zeta(2z)\Gamma(z)=\int_0^{+\infty}(\sum_{n=1}^{\infty}e^{-\pi n^2 s})s^{z-1}ds$$<br>注意，这里的推导并非十分严谨，还需要证明其收敛性，才能交换积分与极限。这要求 $Re(z)&gt;\frac{1}{2}$。</p><a id="more"></a><h3 id="泊松求和"><a href="#泊松求和" class="headerlink" title="泊松求和"></a>泊松求和</h3><p>再来看一下 Fourier 变换<br>$$\mathcal{F}f(x)=\int_{-\infty}^{+\infty}f(t)e^{ixt}dt$$<br>对于足够『好』的函数 $f$，可以证明泊松（Poisson）求和公式<br>$$\sum_{n\in\mathbb{Z}}f(n)=\sum_{n\in\mathbb{Z}}\mathcal{F}f(n)$$<br>这部分我们就证明这个公式。<br>假设 $f$ 足够『好』（要多好有多好），定义<br>$$F(t)=\sum_{n\in\mathbb{Z}}f(n+t)$$<br>则 $F$ 是 $\mathbb{R}$ 上周期为 $1$ 的函数，于是可以构造 $F$ 的 Fourier 级数：令<br>$$c_k=\int_0^1F(t)e^{-2\pi ikt}dt$$<br>是第 $k$ 个 Fourier 系数，则<br>$$F(t)\sim\sum_{k\in\mathbb{Z}}c_ke^{2\pi ikt}$$<br>而这个系数<br>\begin{align*}<br>c_k&amp;=\int_0^1F(t)e^{-2\pi ikt}dt\\<br>&amp;=\int_0^1\sum_{n\in\mathbb{Z}}f(n+t)e^{-2\pi ik(n+t)}dt\\<br>&amp;=\int_{-\infty}^{+\infty}f(t)e^{-2\pi ikt}dt\\<br>&amp;=\mathcal{F}f(k)<br>\end{align*}<br>从而<br>$$\sum_{n\in\mathbb{Z}}f(n)=F(0)\sim\sum_{k\in\mathbb{Z}}c_k=\sum_{k\in\mathbb{Z}}\mathcal{F}f(k)$$<br>就得到了 Poisson 求和公式形式上的『证明』。<br>那么 $f$ 究竟要满足什么条件呢？<br>如果周期函数 $F\in C^2[0,1]$，就有 $F(t)=\sum_{k\in\mathbb{Z}}c_ke^{2\pi ikt}$。因此，我们要求 $f$ 二阶连续可导，并且<br>$$\sum_{n\in\mathbb{Z}}||f||_{[n.n+1],\infty}+||f’||_{[n.n+1],\infty}+||f’’||_{[n.n+1],\infty}&lt;+\infty$$<br>使用导数一致收敛的判别法则，就得到 $F\in C^2[0,1]$ 啦。<br>也就是说，如果 $f\in C^2(\mathbb{R})$，并且满足以上条件，就有 Poisson 求和公式<br>$$\sum_{n\in\mathbb{Z}}f(n)=\sum_{n\in\mathbb{Z}}\mathcal{F}f(n)$$</p><h3 id="解析延拓"><a href="#解析延拓" class="headerlink" title="解析延拓"></a>解析延拓</h3><p>设 $\lambda&gt;0$，令<br>\begin{eqnarray*}<br>\theta(\lambda)&amp;=&amp;\sum_{n\in\mathbb{Z}}e^{-\pi n^2\lambda}\\<br>\psi(\lambda)&amp;=&amp;\sum_{n=1}^\infty e^{-\pi n^2\lambda}<br>\end{eqnarray*}<br>很显然 $\theta(\lambda)=2\psi(\lambda)+1$。<br>考虑 $f(t)=e^{-\pi t^2\lambda}$，计算得 $\mathcal{F}f(x)=\frac{1}{\sqrt{\lambda}}e^{-\pi\frac{x^2}{\lambda}}$，而且满足相应条件，因此用 Poisson 求和公式，<br>$$\sum_{n\in\mathbb{Z}}e^{-\pi n^2\lambda}=\frac{1}{\sqrt{\lambda}}\sum_{n\in\mathbb{Z}}e^{-\pi\frac{n^2}{\lambda}}$$<br>即 $\theta(\lambda)=\frac{1}{\sqrt{\lambda}}\theta\left(\frac{1}{\lambda}\right)$。<br>换成 $\psi$ 就是 $\psi\left(\frac{1}{\lambda}\right)=\sqrt{\lambda}\psi(\lambda)+\frac{\sqrt{\lambda}-1}{2}$。<br>第二部分的最后，得到了<br>\begin{align*}<br>\pi^{-z}\zeta(2z)\Gamma(z)&amp;=\int_0^{+\infty}\left(\sum_{n=1}^\infty e^{-\pi n^2s}\right)s^{z-1}ds\\<br>&amp;=\int_0^{+\infty}\psi(s)s^{z-1}ds<br>\end{align*}<br>因此<br>\begin{align*}<br>\pi^{-z}\zeta(2z)\Gamma(z)&amp;=\int_0^{+\infty}\psi(s)s^{z-1}ds\\<br>&amp;=\int_1^{+\infty}\psi(s)s^{z-1}ds+\int_0^1\psi(s)s^{z-1}ds\\<br>&amp;=\int_1^{+\infty}\psi(s)s^{z-1}ds+\int_1^{+\infty}\psi\left(\frac{1}{s}\right)s^{1-z}\frac{ds}{s^2}\\<br>&amp;=\int_1^{+\infty}\psi(s)s^{z-1}ds+\int_1^{+\infty}\left(\psi(s)\sqrt{s}+\frac{\sqrt{s}-1}{2}\right)s^{-1-z}ds\\<br>&amp;=\int_1^{+\infty}\psi(s)(s^{z-1}+s^{-z-\frac{1}{2}})ds+\int_1^{+\infty}\frac{s^{-z-\frac{1}{2}}-s^{-z-1}}{2}ds\\<br>&amp;=\int_1^{+\infty}\psi(s)(s^{z-1}+s^{-z-\frac{1}{2}})ds+\frac{1}{2z(2z-1)}<br>\end{align*}<br>以上计算的前提是 $Re(z)&gt;\frac{1}{2}$。<br>令 $w=2z$，则当 $Re(w)&gt;1$ 时，<br>$$\sqrt{\pi}^{-w}\zeta(w)\Gamma\left(\frac{w}{2}\right)=\int_1^{+\infty}\psi(s)(\sqrt{s}^{w-2}+\sqrt{s}^{-w-1})ds-\frac{1}{w(1-w)}$$<br>现在观察：等号右边是一个亚纯函数（亚纯函数就是『能表示成两个解析函数的商』的函数，或者『没有本性奇点』的函数，两个亚纯函数经过四则运算仍然是亚纯函数），而等号左边的 $\sqrt{\pi}^{-w}$、$\Gamma\left(\frac{w}{2}\right)$ 也都是亚纯函数。这样，上式相当于给出了 $\zeta(w)$ 在 $w\in\mathbb{C}$ 上的定义！</p><h2 id="所有自然数的『和』"><a href="#所有自然数的『和』" class="headerlink" title="所有自然数的『和』"></a>所有自然数的『和』</h2><p>这还没完，试试在等号右边把 $w$ 换为 $1-w$，你会发现式子根本没变。这就说明：<br>$$\sqrt{\pi}^{-w}\zeta(w)\Gamma\left(\frac{w}{2}\right)=\sqrt{\pi}^{w-1}\zeta(1-w)\Gamma\left(\frac{1-w}{2}\right)$$<br>现在让 $w=-1$，就有<br>$$\sqrt{\pi}\zeta(-1)\Gamma\left(-\frac{1}{2}\right)=\sqrt{\pi}^{-2}\zeta(2)\Gamma(1)$$<br>我们知道<br>$$\zeta(2)=\sum_{n=1}^\infty\frac{1}{n^2}=\frac{\pi^2}{6}$$<br>并且，<br>\begin{eqnarray*}<br>\Gamma(1)&amp;=&amp;1\\<br>\Gamma\left(\frac{1}{2}\right)&amp;=&amp;\sqrt{\pi}\\<br>\Gamma\left(-\frac{1}{2}\right)&amp;=&amp;\frac{\Gamma\left(\frac{1}{2}\right)}{-\frac{1}{2}}=-2\sqrt{\pi}<br>\end{eqnarray*}<br>因此：<br>$$\zeta(-1)=\frac{\sqrt{\pi}^{-2}\zeta(2)\Gamma(1)}{\sqrt{\pi}\Gamma\left(-\frac{1}{2}\right)}=\frac{\frac{\pi^2}{6}}{\sqrt{\pi}^3(-2)\sqrt{\pi}}=-\frac{1}{12}$$<br>我们便得出了全体自然数的『和』为 $-\frac{1}{12}$ 这一结论。</p><h2 id="黎曼猜想与素数"><a href="#黎曼猜想与素数" class="headerlink" title="黎曼猜想与素数"></a>黎曼猜想与素数</h2><h3 id="欧拉乘积公式"><a href="#欧拉乘积公式" class="headerlink" title="欧拉乘积公式"></a>欧拉乘积公式</h3><p>从 $\zeta$ 函数的原始定义出发：<br>$$\zeta(s)=\frac{1}{1^s}+\frac{1}{2^s}+\frac{1}{3^s}+\cdots$$<br>在等式两边同时乘以第二项：<br>$$\frac{1}{2^s}\times\zeta(s)=\frac{1}{2^s}+\frac{1}{4^s}+\frac{1}{6^s}+\cdots$$<br>两式相减得：<br>$$(1-\frac{1}{2^s})\times\zeta(s)=\frac{1}{1^s}+\frac{1}{3^s}+\frac{1}{5^s}+\cdots$$<br>这时，等号右边的分母上已经没有 2 的倍数了。重复这一过程：<br>$$\frac{1}{3^s}\times(1-\frac{1}{2^s})\zeta(s)=\frac{1}{3^s}+\frac{1}{9^s}+\frac{1}{15^s}+\cdots$$<br>以上两式相减，又有：<br>$$(1-\frac{1}{3^s})(1-\frac{1}{2^s})\zeta(s)=\frac{1}{1^s}+\frac{1}{5^s}+\frac{1}{7^s}+\cdots$$<br>等号右边也没有 3 的倍数了。无限重复此过程，就有：<br>$$\cdots(1-\frac{1}{11^s})(1-\frac{1}{7^s})(1-\frac{1}{5^s})(1-\frac{1}{3^s})\zeta(s)=1$$<br>即：<br>$$\zeta(s)=\frac{1}{1-\frac{1}{2^s}}\times\frac{1}{1-\frac{1}{3^s}}\times\frac{1}{1-\frac{1}{5^s}}\times\frac{1}{1-\frac{1}{7^s}}\times\cdots$$<br>可以写成：<br>$$\zeta(s)=\sum_n\frac{1}{n^s}=\prod_p\frac{1}{1-p^{-s}}$$<br>这就是欧拉乘积公式，该表达式首先出现在 1737 年一篇题为《Variae observationes circa series infinitas》（无穷级数的各种观察）的论文中。<br>该恒等式展示了素数与 $\zeta$ 函数间的联系。</p><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>奥古斯特 · 费迪南德 · 莫比乌斯之后重写了欧拉乘积公式，创造了一个新的求和。首先引入莫比乌斯函数：<br>$$\mu(n)=<br>\begin{cases}<br>1 &amp; n 是偶数个不同的素数相乘 \\<br>-1 &amp; n 是奇数个不同的素数相乘 \\<br>0 &amp; n 被某个素数的平方整除<br>\end{cases}<br>$$<br>和式用 $\mu(n)$ 表示如下：<br>$$\frac{1}{\zeta(s)}=\sum_{n\in\mathbb{N}}\frac{\mu(n)}{n^s}$$</p><h3 id="素数计数函数"><a href="#素数计数函数" class="headerlink" title="素数计数函数"></a>素数计数函数</h3><p>定义为<br>$$\pi(x)=\sum_{p\le x}1$$<br>表示不超过 x 的素数个数。<br>在间断点处用左右平均代替更好，重新定义：<br>$$\pi(x)=\frac{1}{2}\left(\sum_{p\le x}1+\sum_{p&lt; x}1\right)$$<br>令<br>$$\Pi(x)=\sum_n\frac{1}{n}\pi(x^{\frac{1}{n}})$$<br>有莫比乌斯反转<br>$$\pi(x)=\sum_n\frac{\mu(n)}{n}\Pi(x^{\frac{1}{n}})$$</p><h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>素数定理由高斯和勒让德独立地阐述：<br>$$\mathop{\lim}_{x\rightarrow\infty}\frac{\pi(x)}{\frac{x}{\ln(x)}}=1$$<br>目前人类证明的素数定理的误差界是<br>$$\pi(x)=Li(x)+O\left(x\exp\left({-\frac{A(\ln x)^{0.6}}{(\ln\ln x)^{0.2}}}\right)\right)$$<br>从概率的角度来说，素数定理说明若你随机选择一个自然数 $x$，那么该数字为素数的概率约为 $\frac{1}{\ln(x)}$。这意味着前 $x$ 个整数中相邻素数之间的平均间隙约为 $\ln(x)$。</p><h3 id="对数积分函数"><a href="#对数积分函数" class="headerlink" title="对数积分函数"></a>对数积分函数</h3><p>定义<br>$$Li(x)=\int_2^x\frac{1}{\ln(t)}dt$$<br>称为对数积分函数。<br>那么<br>$$\Pi(x)=Li(x)-\sum_{\rho}Li(x^{\rho})-\ln 2+\int_x^\infty\frac{dt}{t(t^2-1)\ln t}$$<br>其中求和号的 $\rho$ 取 $\zeta(s)$ 的非平凡零点，求和之后通常表现为震荡。至于剩下的常数和积分，对较大的 $x$ 可以忽略。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>敬请期待</p><p>参考文章：<br><a href="https://en.wikipedia.org/wiki/Riemann_hypothesis" target="_blank" rel="noopener">黎曼猜想</a><br><a href="https://zhuanlan.zhihu.com/p/35397224" target="_blank" rel="noopener">为什么全体自然数的和是负十二分之一？</a><br><a href="https://zhuanlan.zhihu.com/p/45240901" target="_blank" rel="noopener">黎曼猜想跟素数分布有怎样的联系</a><br><a href="https://zhuanlan.zhihu.com/p/25055731" target="_blank" rel="noopener">黎曼猜想，及其解释（上）</a><br><a href="https://zhuanlan.zhihu.com/p/25222934" target="_blank" rel="noopener">黎曼猜想，及其解释（下）</a></p><p>拓展阅读：<br><a href="https://terrytao.wordpress.com/2010/04/10/the-euler-maclaurin-formula-bernoulli-numbers-the-zeta-function-and-real-variable-analytic-continuation" target="_blank" rel="noopener">The Euler-Maclaurin formula, Bernoulli numbers, the zeta function, and real-variable analytic continuation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几日关于黎曼猜想（Riemann Hypothesis）被证明的消息在网络上炒得沸沸扬扬，菲尔兹奖、阿贝尔奖双料得主 Michael Francis Atiyah 爵士声称他证明了这个困扰了数学界 160 年的问题，且其目的是为了研究精细结构常数。然而，在他公布了他的 Simple Proof 后，却不被学界所看好，甚至遭到了一些尖锐的批评。毕竟，这篇只有五页纸的文章，刨去介绍等内容，并没有展示太多的细节；其证明过程，又依赖于一个存疑的 Todd function。如果如证明中所说，黎曼猜想真的指向了精细结构常数，这对于由第一性原理出发构建物理学体系将有极大的启发性，其结果无疑是令人激动的。但是经过计算，却发现文中所声称的极限存在问题，整个理论的正确性难以得到证实。&lt;br&gt;有鉴于此，博主研究该证明过程的计划搁置了（毕竟没有什么价值，大概可以用来提升读 Paper 的能力 #捂脸），还是写篇文章介绍下黎曼猜想本身吧。&lt;/p&gt;
&lt;h2 id=&quot;猜想的提出&quot;&gt;&lt;a href=&quot;#猜想的提出&quot; class=&quot;headerlink&quot; title=&quot;猜想的提出&quot;&gt;&lt;/a&gt;猜想的提出&lt;/h2&gt;&lt;p&gt;时间回到 1859 年，著名的德国数学家波恩哈德 · 黎曼（Bernhard Riemann）在他的论文《Über die Anzahl der Primzahlen unter einer gegebenen Größe》中提及了这个著名的猜想。黎曼本人在数学界颇有建树，但他却并没有试图对论文中的猜想给出证明。&lt;br&gt;这个猜想是关于黎曼 $\zeta$ 函数的，该函数的定义为：&lt;br&gt;$$\zeta(s)=\frac{1}{1^s}+\frac{1}{2^s}+\frac{1}{3^s}+\frac{1}{4^s}+\cdots$$&lt;br&gt;注意，$\zeta$ 函数必须经过解析延拓，才能在全复平面上有定义，稍后将给出解析延拓的过程。&lt;br&gt;而黎曼猜想就是：$\zeta(s)$ 的所有非平凡零点的实部均为 $\frac{1}{2}$。&lt;/p&gt;
&lt;h2 id=&quot;zeta-函数的解析延拓&quot;&gt;&lt;a href=&quot;#zeta-函数的解析延拓&quot; class=&quot;headerlink&quot; title=&quot;$\zeta$ 函数的解析延拓&quot;&gt;&lt;/a&gt;$\zeta$ 函数的解析延拓&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在中学数学中，我们所接触到的函数都是实变函数，即从实数集到实数集的映射，写为 $f:\mathbb{R}\rightarrow\mathbb{R}$。在接触了虚数单位 i 和复数后，就可以开始定义复变函数，即复数集到复数集的映射，写为 $f:\mathbb{C}\rightarrow\mathbb{C}$。实变函数的定义域被限制在了实轴上，而为了表示出一个与之对应的复变函数，就需要扩充其定义域到复平面上。这样，可以定义出复数域上的各种函数：指数、对数、三角函数等。由于复数的性质，还需要根据枝点规定割线、单值分支等，来确定出函数值。而原本定义域只在复平面上某一区域的复变函数，经过严格的数学推导（例如级数展开等），也可以扩充其定义域。这时，解析延拓的办法应运而生。对于 $\zeta(s)$ 函数而言，非常明显，当 $s$ 取在实轴上（即作为实变函数时），若 $s\le 1$，其函数值发散；而 $s&amp;gt;1$ 时收敛。特别的，$s=1$ 时为调和级数，而 $s=2$ 时由高斯最早计算出了其函数值 $\frac{\pi^2}{6}$。&lt;br&gt;在复数域上，可以证明，$\zeta(s)$ 在 $Re(s)&amp;gt;1$ 上解析。接下来，我们需要将其定义域扩展到全复平面；之前的级数定义将不在对 $Re(s)&amp;lt;1$ 的情况使用，因为它不收敛，无法采用 Cauchy 和。&lt;/p&gt;
&lt;h3 id=&quot;梅林变换&quot;&gt;&lt;a href=&quot;#梅林变换&quot; class=&quot;headerlink&quot; title=&quot;梅林变换&quot;&gt;&lt;/a&gt;梅林变换&lt;/h3&gt;&lt;p&gt;梅林（Mellin）变换是一个积分变换，它把一个正实数域 $\mathbb{R}^+$ 上的函数变换为一个复数域 $\mathbb{C}$ 上的函数。设 $f:\mathbb{R}^+\rightarrow\mathbb{C}$ 是一个函数，定义：&lt;br&gt;$$\mathcal{M}f(z)=\int_0^{+\infty}f(s)s^z\frac{ds}{s}$$&lt;br&gt;称 $\mathcal{M}f:\mathbb{C}\rightarrow\mathbb{C}$ 为 $f$ 的梅林变换。&lt;br&gt;取 $f(s)$ 为 $f_\lambda (s)=e^{-\lambda s}$，则有：&lt;br&gt;\begin{align*}&lt;br&gt;\mathcal{M}f(z)&amp;amp;=\int_0^{+\infty}e^{-\lambda s}s^z\frac{ds}{s}\\&lt;br&gt;&amp;amp;=\lambda^{-z}\int_0^{+\infty}e^{-s}s^{z-1}ds\\&lt;br&gt;&amp;amp;=\lambda^{-z}\Gamma(z)&lt;br&gt;\end{align*}&lt;br&gt;这里的 $\Gamma(z)$ 就是一般数理方程中会涉及到的 $\Gamma$ 函数，其性质不再赘述。&lt;br&gt;记住以上结论，取 $\lambda=\pi n^2$，继续构造函数：&lt;br&gt;$$f(s)=\sum_{n=1}^{\infty}f_{\pi n^2}(s)=\sum_{n=1}^{\infty}e^{-\pi n^2 s}$$&lt;br&gt;注意到梅林变换是线性的，这时，&lt;br&gt;\begin{align*}&lt;br&gt;\mathcal{M}f(z)&amp;amp;=\sum_{n=1}^{\infty}\mathcal{M}f_{\pi n^2}(z)\\&lt;br&gt;&amp;amp;=\sum_{n=1}^{\infty}(\pi n^2)^{-z}\Gamma(z)\\&lt;br&gt;&amp;amp;=\pi^{-z}\sum_{n=1}^{\infty}n^{-2z}\Gamma(z)\\&lt;br&gt;&amp;amp;=\pi^{-z}\zeta(2z)\Gamma(z)&lt;br&gt;\end{align*}&lt;br&gt;最后一个等号使用了 $\zeta$ 函数的原始定义。考虑到：&lt;br&gt;$$\mathcal{M}f(z)=\int_0^{+\infty}(\sum_{n=1}^{\infty}e^{-\pi n^2 s})s^{z-1}ds$$&lt;br&gt;于是，利用 $\mathcal{M}f(z)$ 的两个等价表达式，我们得到了一个重要结论：&lt;br&gt;$$\pi^{-z}\zeta(2z)\Gamma(z)=\int_0^{+\infty}(\sum_{n=1}^{\infty}e^{-\pi n^2 s})s^{z-1}ds$$&lt;br&gt;注意，这里的推导并非十分严谨，还需要证明其收敛性，才能交换积分与极限。这要求 $Re(z)&amp;gt;\frac{1}{2}$。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://zhangshuqiao.org/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数学" scheme="https://zhangshuqiao.org/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>月下独酌</title>
    <link href="https://zhangshuqiao.org/2018-09/%E6%9C%88%E4%B8%8B%E7%8B%AC%E9%85%8C/"/>
    <id>https://zhangshuqiao.org/2018-09/月下独酌/</id>
    <published>2018-09-24T10:15:20.000Z</published>
    <updated>2018-11-03T07:48:33.841Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 月下独酌 </strong></p><ul><li>李白 *<br>花间一壶酒，独酌无相亲。<br>举杯邀明月，对影成三人。<br>月既不解饮，影徒随我身。<br>暂伴月将影，行乐须及春。<br>我歌月徘徊，我舞影零乱。<br>醒时同交欢，醉后各分散。<br>永结无情游，相期邈云汉。</li></ul><p><strong> 八月十五夜月 </strong></p><ul><li>杜甫 *<br>满月飞明镜，归心折大刀。<br>转蓬行地远，攀桂仰天高。<br>水路疑霜雪，林栖见羽毛。<br>此时瞻白兔，直欲数秋毫。</li></ul><p><strong> 十五夜望月 </strong></p><ul><li>王建 *<br>中庭地白树栖鸦，冷露无声湿桂花。<br>今夜月明人尽望，不知秋思落谁家！</li></ul><p><strong> 南斋玩月 </strong></p><ul><li>王昌龄 *<br>高卧南斋时，开帷月初吐。<br>清辉澹水木，演漾在窗户。<br>荏苒几盈虚，澄澄变今古。<br>美人清江畔，是夜越吟苦。<br>千里共如何，微风吹兰杜。</li></ul><p><strong> 中秋月 </strong></p><ul><li>苏轼 *<br>暮云收尽溢清寒，银汉无声转玉盘。<br>此生此夜不长好，明月明年何处看。</li></ul><p><strong> 中秋月 </strong></p><ul><li>齐已 *<br>空碧无云露湿衣，众星光外涌清规。<br>东林莫碍渐高势，四海正看当路时。<br>还许分明吟皓魄，肯教幽暗取丹枝。<br>可怜关夜婵娟影，正对五候残酒卮。</li></ul><a id="more"></a><p><strong> 关山月 </strong></p><ul><li>李白 *<br>明月出天山，苍茫云海间。<br>长风几万里，吹度玉门关。<br>汉下白登道，胡窥青海湾。<br>由来征战地，不见有人还。<br>戍客望边色，思归多苦颜。<br>高楼当此夜，叹息未应闲。</li></ul><p><strong> 静夜思 </strong></p><ul><li>李白 *<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</li></ul><p><strong> 月夜 </strong></p><ul><li>刘方平 *<br>更深月色半人家，北斗阑干南斗斜。<br>今夜偏知春气暖，虫声新透绿窗纱。</li></ul><p><strong> 嫦娥 </strong></p><ul><li>李商隐 *<br>云母屏风烛影深，长河渐落晓星沈。<br>嫦娥应悔偷灵药，碧海青天夜夜心。</li></ul><p><strong> 月夜忆舍弟 </strong></p><ul><li>杜甫 *<br>戍鼓断人行，秋边一雁声。<br>露从今夜白，月是故乡明。<br>有弟皆分散，无家问死生。<br>寄书长不达，况乃未休兵。</li></ul><p><strong> 望月怀远 </strong></p><ul><li>张九龄 *<br>海上生明月，天涯共此时。<br>情人怨遥夜，竟夕起相思！<br>灭烛怜光满，披衣觉露滋。<br>不堪盈手赠，还寝梦佳期。</li></ul><p><strong> 霜月 </strong></p><ul><li>李商隐 *<br>初闻征雁已无蝉，百尺楼高水接天。<br>青女素娥俱耐冷，月中霜里斗婵娟</li></ul><p><strong> 秋宵月下有怀 </strong></p><ul><li>孟浩然 *<br>秋空明月悬，光彩露沾湿。<br>惊鹊栖未定，飞萤卷帘入。<br>庭槐寒影疏，邻杵夜声急。<br>佳期旷何许！望望空伫立。</li></ul><p><strong> 中秋待月 </strong></p><ul><li>陆龟蒙 *<br>转缺霜输上转迟，好风偏似送佳期。<br>帘斜树隔情无限，烛暗香残坐不辞。<br>最爱笙调闻北里，渐看星潆失南箕。<br>何人为校清凉力，欲减初圆及午时。</li></ul><p><strong> 倪庄中秋 </strong></p><ul><li>元好问 *<br>强饭日逾瘦，狭衣秋已寒。<br>儿童漫相忆，行路岂知难。<br>露气入茅屋，溪声喧石滩。<br>山中夜来月，到晓不曾看。</li></ul><p><strong> 八月十五夜桃源玩月 </strong></p><ul><li>刘禹锡 *<br>尘中见月心亦闲，况是清秋仙府间。<br>凝光悠悠寒露坠，此时立在最高山。<br>碧虚无云风不起，山上长松山下水。<br>群动悠然一顾中，天高地平千万里。<br>少君引我升玉坛，礼空遥请真仙官。<br>云軿欲下星斗动，天乐一声肌骨寒。<br>金霞昕昕渐东上，轮欹影促犹频望。<br>绝景良时难再并，他年此日应惆怅。</li></ul><p><strong> 中秋月 </strong></p><ul><li>晏殊 *<br>十轮霜影转庭梧，此夕羁人独向隅。<br>未必素娥无怅恨，玉蟾清冷桂花孤。</li></ul><p><strong> 中秋月 </strong></p><ul><li>苏轼 *<br>暮云收尽溢清寒，银汉无声转玉盘。<br>此生此夜不长好，明月明年何处看。</li></ul><p><strong> 八月十五日夜湓亭望月 </strong></p><ul><li>白居易 *<br>昔年八月十五夜，曲江池畔杏园边。<br>今年八月十五夜，湓浦沙头水馆前。<br>西北望乡何处是，东南见月几回圆。<br>昨风一吹无人会，今夜清光似往年。</li></ul><p><strong> 天竺寺八月十五日夜桂子 </strong></p><ul><li>皮日休 *<br>玉颗珊珊下月轮，殿前拾得露华新。<br>至今不会天中事，应是嫦娥掷与人。</li></ul><p><strong> 中秋见月和子由 </strong></p><ul><li>苏轼 *<br>明月未出群山高，瑞光千丈生白毫。<br>一杯未尽银阙涌，乱云脱坏如崩涛。<br>谁为天公洗眸子，应费明河千斛水。<br>遂令冷看世间人，照我湛然心不起。<br>西南火星如弹丸，角尾奕奕苍龙蟠。<br>今宵注眼看不见，更许萤火争清寒。<br>何人舣舟昨古汴，千灯夜作鱼龙变。<br>曲折无心逐浪花，低昂赴节随歌板。<br>青荧灭没转山前，浪飐风回岂复坚。<br>明月易低人易散，归来呼酒更重看。<br>堂前月色愈清好，咽咽寒螀鸣露草。<br>卷帘推户寂无人，窗下咿哑唯楚老。<br>南都从事莫羞贫，对月题诗有几人。<br>明朝人事随日出，恍然一梦瑶台客。</li></ul><p><strong> 中秋登楼望月 </strong></p><ul><li>米芾 *<br>目穷淮海满如银，万道虹光育蚌珍。<br>天上若无修月户，桂枝撑损向西轮。</li></ul><p><strong> 明月何皎皎 </strong></p><ul><li>佚名 *<br>明月何皎皎，照我罗床帏。<br>夜愁不能寐，揽衣起徘徊。<br>客行虽云乐，不如早旋归。<br>出户独彷徨，愁思当告谁！<br>引领还入房，泪下沾裳衣。</li></ul><p><strong> 水调歌头 </strong></p><ul><li>苏轼 *<br>明月几时有，把酒问青天。<br>不知天上宫阙，今夕是何年。<br>我欲乘风归去，惟恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间。<br>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆。<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</li></ul><p><strong> 西江月 </strong></p><ul><li>苏轼 *<br>顷在黄州，春夜行蕲水中。过酒家饮酒，醉。乘月至一溪桥上，解鞍曲肱，醉卧少休。及觉已晓。乱山攒拥，流水铿然，疑非人世也。书此语桥柱上。<br>照野弥弥浅浪，横空隐隐层霄。障泥未解玉骢骄，我欲醉眠芳草。<br>可惜一溪风月，莫教踏碎琼瑶。解鞍欹枕绿杨桥，杜宇一声春晓。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 月下独酌 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;李白 *&lt;br&gt;花间一壶酒，独酌无相亲。&lt;br&gt;举杯邀明月，对影成三人。&lt;br&gt;月既不解饮，影徒随我身。&lt;br&gt;暂伴月将影，行乐须及春。&lt;br&gt;我歌月徘徊，我舞影零乱。&lt;br&gt;醒时同交欢，醉后各分散。&lt;br&gt;永结无情游，相期邈云汉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 八月十五夜月 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;杜甫 *&lt;br&gt;满月飞明镜，归心折大刀。&lt;br&gt;转蓬行地远，攀桂仰天高。&lt;br&gt;水路疑霜雪，林栖见羽毛。&lt;br&gt;此时瞻白兔，直欲数秋毫。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 十五夜望月 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;王建 *&lt;br&gt;中庭地白树栖鸦，冷露无声湿桂花。&lt;br&gt;今夜月明人尽望，不知秋思落谁家！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 南斋玩月 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;王昌龄 *&lt;br&gt;高卧南斋时，开帷月初吐。&lt;br&gt;清辉澹水木，演漾在窗户。&lt;br&gt;荏苒几盈虚，澄澄变今古。&lt;br&gt;美人清江畔，是夜越吟苦。&lt;br&gt;千里共如何，微风吹兰杜。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 中秋月 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;苏轼 *&lt;br&gt;暮云收尽溢清寒，银汉无声转玉盘。&lt;br&gt;此生此夜不长好，明月明年何处看。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 中秋月 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;齐已 *&lt;br&gt;空碧无云露湿衣，众星光外涌清规。&lt;br&gt;东林莫碍渐高势，四海正看当路时。&lt;br&gt;还许分明吟皓魄，肯教幽暗取丹枝。&lt;br&gt;可怜关夜婵娟影，正对五候残酒卮。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="其他" scheme="https://zhangshuqiao.org/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>十个 UI 设计的基本原理</title>
    <link href="https://zhangshuqiao.org/2018-09/%E5%8D%81%E4%B8%AAUI%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://zhangshuqiao.org/2018-09/十个UI设计的基本原理/</id>
    <published>2018-09-16T01:52:56.000Z</published>
    <updated>2018-12-25T08:49:42.632Z</updated>
    
    <content type="html"><![CDATA[<p>It’s no great mystery that truly great user interfaces are the ones that are engineered to stay out of the way.<br>真正优秀的用户界面都是那些设计得『不挡路』的——这并不是什么奥秘。<br>‘Staying out of the way’ means not distracting your users. Rather, good UIs let your users complete goals. The result? A reduction in training and support costs, and happier, satisfied and highly engaged users.<br>『不挡路』意味着不会分散用户的注意力。事实上，良好的用户界面可以让你的用户完成目标。结果呢？减少培训和支持的成本，以及让用户更快乐、更满意并被深深吸引。<br>Check out our other <a href="https://teamtreehouse.com/library/topic:design" target="_blank" rel="noopener">design courses</a> at Treehouse.<br>在 Treehouse 查看我们的其他<a href="https://teamtreehouse.com/library/topic:design" target="_blank" rel="noopener">设计课程</a>。<br>When getting started on a new interface, make sure to remember these fundamentals:<br>在开始设计新的用户界面时，请务必记住以下原则：</p><h2 id="Know-your-user"><a href="#Know-your-user" class="headerlink" title="Know your user"></a>Know your user</h2><p>了解你的用户</p><blockquote><p>“Obsess over customers: when given the choice between obsessing over competitors or customers, always obsess over customers. Start with customers and work backward.” – Jeff Bezos<br>『对顾客的关注：当在关注竞争对手或顾客之间做出选择时，总是应该关注顾客。从顾客开始，用逆向思维工作。』 —— Jeff Bezos</p></blockquote><p>Your user’s goals are your goals, so learn them. Restate them, repeat them. Then, learn about your user’s skills and experience, and what they need. Find out what interfaces they like and sit down and watch how they <em>use</em> them. Do not get carried away trying to keep up with the competition by mimicking trendy design styles or adding new features. By focusing on your user first, you will be able to create an interface that lets them achieve their goals.<br>你的用户的目标就是你的目标，因此请了解它们。重申它们，重复它们。然后，了解你的用户的技能和经验，以及他们需要什么。找出他们喜欢的界面，坐下来看看他们如何 <em> 使用 </em> 这些界面。不要试图通过模仿时尚的设计风格或添加新功能来跟上竞争对手，而忘乎所以。通过首先关注你的用户，你将能够创建一个让他们完成目标的界面。</p><h2 id="Pay-attention-to-patterns"><a href="#Pay-attention-to-patterns" class="headerlink" title="Pay attention to patterns"></a>Pay attention to patterns</h2><p>注意 UI 样式</p><p>Users spend the majority of their time on interfaces other than your own (Facebook, MySpace, Blogger, Bank of America, school/university, news websites, etc). There is no need to reinvent the wheel. Those interfaces may solve some of the same problems that users perceive within the one you are creating. By using familiar UI patterns, you will help your users feel at home.<br>用户会将大部分时间花在除你以外的其他界面上（Facebook，MySpace，Blogger，美国银行，学校 / 大学，新闻网站等等）。没有必要重新发明轮子。这些接口可以解决用户在你正在创建的问题中感知的一些相同问题。通过使用熟悉的 UI 模式，你将让你的用户有宾至如归的感觉。</p><h2 id="Stay-consistent"><a href="#Stay-consistent" class="headerlink" title="Stay consistent"></a>Stay consistent</h2><p>保持一致性</p><blockquote><p>“The more users’ expectations prove right, the more they will feel in control of the system and the more they will like it.” – Jakob Nielson<br>『越多用户的期望被证明是正确的，他们对系统的控制感越强，他们就会越喜欢它。』 —— Jakob Nielson</p></blockquote><p>Your users <em>need</em> consistency. They need to know that once they learn to do something, they will be able to do it again. Language, layout, and design are just a few interface elements that need consistency. A consistent interface enables your users to have a better understanding of how things will work, increasing their efficiency.<br>你的用户 <em> 需要 </em> 一致性。他们需要知道，一旦他们学会做某事，他们就能再次做到。语言、布局和设计只是需要一致性的一些界面元素。一致的界面使你的用户能够更好地了解事物的运作方式，从而提高效率。</p><a id="more"></a><h2 id="Use-visual-hierarchy"><a href="#Use-visual-hierarchy" class="headerlink" title="Use visual hierarchy"></a>Use visual hierarchy</h2><p>使用视觉层次结构</p><blockquote><p>“Designers can create normalcy out of chaos; they can clearly communicate ideas through the organizing and manipulating of words and pictures.” – Jeffery Veen, <a href="http://veen.com/artsci" target="_blank" rel="noopener">The Art and Science of Web Design</a><br>『设计师可以摆脱混乱的局面；他们可以通过组织和操纵文字和图片清晰地传达思想。』 —— Jeffery Veen，<a href="http://veen.com/artsci" target="_blank" rel="noopener">网页设计的艺术与科学</a></p></blockquote><p>Design your interface in a way that allows the user to focus on what is most important. The size, color, and placement of each element work together, creating a clear path to understanding your interface. A clear hierarchy will go great lengths in reducing the appearance of complexity (even when the actions themselves are complex).<br>以允许用户专注于最重要的方式设计界面。每个元素的大小、颜色和位置协同工作，为理解界面创建了清晰的途径。明确的层次结构将大大减少复杂性的出现（即使行动本身很复杂）。</p><h2 id="Provide-feedback"><a href="#Provide-feedback" class="headerlink" title="Provide feedback"></a>Provide feedback</h2><p>提供反馈信息</p><p>Your interface should at all times speak to your user, when his/her actions are both right and wrong or misunderstood. Always inform your users of actions, changes in state and errors, or exceptions that occur. Visual cues or simple messaging can show the user whether his or her actions have led to the expected result.<br>无论用户的行为正确、错误还是被误解时，你的界面应始终向你的用户提供反馈。始终通知用户操作、状态和错误的改变或发生的异常。视觉提示或简单消息可以向用户显示他或她的行为是否已导致预期结果。</p><h2 id="Be-forgiving"><a href="#Be-forgiving" class="headerlink" title="Be forgiving"></a>Be forgiving</h2><p>对用户宽容</p><p>No matter how clear your design is, people will make mistakes. Your UI should allow for and tolerate user error. Design ways for users to undo actions, and be forgiving with varied inputs (no one likes to start over because he/she put in the wrong birth date format). Also, if the user does cause an error, use your messaging as a teachable situation by showing what action was wrong, and ensure that she/he knows how to prevent the error from occurring again.<br>无论你的设计多么清晰，人们都会犯错误。你的 UI 应该允许并容忍用户错误。设计用户撤销操作的方式，并对不同的输入进行宽容（没有人希望因为他 / 她输错了出生日期的格式，就得全部重新输入）。此外，如果用户确实导致错误，请通过显示哪些操作出错来将你的消息传递作为可接受的情况，并确保他 / 她知道如何防止错误再次发生。<br>A great example can be seen in <a href="http://carsonified.com/blog/design/how-to-increase-sign-ups-with-easier-captchas" target="_blank" rel="noopener">How to increase signups with easier captchas</a>.<br>在 <a href="http://carsonified.com/blog/design/how-to-increase-sign-ups-with-easier-captchas" target="_blank" rel="noopener">如何使用更简单的验证码增加注册</a> 中可以看到一个很好的例子。</p><h2 id="Empower-your-user"><a href="#Empower-your-user" class="headerlink" title="Empower your user"></a>Empower your user</h2><p>为你的用户提供支持</p><p>Once a user has become experienced with your interface, reward him/her and take off the training wheels. The breakdown of complex tasks into simple steps will become cumbersome and distracting. Providing more abstract ways, like keyboard shortcuts, to accomplish tasks will allow your design to get out of the way.<br>一旦用户熟悉你的界面，奖励他 / 她并把『辅助轮』取下来（注：就像在学习骑自行车时那样）。将复杂任务分解为简单的步骤将变得麻烦和分散注意力。提供更抽象的方法，如键盘快捷键，来完成任务——这将使你的设计摆脱困境。</p><h2 id="Speak-their-language"><a href="#Speak-their-language" class="headerlink" title="Speak their language"></a>Speak their language</h2><p>说出他们的语言</p><blockquote><p>“If you think every pixel, every icon, every typeface matters, then you also need to believe every letter matters.” – <a href="https://basecamp.com/books/getting-real" target="_blank" rel="noopener">Getting Real</a><br>『如果你认为每个像素，每个图标，每个字体都很重要，那么你还需要相信每个字母都很重要。』 —— <a href="https://basecamp.com/books/getting-real" target="_blank" rel="noopener">Getting Real</a></p></blockquote><p>All interfaces require some level of copywriting. Keep things conversational, not sensational. Provide clear and concise labels for actions and keep your messaging simple. Your users will appreciate it, because they won’t hear you – they will hear themselves and/or their peers.<br>所有接口都需要一定程度的文案。让它们亲切随和，而不是耸人听闻。为操作提供清晰简洁的标签，并使你的消息保持简单。你的用户会很感激，因为他们不会听到你的声音——他们会听到自己和 / 或他们的同伴的声音。</p><h2 id="Keep-it-simple"><a href="#Keep-it-simple" class="headerlink" title="Keep it simple"></a>Keep it simple</h2><p>把事情简单化</p><blockquote><p>“A modern paradox is that it’s simpler to create complex interfaces because it’s so complex to simplify them.” – Pär Almqvist<br>『一个现代悖论是，创建复杂的界面更简单，因为简化这些界面非常复杂。』 —— Pär Almqvist</p></blockquote><p>The best interface designs are <a href="http://www.uie.com/articles/experiencedesign" target="_blank" rel="noopener">invisible</a>. They do not contain UI-bling or unnecessary elements. Instead, the necessary elements are succinct and make sense. Whenever you are thinking about adding a new feature or element to your interface, ask the question, “Does the user really need this?” or “Why does the user want this very clever animated gif?” Are you adding things because you like or want them? Never let your UI ego steal the show.<br>最好的界面设计是 <a href="http://www.uie.com/articles/experiencedesign" target="_blank" rel="noopener">无形</a> 的。它们不包含 UI-bling 或不必要的元素。相反，必要的元素是简洁而有意义的。无论何时考虑在界面中添加新功能或元素，都要问『用户真的需要这个吗？』或『为什么用户想要这个巧妙的 gif 动图？』。你是否只是因为喜欢或想要而添加新东西？永远不要让你的 UI 自身抢了风头。</p><h2 id="Keep-moving-forward"><a href="#Keep-moving-forward" class="headerlink" title="Keep moving forward"></a>Keep moving forward</h2><p>不忘初心，继续前进</p><p><strong>Grandpa Bud</strong>: If I gave up every time I failed, I would never have invented my fireproof pants!<br>[Pants burn up, revealing his underwear]<br><strong>Grandpa Bud</strong>: Still working the kinks out a bit.<br>from <a href="https://www.imdb.com/title/tt0396555" target="_blank" rel="noopener">Meet the Robinsons</a></p><blockquote><p><strong> 巴德爷爷 </strong>：如果我每次失败就放弃了，我永远都不会发明我的防火裤！<br>[裤子烧了，露出他的内衣 ]<br><strong> 巴德爷爷 </strong>：仍然在努力解决问题。<br>来自<a href="https://www.imdb.com/title/tt0396555" target="_blank" rel="noopener">拜见罗宾逊一家</a></p></blockquote><p><em>Meet the Robinsons</em> is one of my all time favorite movies. Throughout the movie Lewis, the protagonist, is challenged to “keep moving forward.” This is a key principle in UI design.</p><ul><li><p>拜见罗宾逊一家 <em> 是我最喜欢的电影之一。在整个电影中，主角刘易斯面临着『继续前进』的挑战。这是 UI 设计的关键原则。<br>It is often said when developing interfaces that you need to fail fast, and iterate often. When creating a UI, you </em>will<em> make mistakes. Just keep moving forward, and remember to keep your UI out of the way.<br>在开发接口时经常会说你需要快速失败，并经常迭代。在创建 UI 时，你 </em> 会 * 犯错误。继续前进，并记住保持你的 UI 不受影响。</p></li><li><p>本文由 <a href="https://twitter.com/kyle" target="_blank" rel="noopener">Kyle Sollenberger</a> 撰写。<em></em>This article was written by <a href="https://twitter.com/kyle" target="_blank" rel="noopener">Kyle Sollenberger</a>.*</p></li></ul><p>本文翻译自：<a href="https://blog.teamtreehouse.com/10-user-interface-design-fundamentals" target="_blank" rel="noopener">10 User Interface Design Fundamentals</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;It’s no great mystery that truly great user interfaces are the ones that are engineered to stay out of the way.&lt;br&gt;真正优秀的用户界面都是那些设计得『不挡路』的——这并不是什么奥秘。&lt;br&gt;‘Staying out of the way’ means not distracting your users. Rather, good UIs let your users complete goals. The result? A reduction in training and support costs, and happier, satisfied and highly engaged users.&lt;br&gt;『不挡路』意味着不会分散用户的注意力。事实上，良好的用户界面可以让你的用户完成目标。结果呢？减少培训和支持的成本，以及让用户更快乐、更满意并被深深吸引。&lt;br&gt;Check out our other &lt;a href=&quot;https://teamtreehouse.com/library/topic:design&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;design courses&lt;/a&gt; at Treehouse.&lt;br&gt;在 Treehouse 查看我们的其他&lt;a href=&quot;https://teamtreehouse.com/library/topic:design&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计课程&lt;/a&gt;。&lt;br&gt;When getting started on a new interface, make sure to remember these fundamentals:&lt;br&gt;在开始设计新的用户界面时，请务必记住以下原则：&lt;/p&gt;
&lt;h2 id=&quot;Know-your-user&quot;&gt;&lt;a href=&quot;#Know-your-user&quot; class=&quot;headerlink&quot; title=&quot;Know your user&quot;&gt;&lt;/a&gt;Know your user&lt;/h2&gt;&lt;p&gt;了解你的用户&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Obsess over customers: when given the choice between obsessing over competitors or customers, always obsess over customers. Start with customers and work backward.” – Jeff Bezos&lt;br&gt;『对顾客的关注：当在关注竞争对手或顾客之间做出选择时，总是应该关注顾客。从顾客开始，用逆向思维工作。』 —— Jeff Bezos&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Your user’s goals are your goals, so learn them. Restate them, repeat them. Then, learn about your user’s skills and experience, and what they need. Find out what interfaces they like and sit down and watch how they &lt;em&gt;use&lt;/em&gt; them. Do not get carried away trying to keep up with the competition by mimicking trendy design styles or adding new features. By focusing on your user first, you will be able to create an interface that lets them achieve their goals.&lt;br&gt;你的用户的目标就是你的目标，因此请了解它们。重申它们，重复它们。然后，了解你的用户的技能和经验，以及他们需要什么。找出他们喜欢的界面，坐下来看看他们如何 &lt;em&gt; 使用 &lt;/em&gt; 这些界面。不要试图通过模仿时尚的设计风格或添加新功能来跟上竞争对手，而忘乎所以。通过首先关注你的用户，你将能够创建一个让他们完成目标的界面。&lt;/p&gt;
&lt;h2 id=&quot;Pay-attention-to-patterns&quot;&gt;&lt;a href=&quot;#Pay-attention-to-patterns&quot; class=&quot;headerlink&quot; title=&quot;Pay attention to patterns&quot;&gt;&lt;/a&gt;Pay attention to patterns&lt;/h2&gt;&lt;p&gt;注意 UI 样式&lt;/p&gt;
&lt;p&gt;Users spend the majority of their time on interfaces other than your own (Facebook, MySpace, Blogger, Bank of America, school/university, news websites, etc). There is no need to reinvent the wheel. Those interfaces may solve some of the same problems that users perceive within the one you are creating. By using familiar UI patterns, you will help your users feel at home.&lt;br&gt;用户会将大部分时间花在除你以外的其他界面上（Facebook，MySpace，Blogger，美国银行，学校 / 大学，新闻网站等等）。没有必要重新发明轮子。这些接口可以解决用户在你正在创建的问题中感知的一些相同问题。通过使用熟悉的 UI 模式，你将让你的用户有宾至如归的感觉。&lt;/p&gt;
&lt;h2 id=&quot;Stay-consistent&quot;&gt;&lt;a href=&quot;#Stay-consistent&quot; class=&quot;headerlink&quot; title=&quot;Stay consistent&quot;&gt;&lt;/a&gt;Stay consistent&lt;/h2&gt;&lt;p&gt;保持一致性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“The more users’ expectations prove right, the more they will feel in control of the system and the more they will like it.” – Jakob Nielson&lt;br&gt;『越多用户的期望被证明是正确的，他们对系统的控制感越强，他们就会越喜欢它。』 —— Jakob Nielson&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Your users &lt;em&gt;need&lt;/em&gt; consistency. They need to know that once they learn to do something, they will be able to do it again. Language, layout, and design are just a few interface elements that need consistency. A consistent interface enables your users to have a better understanding of how things will work, increasing their efficiency.&lt;br&gt;你的用户 &lt;em&gt; 需要 &lt;/em&gt; 一致性。他们需要知道，一旦他们学会做某事，他们就能再次做到。语言、布局和设计只是需要一致性的一些界面元素。一致的界面使你的用户能够更好地了解事物的运作方式，从而提高效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="https://zhangshuqiao.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>手机淘宝的 flexible 方案</title>
    <link href="https://zhangshuqiao.org/2018-09/%E6%89%8B%E6%9C%BA%E6%B7%98%E5%AE%9D%E7%9A%84flexible%E6%96%B9%E6%A1%88/"/>
    <id>https://zhangshuqiao.org/2018-09/手机淘宝的flexible方案/</id>
    <published>2018-09-15T11:20:25.000Z</published>
    <updated>2018-11-18T08:49:51.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>手机淘宝从 2014 年中开始，全面推行 flexible 设计。什么叫 flexible 呢？其实 flexible 就是 responsive 的低端形态和基础。对我们来说，最直观的感受就是，在超宽屏幕上，网页显示不会两边留白。以前 pc 时代大家经常讲的流体布局，其实就是一种 flexible design。只不过，流体的表述角度是实现，flexible 的表述角度是结果，为了跟高大上的 responsive 保持一致，我们这里使用了 flexible 这个说法。<br>讨论方案之前，需要先了解三个关键概念：</p><ul><li>单位英寸像素数（Pixel Per Inch，PPI）：现实世界的一英寸内像素数，决定了屏幕的显示质量</li><li>设备像素比率（Device Pixel Ratio，DPR）：物理像素与逻辑像素（px）的对应关系</li><li>分辨率（Resolution）：屏幕区域的宽高所占像素数</li></ul><p>当我们决定不同屏幕的字体和尺寸的单位时，屏幕的这几个参数非常重要。</p><h2 id="Resolution-适配"><a href="#Resolution-适配" class="headerlink" title="Resolution 适配"></a>Resolution 适配</h2><p>一张 banner 图片，当你面对不同的屏幕时你希望它的行为是怎样的？<br>在这个场景中，我们主要需要面对的是分辨率适配问题，考虑到多数网页都是纵向滚动的，在不同的屏幕尺寸下，banner 的行为应该是总是铺满屏幕宽度以及总是保持宽高比。<br>最自然的思路是使用百分比宽度，但是假如使用百分比宽度，即 width:100%，我们又有两种思路来实现固定宽高比：一是利用 img 标签的特性，只设宽度等图片加载完，这种方法会导致大量的重排，并且非固定高度会导致懒加载等功能难以实现，所以果断放弃；二是使用 before 伪元素的 margin 撑开高度，这种方法是比较干净的纯 css 实现，但是不具备任何复用性而且要求特定 html 结构，所以也只好放弃了。<br>于是，剩下最合适的办法是使用其它相对单位，本来最合适的单位是 vw，它的含义是视口宽度，但是这个单位存在严重的兼容问题，所以也只好放弃。<br>最后我们只好配合 js 来做，硬算也是一条路，但是同样不具备任何可复用性，最终我们选择了 rem，我们用 js 给 html 设置一个跟屏幕宽度成正比的 font-size，然后把元素宽高都用 rem 作为单位。<br>这是我们目前的线上方案了，它是一个近乎 Hack 的用法，已知的问题包括：</p><ul><li>某些 Android 机型会丢掉 rem 小数部分</li><li>占用了 rem 单位</li><li>不是纯 css 方案</li></ul><h2 id="PPI-适配"><a href="#PPI-适配" class="headerlink" title="PPI 适配"></a>PPI 适配</h2><p>一段文字，当你面对不同的屏幕时你希望它的行为是怎样的？<br>显然，我们在 iPhone3G 和 iPhone4 的 Retina 屏下面，希望看到的文字尺寸是相同的，也就是说，我们不希望文字在 Retina 屏尺寸变小，此外，我们在大屏手机上，希望看到更多文字，以及，现在绝大多数的字体文件，是自带一些点阵尺寸的，通常是 16px 和 24px，所以我们不希望出现 13px、15px 这样的奇葩尺寸。<br>这样的特征决定了，场景 1 中的 rem 方案，不适合用到段落文字上。所以段落文字应该使用 px 作为单位，考虑到 Retina，我们利用 media query 来指定不同的字体，考虑到 dpr 判定的兼容性，我们用宽度替换来代替：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> (min-width: <span class="number">401px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.a</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种场景，一些标题性文字，希望随着屏幕宽而增大的，我们可以仍然使用 rem 作为单位。超过 35px（个人直观感受）的文字，已经不用太考虑点阵信息了，靠字体的矢量信息也能渲染的很好。</p><h2 id="DPR-匹配"><a href="#DPR-匹配" class="headerlink" title="DPR 匹配"></a>DPR 匹配</h2><p>一个区块，设计稿上有 1 像素边框，当你面对不同的屏幕时你希望它的行为是怎样的？<br>这个场景，需求很简单，设计师希望在任何屏幕上这条线都是 1 物理像素。<br>好吧，当然这个问题的答案不是写 1px 那么简单。在 retina 屏下面，如果你写了这样的 meta：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>你将永远无法写出 1px 宽度的东西，除此之外，inline 的 SVG 等元素，也会按照逻辑像素来渲染，整个页面的清晰度会打折。<br>所以，手机淘宝用 JS 来动态写 meta 标签，代码类似这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> metaEl = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line"><span class="keyword">var</span> scale = isRetina ? <span class="number">0.5</span> : <span class="number">1</span>;</span><br><span class="line">metaEl.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>);</span><br><span class="line">metaEl.setAttribute(<span class="string">'content'</span>, <span class="string">'initial-scale='</span> + scale + <span class="string">', maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">', user-scalable=no'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.documentElement.firstElementChild) &#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.firstElementChild.appendChild(metaEl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wrap = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    wrap.appendChild(metaEl);</span><br><span class="line">    <span class="built_in">document</span>.write(wrap.innerHTML);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总的来说，手机淘宝的 flexible 方案是综合运用 rem 和 px 两种单位 + js 设置 scale 和 html 字体。<br>这些 JS 的内容，可以在我们开源的库 <a href="https://github.com/amfe/ml" target="_blank" rel="noopener">ml</a> 中找到，也可以参考<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">lib-flexible</a>。</p><p>参考文章：<br><a href="http://www.html-js.com/article/2402" target="_blank" rel="noopener">手机淘宝的 flexible 设计与实现</a><br><a href="http://www.html-js.com/article/2400" target="_blank" rel="noopener">关于 webapp 中的文字单位的一些捣腾</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;手机淘宝从 2014 年中开始，全面推行 flexible 设计。什么叫 flexible 呢？其实 flexible 就是 respons
      
    
    </summary>
    
      <category term="Web开发" scheme="https://zhangshuqiao.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CSS" scheme="https://zhangshuqiao.org/tags/CSS/"/>
    
      <category term="HTML" scheme="https://zhangshuqiao.org/tags/HTML/"/>
    
  </entry>
  
</feed>
