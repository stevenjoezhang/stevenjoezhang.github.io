[{"title":"转换Minecraft存档格式","url":"/2019-09/转换Minecraft存档格式/","content":"\nMinecraft在不同的平台上发行了多个版本，如经典的Java版、曾经的Minecraft PE版和微软接手后重制的Bedrock版。在过去的数年中，Mojang和Microsoft对Minecraft存档的结构进行了多次改动，这就导致不同版本的Minecraft存档可能完全不兼容。因此，如何在多个平台上同步游戏进度成为了一个令人头痛的问题。若是在各大论坛搜索相关内容，往往会找到一个名为MCEdit的程序。可惜这个由Python编写的程序已经长期没有更新了，它对新格式的存档无能为力。难道真的就没有办法了吗？莫非需要自己造出这个转换Minecraft存档格式的轮子？要知道，这需要极大的学习成本，例如`leveldb`的数据结构。\n幸运的是，博主偶然发现了这个工具：[MCC Toolchest](http://mcctoolchest.com/)。它可以在Java版和Bedrock版之间转换存档。考虑到同一平台上的Minecraft是可以兼容旧存档的（以Java版为例，1.14可以转换、读取1.13的存档），为了最大限度的减少兼容性问题，可以先将Minecraft升级到最新版，然后打开游戏，自动更新存档。随后，就可以通过MCC Toolchest来进行转换了。\n\n## 选择存档\n运行程序后，依次选择『File』『Open』，然后在文件浏览器中选择要打开的存档文件夹。\n![](/images/2019-09/1.png)\n\n如果存档是完好的，其目录结构会在左侧被展示出来。\n![](/images/2019-09/2.png)\n\n## 进行转换\n随后，依次选择『Tools』『Convert』，根据需要转换到Java版或Bedrock版。\n![](/images/2019-09/3.png)\n\n在新弹出的窗口中可以选择存档的具体参数。最上面需要选择存档文件夹，创建一个空目录即可。\n![](/images/2019-09/4.png)\n\n最后，点击『Convert』按钮，耐心等待转换完成就行啦！\n","tags":["我的世界"],"categories":["电子游戏"]},{"title":"Gettysburg Address","url":"/2019-08/Gettysburg Address/","content":"\n> Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.\n\n> Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.\n\n> But, in a larger sense, we can not dedicate—we can not consecrate—we can not hallow—this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us—that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion—that we here highly resolve that these dead shall not have died in vain—that this nation, under God, shall have a new birth of freedom—and that government of the people, by the people, for the people, shall not perish from the earth.\n","categories":["其他"]},{"title":"失去同步","url":"/2019-08/失去同步/","content":"\n![](/images/2019-08/005.jpg)\n\n图片来源：[1. Justice and Fresh Vegetables - Europe Comics](http://www.europecomics.com/album/1-justice-fresh-vegetables/)\n\n这样巧妙的设计，不禁让人联想起《哆啦A梦》中的类似剧情：大雄为了追回失窃的藏品，乘坐时光机回到案发现场，结果发现小偷正是自己……\n\n这本漫画书中还有很多像这样脑洞大开的漫画，可以通过多个渠道购买、下载。\n","categories":["幽默"]},{"title":"在Ubuntu上安装TeamViewer","url":"/2019-08/在Ubuntu上安装TeamViewer/","content":"\n首先，安装Xfce桌面环境\n```bash\napt install xfce4 xfce4-goodies\n```\n\n然后安装LightDM，这是一个显示管理器，可以渲染登陆页面\n```bash\napt install lightdm\n```\n\n还需要安装一个配套的greeter\n```bash\napt install lightdm-gtk-greeter\n```\n可选项还有很多，例如：\n- Unity Greeter (unity-greeter)\n- GTK+ Greeter (lightdm-gtk-greeter)\n- KDE Greeter (lightdm-kde-greeter)\n- WebKit Greeter (lightdm-webkit-greeter)\n- RazorQt Greeter (razorqt-lightdm-greeter)\n\n下一步，是配置LightDM\n```bash\necho \"[Seat:*]\nallow-guest=false\nuser-session=xfce\" >> /etc/lightdm/lightdm.conf\n```\n\n完成后，就可以下载TeamViewer了\n```bash\nwget https://download.teamviewer.com/download/linux/teamviewer-host_amd64.deb\n```\n\nTeamViewer通过deb安装包进行安装\n```bash\napt install ./teamviewer-host_amd64.deb\n```\n\n安装完成就可以进行初始化设置，需要先到[TeamViewer官网](https://login.teamviewer.com/LogOn)注册账号\n```bash\nteamviewer setup\n```\n\n设置成功后，重启系统即可\n```bash\nreboot\n```\n\n此外，还需要检查防火墙设置。TeamViewer会使用5938端口，确保它没有被拦截。一切正常的话，就可以登录了。\n\n![](/images/2019-08/teamviewer.png)\n\n如果需要卸载，执行以下命令即可\n```bash\napt purge teamviewer-host\n```\n","tags":["Linux"],"categories":["技术"]},{"title":"青海湖之行","url":"/2019-07/青海湖之行/","content":"\n![](/images/2019-07/IMG_5005.jpg)\n\n> 嘉峪关的花朵\n\n![](/images/2019-07/IMG_5077.jpg)\n\n> 月牙泉的骆驼\n\n![](/images/2019-07/IMG_5260.jpg)\n\n> 日出前的敦煌\n\n![](/images/2019-07/IMG_5261.jpg)\n\n> 日出前的沙漠\n\n![](/images/2019-07/IMG_5439.jpg)\n\n> 翡翠湖\n\n![](/images/2019-07/IMG_5483.jpg)\n\n> 茶卡盐湖\n\n![](/images/2019-07/IMG_5513.jpg)\n\n> 青海湖\n","tags":["摄影"],"categories":["其他"]},{"title":"在Win 95中晃动鼠标竟能加速系统","url":"/2019-07/在Win 95中晃动鼠标竟能加速系统/","content":"\n**Through the looking glass:** Adding new hardware or overclocking what you've already got are among the leading ways to squeeze more performance out of your PC but in the earlier days of computing, all one had to do to give their PC a jolt was wiggle the mouse cursor around during an install.\n添加新硬件或超频现有硬件是使PC获得更佳性能的主要方法。但在个人计算机的早期阶段，用户竟然还可以通过一个巧妙的办法来提升性能——不停地晃动鼠标的光标。\n\n![](/images/2019-07/2019-07-15-image-24.jpg)\n\nI'm a self-professed fidgeter, especially at the computer. It's not uncommon to catch me moving the mouse all around with zero intent, even if I'm busy reading a story or watching a video.\n我自认为是一个手抖的人，尤其是在电脑前。即使我在忙着用电脑读故事或看视频，你也会发现我在毫无目的地移动鼠标。\n\nI chalk it up to the earlier days of computing when keeping the mouse active seemed to have a tangible benefit on system performance. Turns out, it wasn't just in our imagination.\n我把它归结为在上古时期，保持鼠标活动似乎对系统性能有明显的好处。事实证明，这并不只是我们的想象。\n\nAccording to a running thread over on [Stack Exchange](https://retrocomputing.stackexchange.com/questions/11533/why-did-moving-the-mouse-cursor-cause-windows-95-to-run-more-quickly), moving the mouse cursor in Windows 95 did indeed speed up performance due to a flaw in the way the OS generates events and the fact that many applications are event driven.\n根据[Stack Exchange](https://retrocomputing.stackexchange.com/questions/11533/why-did-moving-the-mouse-cursor-cause-windows-95-to-run-more-quickly)上一个正在热烈讨论的主题，在Windows 95中移动鼠标光标确实提升了性能，因为操作系统的事件生成方法存在缺陷，并且许多应用程序都是基于事件来驱动的。\n\nAs one user explains:\n正如一位用户解释到：\n\n> Windows 95 applications often use asynchronous I/O, that is they ask for some file operation like a copy to be performed and then tell the OS that they can be put to sleep until that operation finishes. By sleeping they allow other applications to run, rather than wasting CPU time endlessly asking if the file operation has completed yet.\n> Windows 95应用程序通常采用了异步I/O，也就是说，在它们要求执行某些文件操作的时候（例如要执行的副本），会向操作系统表示其能够在操作完成之前转入休眠状态。通过这项休眠机制，其它应用程序将可以穿插空档来运行，而不是无休止地询问文件操作是否已经完成，从而浪费CPU时间。\n\n> For reasons that are not entirely clear, but probably due to performance problems on low end machines, Windows 95 tends to bundle up the messages about I/O completion and doesn't immediately wake up the application to service them. However, it does wake the application for user input, presumably to keep it feeling responsive, and when the application is awake it will handle any pending I/O messages too.\n> 目前原因尚不完全清楚，但一个猜测是，这可能是为了解决低端计算机上的性能问题——Windows 95倾向于捆绑关于I/O完成的消息，并且不会立即唤醒应用程序来为它们提供服务。不过，在用户输入时，操作系统会唤醒应用程序，这可能是为了让应用程序保持响应；而当应用程序处于唤醒状态时，它就能够处理任何挂起的I/O消息。\n\n> Thus wiggling the mouse causes the application to process I/O messages faster, and install quicker. The effect was quite pronounced; large applications that could take an hour to install could be reduced to 15 minutes with suitable mouse input.\n> 换言之，晃动鼠标可以使应用程序更快地处理I/O消息，并加快安装速度。效果相当明显：配合合适的鼠标输入，原先可能需要一个小时安装的大型应用程序，耗时可以减少到15分钟。\n\nAs a youth, I'd keep my mouse cursor active as much as possible -- and especially during installs -- simply because I didn't want the screensaver to trigger and bog down system resources. Sure, I could have just set the timeout to longer on the screensaver, but that's beside the point. As it turns out, my actions were actually helpful, and not for the reason I thought.\n在我年轻的时候，我尽可能地让鼠标光标处于活动状态——尤其是在安装期间——只是因为我不想让屏幕保护程序触发并阻塞系统资源。当然，我可以把屏保上的超时设置得更长一些，但这不是重点。事实证明，我的行为实际上是有帮助的——即使这并不是我的初衷。\n\n---\n\n本文翻译自：[Wiggling the mouse in Windows 95 made the operating system faster](https://www.techspot.com/news/80956-wiggling-mouse-windows-95-made-operating-system-faster.html)\n","tags":["Windows"],"categories":["技术"]},{"title":"怎样修好任何电脑","url":"/2019-07/怎样修好任何电脑/","content":"\n![](/images/2019-07/header.png)\n![](/images/2019-07/windows.png)\n![](/images/2019-07/apple.png)\n![](/images/2019-07/linux.png)\n\n图片来源：[How to fix any computer - The Oatmeal](https://theoatmeal.com/blog/fix_computer)\n","categories":["幽默"]},{"title":"Range对象的使用","url":"/2019-06/Range对象的使用/","content":"\n## 什么是Range对象\n\nRange是指html文档中的区域，如用户用鼠标拖动选中的区域，如下图：\n\n![](/images/2019-06/range.png)\n\n通过Range对象，可以获取用户选中的区域，或者指定选中区域，得到Range的起点和终点、修改或者复制里边的文本，甚至是html。在富文本编辑器开发中，经常会使用到这些功能。\n\n## 获取当前的选区\n\n由于兼容性的问题，需要区分IE浏览器。\n```javascript\nvar selection, range;\nif (window.getSelection) {\n    //现代浏览器\n    selection = window.getSelection();\n} else if (document.selection) {\n    //IE\n    selection = document.selection.createRange();\n}\n\n//Range对象\nrange = selection.getRangeAt(0);\n```\n\n## Range对象的属性\n\n属性 | 描述\n- | -\n`collapsed` | 如果范围的开始点和结束点在文档的同一位置，则为`true`，即范围是空的，或折叠的。\n`commonAncestorContainer` | 范围的开始点和结束点的（即它们的祖先节点）、嵌套最深的Document节点。\n`endContainer` | 包含范围的结束点的Document节点。\n`endOffset` | endContainer中的结束点位置。\n`startContainer` | 包含范围的开始点的Document节点。\n`startOffset` | startContainer中的开始点位置。\n\n## Range对象的操作\n\n```javascript\n//选中区域的文字\nvar text = range.toString();\n\n//选中区域的Element元素\nvar elem = range.commonAncestorContainer;\nif (elem.nodeType != 1) {\n    elem = elem.parentNode;\n}\n\n//选中区域的html\nvar span = document.createElement('SPAN');\nspan.appendChild(range.cloneContents());\n\n//选区是否为空\nvar isSelectionEmpty = false;\nif (range.startContainer === range.endContainer) {\n    if (range.startOffset === range.endOffset) {\n        isSelectionEmpty = true;\n    }\n}\n```\n\n---\n\n参考文章：[JS Range 对象的使用](https://segmentfault.com/a/1190000009875696)\n","tags":["HTML","JavaScript"],"categories":["Web开发"]},{"title":"在PC上使用Pro Controller","url":"/2019-06/在PC上使用Pro Controller/","content":"\nPro Controller是任天堂为Switch适配的游戏手柄，于2016年10月20日与Switch一同亮相，并于2017年1月25日正式发布。除了在Switch上使用外，Pro Controller还可以与PC配对或连接，进行Steam上的游戏——Steam在2018年5月的客户端更新中增加了对Pro Controller的支持。\n\n本文将介绍一个名为[x360ce](https://github.com/x360ce/x360ce)的工具，通过它可以将Pro Controller的操作映射为一个Xbox手柄，这比在Steam中设置手柄更加方便和友好。\n\nPro Controller有两种与PC连接的方式：USB有线连接和蓝牙连接。通过USB连接的Pro Controller只能被steam识别，而无论是x360ce还是pygame都无法正确读取数据。因此，要使用x360ce，你的PC必须具有蓝牙功能。\n\n下面将介绍操作步骤。\n\n## 充电\n\n通过5V电源适配器连接USB Type-C接口为Pro Controller充电，使其保持足够的电量。正如前面所说的，最好不要直接通过PC的USB接口连接Pro Controller，以避免出现混乱。\n\n## 蓝牙连接\n\n长按USB Type-C接口旁的按键，使Pro Controller开机并进入蓝牙配对模式。在PC上通过蓝牙搜索并连接Pro Controller。蓝牙配对完成后，就可以使用x360ce了。\n\n## 安装x360ce\n\n[在这里](https://github.com/x360ce/x360ce/releases)下载最新版本的x360ce，然后解压并运行。\n\n![](/images/2019-06/x360ce.png)\n\n点击『Add...』按钮，并勾选通过蓝牙连接的Pro Controller。\n\n![](/images/2019-06/x360ce2.png)\n\n完成后，点击『OK』回到之前的页面。\n\n## 其它配置\n\n将所有设置项按照前面图中的方式调整好即可。在『General』页面中，可以自行调整按键映射。在『Left Stick』和『Right Stick』中，可以调整灵敏度。完成设置后，需要点击『Save All』进行保存。\n\n如果一切正常，系统会识别出x360ce虚拟的Xbox手柄，这样就可以愉快的进行游戏了！\n","categories":["技术"]},{"title":"PS用文字拼出照片","url":"/2019-06/PS用文字拼出照片/","content":"\n以下操作中的快捷键在Windows下有效，macOS可能需要用<kbd>Command</kbd>代替<kbd>Ctrl</kbd>。\n原始素材尽量选择人物，最好不要全身。\n\n博主以下面这张梅西庆祝的照片为例。\n\n![](/images/2019-06/lionel-messi.jpg)\n\n## 调整对比度\n\n打开素材，<kbd>Ctrl</kbd>+<kbd>j</kbd>复制图层；选定新图层，<kbd>Ctrl</kbd>+<kbd>m</kbd>打开曲线，调大对比度。\n\n![](/images/2019-06/1.png)\n\n<!-- more -->\n## 新建图层\n\n新建图层，填充白色。\n\n![](/images/2019-06/2.png)\n\n## 创建文本框\n\n使用横排文字工具，拖出段落文本框，大小是整幅图的大小。\n\n![](/images/2019-06/3.png)\n\n## 输入文字\n\n输入预先准备好的文字。如果文字内容不重要的话，可以随便打字，或者通过复制粘贴来输入内容。为了视觉效果，一定要填满文本框。\n提醒一下，文字打得时候字体最好不要太大，字间距和行间距也不要太大，否则不好看。\n\n![](/images/2019-06/4.png)\n\n## 选择高光\n\n隐藏上两个图层，<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>2</kbd>将高光提出作为选区；或者到通道面板按住<kbd>Ctrl</kbd>单击RGB通道缩览图，都可以提高光。\n\n![](/images/2019-06/5.png)\n\n## 栅格化\n\n显示上两个图层，然后点击文字图层，右键菜单选择『栅格化文字』，然后删除选区内的文字。\n\n![](/images/2019-06/6.png)\n![](/images/2019-06/7.png)\n\n效果如下图。\n\n![](/images/2019-06/8.png)\n\n## 叠加\n\n复制背景图层，将其移动到最上面，图层模式改为『颜色』。\n\n![](/images/2019-06/9.png)\n![](/images/2019-06/10.png)\n\n效果如图，如果觉得颜色不够的话，再<kbd>Ctrl</kbd>+<kbd>j</kbd>复制图层，模式为『颜色加深』。\n\n![](/images/2019-06/11.png)\n\n可以将颜色加深的图层多复制几层，如果觉得颜色够了就不用那么多层了，或者调整色相饱和度神马的~\n\n## 完成\n\n最终成品如图。\n\n![](/images/2019-06/export.jpg)\n","tags":["Photoshop"],"categories":["技术"]},{"title":"历史上的今天","url":"/2019-06/历史上的今天/","content":"\n如果要在网页上显示一些随机的语句，获得一些人生的经验，你会选择什么？\n也许，[一言](https://hitokoto.cn)是一个很好的选择，它可以提供一些动漫中的台词，或是网络上的各种小段子。\n在前面的文章[有趣的Linux命令行工具](/2018-05/有趣的Linux命令行工具)中提到的`fortune`命令或许也可以满足需求，`pure-ftpd`就可以设置在连接成功时显示随机的来自`fortune`的语句。\n那除此之外呢？历史上的今天是一个不错的方案。当你访问一些门户网站的首页，有时会看到这样的栏目。它也是一些百科全书网站，比如维基百科的传统。事实上，在Mac上就自带了一个小型的『历史上的今天』数据库，执行：\n```bash\ncat /usr/share/calendar/calendar.history\n```\n就可以看到。\n这篇文章将介绍如何搭建一个提供『历史上的今天』信息的API。\n\n## 建立数据库\n首先，建立MySQL数据库，用于存储爬取的信息。\n```sql\nCREATE DATABASE dbname;\n#建立数据库，dbname保持一致即可\nUSE dbname;\nCREATE TABLE event (\n  id int(10) UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n  type int(1) DEFAULT NULL,\n  year varchar(6) DEFAULT NULL,\n  date varchar(6) DEFAULT NULL,\n  info varchar(300) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nQUIT;\n```\n\n## 获取数据\n数据来源是维基百科，使用Python爬取数据，并存入数据库中。代码中的`username`、`password`和`dbname`分别是你的登录用户名、密码和数据库名。数据表名默认是event，也可以自行修改。\n```python\n#!/usr/bin/env python3\n\nusername = \"username\"\npassword = \"password\"\ndbname = \"dbname\"\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nimport datetime\nimport pymysql\n\nconn = pymysql.connect(host = \"127.0.0.1\", user = username, password = password, db = dbname, charset = \"utf8\")\nprint(conn)\ncur = conn.cursor()\ncur.execute(\"SET NAMES utf8mb4\")\n\ndef savedb(data):\n    print(data)\n    try:\n        cur.execute(\"insert into event values(null,%s,%s,%s,%s)\", data)\n    except pymysql.err.InternalError:\n        print(\"\\033[31mERROR: Incorrect string value.\\033[0m\", data)\n        with open(\"failed.txt\", \"a\") as myfile:\n            myfile.write(str(data) + \"\\n\")\n    except pymysql.err.DataError:\n        print(\"\\033[31mERROR: Data too long.\\033[0m\", data)\n        with open(\"failed.txt\", \"a\") as myfile:\n            myfile.write(str(data) + \"\\n\")\n\ndef getDateList():\n    list = []\n    date = datetime.date(2016, 1, 1)\n    for i in range(366):\n        date_str = str(date.month) + \"月\" + str(date.day) + \"日\"\n        list.append(date_str)\n        date += datetime.timedelta(days = 1)\n    return list\n\ndef getInfo(html, type, date):\n    typeList = [\"大事记\", \"出生\", \"逝世\"]\n    flag = re.compile(\"(<h2><span id=.*<span class=\\\"mw-headline\\\" id=.*?\" + typeList[type] + \"[\\s\\S]*?</ul>\\s*?)<h2>\").search(html)\n    if flag:\n        bsObj = BeautifulSoup(flag.group(1), \"html.parser\").findAll(\"li\")\n        for li in bsObj:\n            match = re.compile(\"((^前|^)\\d{1,4}年)：([\\s\\S]*$)\").match(li.get_text())\n            if match:\n                year = match.group(1)\n                info = re.sub(\"\\[\\d{1,}\\]\", \"\", match.group(3).strip())\n                data = (type, year, date, info)\n                savedb(data)\n\nlist = getDateList()\nfor date in list:\n    print(date)\n    url = \"https://zh.wikipedia.org/zh-cn/%s\" % date\n    r = requests.get(url)\n    getInfo(r.text, 0, date) # 大事记\n    getInfo(r.text, 1, date) # 出生\n    getInfo(r.text, 2, date) # 逝世\n\ncur.connection.commit()\ncur.close()\nconn.close()\n```\n这里的两个`except`分别处理的是特殊字符（非UTF-8范围）和内容长度超出的问题。\n\n## 查询数据\n比较简单的方式是按照json格式进行输出，这里给出一种使用Python的方案。\n<!-- more -->\n\n```python\n#!/usr/bin/env python3\n\nusername = \"username\"\npassword = \"password\"\ndbname = \"dbname\"\n\nimport datetime\nimport pymysql\nfrom flask import Flask\nfrom flask import request\n\napp = Flask(__name__)\n\nconn = pymysql.connect(host = \"127.0.0.1\", user = username, password = password, db = dbname, charset = \"utf8\")\nprint(conn)\ncur = conn.cursor()\n\n@app.route(\"/\", methods = [\"GET\", \"POST\"])\ndef query():\n    date = datetime.date.today()\n    today = str(date.month) + \"月\" + str(date.day) + \"日\"\n    _date = request.args.get(\"date\") or today\n    _type = int(request.args.get(\"type\") or 0)\n    _count = int(request.args.get(\"count\") or 1)\n    cur.execute(\"select * from `event` where `date` = %s and `type` = %s order by RAND() limit %s\", (_date, _type, _count))\n    rows = cur.fetchall()\n    result = []\n    for row in rows:\n        result.append({\"year\": row[2], \"info\": row[4]})\n    return str(result)\n\napp.run(debug = True, port = 8080, host = \"0.0.0.0\")\n```\n同样将`username`、`password`和`dbname`根据情况替换，就可以访问了。\n当然，用PHP也是可以实现的，毕竟只需要进行MySQL查询，没有静态文件，很方便。可以使用如下代码：\n```php\n<?php\n    $mysqli = new mysqli(\"localhost\", \"username\", \"password\", \"dbname\");\n\n    /* 检查连接 */\n    if (mysqli_connect_errno()) {\n        printf(\"Connect failed: %s\\n\", mysqli_connect_error());\n        exit();\n    }\n\n    $date = $_GET['date'] ? $mysqli->real_escape_string($_GET['date']) : date(\"m月d日\");\n    $type = $_GET['type'] ? (int)$mysqli->real_escape_string($_GET['type']) : 0;\n    $count = $_GET['count'] ? (int)$mysqli->real_escape_string($_GET['count']) : 1;\n    $result = array();\n\n    /* 创建一个预编译 SQL 语句 */\n    if ($stmt = $mysqli->prepare(\"select * from `event` where `date` = ? and `type` = ? order by RAND() limit ?\")) {\n        /* 对于参数占位符进行参数值绑定 */\n        $stmt->bind_param(\"dii\", $date, $type, $count);\n        /* 执行查询 */\n        $stmt->execute();\n        /* 将查询结果绑定到变量 */\n        $stmt->bind_result($id, $type, $year, $date, $info);\n        /* 获取查询结果值 */\n        while ($stmt->fetch()) {\n            $arr = array('year' => $year, 'info' => $info);\n            $result[] = $arr;\n        };\n        echo json_encode($result, JSON_UNESCAPED_UNICODE);\n        /* 关闭语句句柄 */\n        $stmt->close();\n    }\n    /* 关闭连接 */\n    $mysqli->close();\n?>\n```\n\n---\n\n项目地址：[TodayInHistory-Crawler](https://github.com/stevenjoezhang/TodayInHistory-Crawler)，可以打包下载所有文件。\n\n博主搭建的API：[历史上的今天](https://api.pkupi.com/today/?type=0)\n","tags":["Python","MySQL","PHP"],"categories":["程序设计"]},{"title":"在macOS上读写NTFS磁盘","url":"/2019-05/在macOS上读写NTFS磁盘/","content":"\n本文将介绍一种在macOS上读写NTFS磁盘的方法，通过它可以方便的在不同系统中传输文件。默认情况下，macOS是无法向NTFS磁盘写入的——这个功能由于种种原因被禁用了。我们使用一种Hack的方法将其启用即可。\nmacOS在挂载NTFS磁盘时加载的脚本为`/sbin/mount_ntfs`，参数为：\n```bash\nmount_ntfs -o nodev -o noowners -o nosuid /dev/disk2s1 /Volumes/DATA\n```\n这时，只要加上额外的参数，就可以启用对NTFS磁盘的写入。具体方法是：\n```bash\nsudo -s #输入密码，获取root权限\ncd /sbin\nmv mount_ntfs mount_ntfs_orig\nvim mount_ntfs\n```\n将`mount_ntfs`重命名为`mount_ntfs_orig`，然后再新建一个`mount_ntfs`，输入以下内容：\n```bash\n#!/bin/sh\n/sbin/mount_ntfs_orig -o rw,nobrowse \"$@\"\n```\n这样就可以欺骗系统，运行带有额外参数的指令。这里的`nobrowse`是为了避免挂载上来的还是只读模式，但是它同时会导致磁盘不可见，也就是挂在后不会在桌面和Finder中显示，需要手动到`/Volumes`下打开。如果这样不爽的话，你可以尝试\n```bash\n#!/bin/sh\n/sbin/mount_ntfs_orig -o rw \"$@\"\n```\n将磁盘推出再挂载，如果一切正常的话，就可以愉快的使用了。\n\n---\n\n参考文章：[OS X 原生可读写挂载NTFS分区](https://www.jianshu.com/p/d4073acbb218)\n","tags":["Mac"],"categories":["技术"]},{"title":"Windows安装tensorflow-gpu","url":"/2019-05/Windows安装tensorflow-gpu/","content":"\n## 准备工作\n\n下面列出了博主测试成功的环境，使用其它的版本可能出现不可预料的情况。\n\n### 硬件\n\n- 图形卡\n  根据Tensorflow官网上对于[GPU 支持](https://www.tensorflow.org/install/gpu)的描述，需要CUDA® 计算能力为 3.5 或更高的 NVIDIA® GPU 卡。博主使用了一块NVIDIA GeForce RTX 2070进行测试。\n\n- 其它\n  其它硬件达到主流配置即可。\n\n### 软件\n\n- Windows系统\n  由于macOS Mojave的N卡驱动迟迟没有更新（据说是苹果已经抛弃了N卡，未来很有可能不会再更新驱动）；并且Tensorflow官方已经不再推出适配macOS的`tensorflow-gpu`了，需要自己编译；因而使用Windows或者Linux系统会是更好的选择。博主使用的是Windows 10。\n\n- 显卡驱动程序\n  Windows10会自动下载安装显卡驱动，但可能不是最新版本。建议通过GeForce Experience管理驱动程序。\n\n- CUDA\n  `tensorflow-gpu`依赖于CUDA，需要到NVIDIA官网上的[CUDA Zone](https://developer.nvidia.com/cuda-zone)下载。下载时选择10.0版本即可，因为最新的版本可能不被tensorflow所支持。历史版本可以在这里查看：[CUDA Toolkit Archive](https://developer.nvidia.com/cuda-toolkit-archive)。\n\n- cuDNN\n  cuDNN的全称为NVIDIA CUDA® Deep Neural Network library，是NVIDIA专门针对深度神经网络（Deep Neural Networks）中的基础操作而设计基于GPU的加速库。这也是一个重要依赖，需要准备好。其主页是[NVIDIA cuDNN](https://developer.nvidia.com/cudnn)，下载需要注册账号，不过也可以选择微信快捷登陆。同样需要注意的是，要正确选择与CUDA对应的cuDNN版本。本文发布时，与CUDA 10.0兼容的最新版本cuDNN为v7.6.0。\n\n- Python\n  博主使用的是Python 3.7.0。安装好之后确保能够通过PowerShell执行`python`和`pip`即可。\n\n- `tensorflow-gpu`\n  安装`tensorflow-gpu`的方法也有很多，例如Anaconda或者pip。如果不想折腾环境，直接从这里找一个wheel就行了：[tensorflow-gpu · PyPI](https://pypi.org/project/tensorflow-gpu/#files)。需要根据自己的系统和Python版本选择，例如`tensorflow_gpu-1.13.1-cp37-cp37m-win_amd64.whl`。\n\n## 安装\n\n### 安装CUDA\n安装过程并不复杂。运行从NVIDIA官网上下载的CUDA安装程序，将其安装在默认目录下即可。如果一切正常，相关组件会出现在`C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0`目录下。\n\n### 安装cuDNN\n解压cuDNN的安装包，会得到一个文件夹，将其打开后，可以看到名为`bin`，`include`和`lib`的子目录。而在前面所说的`C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0`目录下也有这样几个子目录。因此，直接将cuDNN的相关文件复制合并进对应的目录即可。\n\n### 安装`tensorflow-gpu`\n\n以PowerShell为例，将CUDA相关组件添加至环境变量：\n```bash\n$Env:path=$Env:Path+\";C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0\\bin;C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0\\extras\\CUPTI\\libx64;\"\n```\n完成后，cd进入下载的whl文件所在目录，使用pip安装即可\n```bash\npip install tensorflow_gpu-1.13.1-cp37-cp37m-win_amd64.whl\n```\n`pip`会自动下载所需的依赖。\n\n## 运行\n如果一切顺利，打开Python，执行\n```python\nimport tensorflow as tf\nhello = tf.constant(\"Hello, TensorFlow!\")\nsess = tf.Session()\nprint(sess.run(hello))\n```\n不报错的话，就安装成功了。\n","tags":["Python","Windows"],"categories":["技术"]},{"title":"MySQL重置AUTO_INCREMENT","url":"/2019-05/MySQL重置AUTO_INCREMENT/","content":"\n在WordPress中，文章、用户的ID都是通过`AUTO_INCREMENT`分配的，如果要改变其值，可以在`wp_usermeta`和`wp_users`数据表中执行：\n```sql\nALTER TABLE `wp_usermeta`\n  MODIFY `umeta_id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=177;\nCOMMIT;\n```\n以及\n```sql\nALTER TABLE `wp_users`\n  MODIFY `ID` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;\nCOMMIT;\n```\n将`AUTO_INCREMENT`根据你自己的情况，修改为当前的行数即可。\n\n对于存储评论信息的`wp_comments`也是类似的。\n","tags":["MySQL"],"categories":["技术"]},{"title":"Minecraft配置Seus光影","url":"/2019-04/Minecraft配置Seus光影/","content":"\n## 准备工作\n\n下面列出了博主测试成功的环境，使用其它的版本可能出现不可预料的情况。\n\n### 硬件\n\n- 图形卡\n  由于Seus光影对计算机的图形性能有较高的要求，博主使用了一块NVIDIA GeForce RTX 2070显卡进行测试。根据作者的描述，20系和10系显卡对Seus光影的渲染没有本质区别——RTX加持暂时还没有体现出作用。因此，你也可以放心地选择其它型号的N卡，即使是上古核弹，运行起来也不会有影响。不过，根据一些Minecraft论坛的反馈，A卡和I卡可能无法支持此光影效果。\n\n- 其它\n  其它硬件达到主流配置即可，Minecraft对性能没有什么苛求。如果上卡吧标配的话，流畅玩耍一定没有什么问题。\n\n### 软件\n\n- Windows系统\n  由于macOS Mojave的N卡驱动迟迟没有更新（据说是苹果已经抛弃了N卡，未来很有可能不会再更新驱动），因而需要在其它系统上运行。博主使用的是Windows 10。Linux原理上也是可以的，不过博主并没有进行尝试。\n\n- Java环境\n  Minecraft Java版自然需要Java的环境。由于Minecraft对Java9及以上版本的支持不佳，博主推荐安装Java SE 8。可以到[Oracle官网](https://www.oracle.com/index.html)下载。测试使用的是JDK1.8.0_211。\n\n- HMCL启动器\n  你可以从GitHub上[获取HMCL启动器](https://github.com/huanghongxun/HMCL/releases)，下载`exe`版本即可。博主使用的是目前的最新版本3.2.129，后面的安装步骤也以该版本为例。\n\n- 光影\n  在[Seus官方网站](https://sonicether.com/seus/#Downloads)可以下载免费的光影包。推荐使用`SEUS Renewed v1.0.0`和`SEUS V11`。除此之外，可以向作者本人[付费购买](https://www.patreon.com/sonicether)制作中的`SEUS PTGI`（目前的版本收费10美元，未来发布的正式版将免费）。截至发稿前，最新版本为`SEUS PTGI E6`。博主这里提供了一个免费镜像：\n  [SEUS_PTGI_E6.zip](/files/SEUS_PTGI_E6.zip)\n\n- 材质\n  一个好的材质包同样是不可或缺的。博主推荐使用[Realistico](https://matteorizzo.com/realistico/)，不过，这个材质包的官方`512x`版本是付费的，可以自行到国内或国外的玩家论坛上寻找资源。\n\n## 安装\n\n### 安装Minecraft\n安装过程并不复杂。运行`HMCL-3.2.129.exe`，在『游戏列表』中选择『安装新游戏版本』。\n![](/images/2019-04/seus1.png)\n\n然后选择1.12.2版本，其它版本可能无法正确适配光影。\n\n![](/images/2019-04/seus2.png)\n\n随后安装OptiFine，点击这里的箭头：\n\n![](/images/2019-04/seus3.png)\n\n选择最新版本，例如HD_U_E3。如果在游戏过程中发现存在渲染问题（例如黑屏等），可以换其它版本试试。\n\n![](/images/2019-04/seus4.png)\n\n最后点击『安装』，HMCL启动器会自动下载并配置相关组件。\n\n<!-- more -->\n### 安装光影和材质\n初始化完成后，在`HMCL-3.2.129.exe`的同级目录下，会创建一个名为`.minecraft`的文件夹。打开这个目录，将光影放入`shaderpacks`子目录，将材质包放入`resourcepacks`子目录（都是直接将`zip`格式的文件放进去即可，无需解压）。然后启动游戏，就可以检查光影和材质是否正确运作了。\n\n## 启动\n\n如果一切正常（启动游戏后可以进入主界面），下一步就是进行设置了。如果启动器弹出了报错信息，请检查Java版本、游戏版本和插件版本是否正确，必要时可以通过提交Issue与开发者交流。\n\n### 设置光影\n依次点击『选项…』『视频设置…』『光影…』，所有`shaderpacks`目录下的光影都会显示在这里。点击一个启用即可。\n\n![](/images/2019-04/seus5.png)\n\n### 设置材质\n依次点击『选项…』『资源包…』，所有`resourcepacks`目录下的材质都会显示在这里。点击一个启用即可。\n\n![](/images/2019-04/seus6.png)\n\n## 效果\n\n最后再上几张游戏截图。\n\n![](/images/2019-04/screenshot1.png)\n\n![](/images/2019-04/screenshot2.png)\n\n![](/images/2019-04/screenshot3.png)\n\n![](/images/2019-04/screenshot4.png)\n\n---\n\n本文更新于2019年5月1日：\n除了前面提到的Realistico材质包，还有一个名为[Stratum](https://continuum.graphics/stratum-rp)的材质也很不错。博主在Reddit上找到了一个讨论帖：[[Request] Tier 3 of the stratum resource pack](https://www.reddit.com/r/modpiracy/comments/9vmmj9/request_tier_3_of_the_stratum_resource_pack/)，不过下载链接被删除了。后来博主发现可以通过把`www.reddit.com`替换为`www.removeddit.com`查看所有被和谐的内容，于是就找到了这个Mediafire上的存储库：[Stratum](https://www.mediafire.com/folder/6lxv0w9517j6l/Stratum)。\n\n本文更新于2019年9月8日：\n不幸的是，在这篇文章完成后不久，文中提到的Stratum材质包存储库就因为版权问题被处理了。新的下载方式是通过Google云端硬盘：[StratunT1-3](https://drive.google.com/drive/folders/1cd78-iJI6NrWcufmdxV7-XoYG_sdvUOF)。\n\n除此之外，博主又找到了另一个高质量的材质包：[UMSOEA](https://www.patreon.com/umsoea)。这是专门为SEUS光影设计的，同样也需要付费订阅才能下载，可以作为替代方案。一番搜索后，博主发现了一个名为[yiff.party](https://yiff.party)的网站，这里收录了大量Patreon上的付费下载内容。至此，问题全部解决，可以愉快地进行游戏了！\n","tags":["我的世界"],"categories":["电子游戏"]},{"title":"为JavaScript控制台添加样式","url":"/2019-04/为JavaScript控制台添加样式/","content":"\n在常见的JavaScript代码中，一般会通过`console`向控制台输出简单的文字信息。为了把信息输出得更优雅更便于阅读，除了`cosole.log()`方法外，还可以调用`cosole.warn()`来输出警告信息，在输出信息前面会有一个带感叹号的黄色三角警告符号。\n另外经常用到的是输出错误信息，可以通过调用`console.error()`来实现，信息前面会出现一个带叉的红色圆形图标。\n在某些浏览器下，还可以按以下格式，为输出到控制台的文字进行CSS控制，添加样式：\n```javascript\nconsole.log(\"%c需要输出的信息\", \"css代码\");\n```\n这样可以显示缤纷的颜色，甚至图片，简直爽翻了。\n下面是Chrome中`console.log()`的官方文档摘要，也适用于大部分主流浏览器：\n\nFormat Specifier | Description\n- | -\n%s | Formats the value as a string.\n%d or %i | Formats the value as an integer.\n%f | Formats the value as a floating point value.\n%o | Formats the value as an expandable DOM element (as in the Elements panel).\n%O | Formats the value as an expandable JavaScript object.\n%c | Formats the output string according to CSS styles you provide.\n\n下面是一些例子：\n\n![](/images/2019-04/2018-07-17.png)\n\n## 3D Text\n\n```javascript\nconsole.log(\"%c3D Text\", \"text-shadow: 0 1px 0 #ccc, 0 2px 0 #c9c9c9, 0 3px 0 #bbb, 0 4px 0 #b9b9b9, 0 5px 0 #aaa, 0 6px 1px rgba(0, 0, 0, .1), 0 0 5px rgba(0, 0, 0, .1), 0 1px 3px rgba(0, 0, 0, .3), 0 3px 5px rgba(0, 0, 0, .2), 0 5px 10px rgba(0, 0, 0, .25), 0 10px 10px rgba(0, 0, 0, .2), 0 20px 20px rgba(0, 0, 0, .15);\\\nfont-size: 5em;\");\n```\n\n## Colorful CSS\n\n```javascript\nconsole.log(\"%cColorful CSS\", \"background: rgba(252, 234, 187, 1);\\\nbackground: -moz-linear-gradient(left, rgba(252, 234, 187, 1) 0%, rgba(175, 250, 77, 1) 12%, rgba(0, 247, 49, 1) 28%, rgba(0, 210, 247, 1) 39%, rgba(0, 189, 247, 1) 51%, rgba(133, 108, 217, 1) 64%, rgba(177, 0, 247, 1) 78%, rgba(247, 0, 189, 1) 87%, rgba(245, 22, 52, 1) 100%);\\\nbackground: -webkit-gradient(left top, right top, color-stop(0%, rgba(252, 234, 187, 1)), color-stop(12%, rgba(175, 250, 77, 1)), color-stop(28%, rgba(0, 247, 49, 1)), color-stop(39%, rgba(0, 210, 247, 1)), color-stop(51%, rgba(0, 189, 247, 1)), color-stop(64%, rgba(133, 108, 217, 1)), color-stop(78%, rgba(177, 0, 247, 1)), color-stop(87%, rgba(247, 0, 189, 1)), color-stop(100%, rgba(245, 22, 52, 1)));\\\nbackground: -webkit-linear-gradient(left, rgba(252, 234, 187, 1) 0%, rgba(175, 250, 77, 1) 12%, rgba(0, 247, 49, 1) 28%, rgba(0, 210, 247, 1) 39%, rgba(0, 189, 247, 1) 51%, rgba(133, 108, 217, 1) 64%, rgba(177, 0, 247, 1) 78%, rgba(247, 0, 189, 1) 87%, rgba(245, 22, 52, 1) 100%);\\\nbackground: -o-linear-gradient(left, rgba(252, 234, 187, 1) 0%, rgba(175, 250, 77, 1) 12%, rgba(0, 247, 49, 1) 28%, rgba(0, 210, 247, 1) 39%, rgba(0, 189, 247, 1) 51%, rgba(133, 108, 217, 1) 64%, rgba(177, 0, 247, 1) 78%, rgba(247, 0, 189, 1) 87%, rgba(245, 22, 52, 1) 100%);\\\nbackground: -ms-linear-gradient(left, rgba(252, 234, 187, 1) 0%, rgba(175, 250, 77, 1) 12%, rgba(0, 247, 49, 1) 28%, rgba(0, 210, 247, 1) 39%, rgba(0, 189, 247, 1) 51%, rgba(133, 108, 217, 1) 64%, rgba(177, 0, 247, 1) 78%, rgba(247, 0, 189, 1) 87%, rgba(245, 22, 52, 1) 100%);\\\nbackground: linear-gradient(to right, rgba(252, 234, 187, 1) 0%, rgba(175, 250, 77, 1) 12%, rgba(0, 247, 49, 1) 28%, rgba(0, 210, 247, 1) 39%, rgba(0, 189, 247, 1) 51%, rgba(133, 108, 217, 1) 64%, rgba(177, 0, 247, 1) 78%, rgba(247, 0, 189, 1) 87%, rgba(245, 22, 52, 1) 100%);\\\nfilter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1);\\\nfont-size: 5em;\");\n```\n\n## Rainbow Text\n\n```javascript\nconsole.log(\"%cRainbow Text\", \"background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2), color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22));\\\ncolor: transparent;\\\n-webkit-background-clip: text;\\\nfont-size: 5em;\");\n```\n\n## Image\n\n![](/images/2019-04/072156353445447.gif)\n\n```javascript\nconsole.log(\"%c\", \"padding: 50px 300px; line-height: 120px; background: url('/images/icon.gif') no-repeat;\");\n```\n更多内容可以参考[Chrome控制台新玩法-console显示图片以及为文字加样式](https://www.cnblogs.com/Wayou/p/chrome_dev_tool_style_console.html)。\n","tags":["JavaScript"],"categories":["Web开发"]},{"title":"macOS Chrome禁用双指手势","url":"/2019-04/macOS Chrome禁用双指手势/","content":"\nMac版Chrome自带双指手势前进后退功能，也就是在一个页面已经水平滑动到尽头后，继续向前/向后滑动，就会触发前进/后退。这个功能的初衷不错，只是容易误操作，博主一直想把它关闭了，但Chrome的设置里没有该选项，也没有从`chrome://flags/`中找到相关内容。\n后来发现可以通过命令行进行设置，操作方法是：\n\n禁用鼠标手势\n```bash\ndefaults write com.google.Chrome AppleEnableMouseSwipeNavigateWithScrolls -bool false\n```\n禁用触控板手势\n```bash\ndefaults write com.google.Chrome AppleEnableSwipeNavigateWithScrolls -bool false\n```\n\n参考文章：[Mac Chrome 关闭 双指手势 前进 后退](https://blog.csdn.net/HandSome696/article/details/79493889)\n","tags":["Mac"],"categories":["技术"]},{"title":"Test-driven Development","url":"/2019-03/Test-driven Development/","content":"\n![](/images/2019-03/test.driven.development.cartoon_0.jpg)\n\n图片来源：[Test-driven Development](https://www.icemobile.com/test-driven-development)\n","categories":["幽默"]},{"title":"神奇的求圆周率代码","url":"/2019-03/神奇的求圆周率代码/","content":"\n今天是圆周率日，我们就来讲一讲关于圆周率的故事吧。\n很久以前，博主看到了一段惊为天人的代码，可以求出圆周率的前800位（修改参数可以实现任意精度）：\n```c\nint a=10000,b,c=2800,d,e,f[2801],g;main(){for(;b-c;)f[b++]=a/5;\nfor(;d=0,g=c*2;c-=14,printf(\"%.4d\",e+d/a),e=d%a)for(b=c;d+=f[b]*a,\nf[b]=d%--g,d/=g--,--b;d*=b);}\n```\n[经过考证](https://crypto.stanford.edu/pbc/notes/pi/code.html)，这段代码的作者是Dik T. Winter。下面我们来看看它是如何工作的。\n\n在C语言中，`for`循环和`while`循环可以互相代替。这里涉及到`for`循环的执行顺序。例如\n```c\nfor (statement1; statement2; statement3) {\n    statements;\n}\n```\n上面的`for`语句可以用下面的`while`语句来代替：\n```c\nstatement1;\nwhile (statement2) {\n    statements;\n    statement3;\n}\n```\n而逗号运算符和`--`运算符的功能也是需要注意的。要写出这样怪异的C程序，逗号运算符无疑是一个好的助手，它的作用是：从左到右依次计算各个表达式的值，并且返回最右边表达式的值。\n\n了解这些内容后，我们将这段代码中的`for`循环展开，等价地写为`while`的形式。\n```c\n#include <stdio.h>\nint a = 10000, b, c = 2800, d, e, f[2801], g;\nmain() {\n    for (int i = 0; i < c; i++) {\n        f[i] = a / 5;\n    }\n    while (c != 0) {\n        d = 0;\n        g = c * 2;\n        b = c;\n        while (1) {\n            d += f[b] * a;\n            g--;\n            f[b] = d % g;\n            d /= g;\n            g--;\n            b--;\n            if (b == 0) break;\n            d *= b;\n        }\n        c -= 14;\n        printf(\"%.4d\", e + d / a);\n        e = d % a;\n    }\n}\n```\n<!-- more -->\n\n进一步观察，不难发现这里的`a`是常数，而`g`可以方便的代换掉。继续改写代码。\n```c\n#include <stdio.h>\nint b, c = 2800, d, e, f[2801]; \nmain() {\n    for (int i = 0; i < c; i++) {\n        f[i] = 2000;\n    }\n    while (c != 0) {\n        b = c;\n        d = f[b] * 10000;\n        f[b] = d % (b * 2 - 1);\n        d /= b * 2 - 1;\n        b--;\n        while (1) {\n            d = d * b + f[b] * 10000;\n            f[b] = d % (b * 2 - 1);\n            d = d / (b * 2 - 1);\n            b--;\n            if (b == 0) break;\n        }\n        c -= 14;\n        printf(\"%.4d\", e + d / 10000);\n        e = d % 10000;\n    }\n}\n```\n不过，即使是这样，这段代码还是让人看得很迷糊。我们不妨开个挂，进行倒推吧。\n我们来看看这段代码的数学对应。这是一个计算$\\pi$的公式：\n$$\\frac{\\pi}{2}=\\sum_{k=0}^{\\infty}\\frac{k!}{(2k+1)!!}=\\sum_{k=0}^{\\infty}\\frac{2^{k}k!^{2}}{(2k+1)!}=1+\\frac{1}{3}\\left(1+\\frac{2}{5}\\left(1+\\frac{3}{7}(1+\\cdots)\\right)\\right)$$\n可以进一步写为\n$$\\pi=2\\left(1+\\frac{1}{3}\\left(1+\\frac{2}{5}\\left(1+...\\left(1+\\frac{2799}{2\\cdot2799+1}(1+0)\\right)...\\right)\\right)\\right)$$\n根据维基百科的相关内容，该公式最早似乎由牛顿推出，而Wolfram收录的一个变式则写明作者是Beeler等人（参见[PiFormulas](http://mathworld.wolfram.com/PiFormulas.html)）。\n在这个迭代中，我们需要不断地生成形如$\\frac{k}{2k+1}$的分式。对应于展开后的代码，不难发现`g`就是分母，而`b`则是分子。\n当然，这还不是足够的。一个重要的问题是如何在逐次迭代中将误差进行传递，以实现任意精度的计算。整个程序中的唯一一个关系到输出的`printf`函数，每次会输出四位整数。那么`c -= 14`又是怎么来的呢？我们注意到$2^{14}>10^4=10000$，而$14\\times 200=2800$，$200\\times 4=800$，这些『神秘数字』就都说得通了。每次循环用14项获得4位精确的$\\pi$值，它们是一个八位整数的前四位，因此需要模10000；然后将后四位乘以10000，代入下一次循环。\n\n读者可以自行体会这个算法的精妙，特别是它是如何在不损失精度的情况下，完成整个计算过程。\n\n最后再附上一个Python版本：\n```python\n#!/usr/bin/env python3\n\na = 10000\nc = 2800\ne = 0\nf = [a // 5 for i in range(c + 1)]\n\nwhile c != 0:\n    d = 0\n    g = c * 2\n    b = c\n    while True:\n        d += f[b] * a\n        g -= 1\n        f[b] = d % g\n        d //= g\n        g -= 1\n        b -= 1\n        if b == 0:\n            break\n        d *= b\n    \n    c -= 14\n    print(\"%.4d\" % (e + d // a), end = \"\")\n    e = d % a\n```\n\n---\n\n参考文章：\n[Computing Pi in C](https://crypto.stanford.edu/pbc/notes/pi/code.html)\n[求圆周率Pi一万位程序分析](http://www.cnblogs.com/PegasusWang/archive/2013/03/17/2965189.html)\n\n拓展阅读：\n[编程计算Pi的N种方法](https://blog.csdn.net/s170262941/article/details/11123945)\n[Tiny programs for constants computation](http://numbers.computation.free.fr/Constants/TinyPrograms/tinycodes.html)\n[圓周率 - 维基百科](https://zh.wikipedia.org/wiki/圓周率)\n[圆周率近似值 - 维基百科](https://zh.wikipedia.org/wiki/圆周率近似值)\n[梅欽類公式 - 维基百科](https://zh.wikipedia.org/wiki/梅欽類公式)\n[The Pi-Search Page](http://www.angio.net/pi/)\n","tags":["C","数学"],"categories":["程序设计"]},{"title":"真正的红黑树","url":"/2019-03/真正的红黑树/","content":"\n![](/images/2019-03/IMG_4171.jpg)\n","categories":["幽默"]},{"title":"macOS Mojave动态壁纸","url":"/2019-02/macOS Mojave动态壁纸/","content":"\n![](/images/2019-02/1_qjVGv0IMNTeKFIcks41ohA.png)\n\nHow Apple built dynamic wallpapers? And is it possible to create your own dynamic wallpaper for macOS? I spent some time because I would like to answer to the both above questions.\nApple如何构建动态壁纸？是否可以为macOS创建自己的动态壁纸？我花了一些时间，因为我想回答上述两个问题。\n\n---\n\nIn Mojave we can choose new type of wallpaper: dynamic.\n在Mojave，我们可以选择新型壁纸：动态。\n\n![](/images/2019-02/1_4a3SZs7wS3g3AtO8E2RNvw.png)\n\nDepending on day time, system displays different wallpaper. At night it is picture of Mojave at night, during day it's picture of Mojave taken during day. So at night we have dark wallpaper at day we have light wallpaper.\n根据时间，系统会显示不同的壁纸。晚上显示Mojave晚上的照片，白天则是在白天拍摄的Mojave的照片。所以晚上我们有暗色的壁纸，白天则是明亮的壁纸。\n\nAll built in wallpapers in macOS we can find in folder: `/Library/Desktop Pictures`. Also here we can find dynamic wallpaper.\n我们可以在文件夹`/Library/Desktop Pictures`中找到所有macOS内置的壁纸。在这里我们也可以找到动态壁纸。\n\n![](/images/2019-02/1_lRpwIxzeyEoXMbz97ZfG5Q.png)\n\nDynamic wallpaper is saved as a HEIC file (`Mojave (Dynamic).heic`). More information about this type of file you can find on [Wikipedia](https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format). Generally this is type of file which Apple uses in iOS devices. Photos in iOS (also live photos) are stored as a HEIC file. That kind of file can contains multiple images/thumbnails and metadata in a single file.\n动态壁纸保存为HEIC文件（`Mojave (Dynamic).heic`）。有关此类文件的更多信息，请访问[Wikipedia](https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format)。通常，这是Apple在iOS设备中使用的文件类型。iOS中的照片（也包括实时照片）会存储为HEIC文件。这种文件可以在单个文件中包含多个图像/缩略图和元数据。\n\nThere is really good online tool where we can check content of Mojave wallpaper file: https://strukturag.github.io/libheif/. You can upload `Mojave (Dynamic).heic` file and you will see that in this single file there is 16 separate pictures taken in different day phase.\n有一个很好的在线工具，让我们可以检查Mojave壁纸文件的内容：https://strukturag.github.io/libheif/ 。你可以上传`Mojave (Dynamic).heic`文件，然后你会发现在这个单独的文件中有16张不同时间拍摄的单独照片。\n\n![](/images/2019-02/1_ESDAv949YKQIEocL-qDcGA.png)\n\nSo maybe it's enough to create new HEIC file with 16 separate images and macOS will show them properly. Let's try it!\n所以也许它足以创建具有16个单独图像的新HEIC文件，macOS将正确显示它们。我们来试试吧！\n\n<!-- more -->\nFirst I had to prepare 16 different images.\n首先，我必须准备16张不同的图像。\n\n![](/images/2019-02/1_VBLUh9q7ygeysmHmCPr7tQ.png)\n\nI know, I know - they are not impressive :-). However for our experiment they will be enough.\n我知道，我知道 - 它们非常trivial :-)。然而，对于我们的实验，它们就足够了。\n\nNow I have to prepare application which convert set of images to one HEIC file. I prepared simple console application in Swift.\n现在我必须准备一个能将图像集转换为HEIC文件的应用程序。我用Swift写了一个简单的控制台应用程序。\n```swift\nimport Foundation\nimport AppKit\nimport AVFoundation\n\nextension NSImage {\n    @objc var CGImage: CGImage? {\n        get {\n            guard let imageData = self.tiffRepresentation else { return nil }\n            guard let sourceData = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }\n            return CGImageSourceCreateImageAtIndex(sourceData, 0, nil)\n        }\n    }\n}\n\nlet output = \"wallpapers-new/output.heic\"\nlet quality = 0.9\nvar imageData: Data? = nil\n\nif let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n\n    let destinationData = NSMutableData()\n    if let destination = CGImageDestinationCreateWithData(destinationData, AVFileType.heic as CFString, 16, nil) {\n        let options = [kCGImageDestinationLossyCompressionQuality: quality]\n\n        for index in 1...16 {\n            let fileURL = dir.appendingPathComponent(\"wallpapers-new/\\(index).png\")\n            let orginalImage = NSImage(contentsOf: fileURL)\n\n            if let cgImage = orginalImage?.CGImage {\n                    CGImageDestinationAddImage(destination, cgImage, options as CFDictionary)\n            }\n        }\n\n        CGImageDestinationFinalize(destination)\n        imageData = destinationData as Data\n\n        let outputURL = dir.appendingPathComponent(output)\n        try! imageData?.write(to: outputURL)\n    }\n}\n```\n\nApplication requires that in my `Documents` folder I have `wallpaper-new` folder with 16 images (from `1.png` to `16.png`). I can run application and after that I have new `output.heic` file in the same directory.\n应用程序要求在我的`Documents`文件夹中存在有`wallpaper-new`文件夹，里面有16张图片（从`1.png`到`16.png`）。我可以运行应用程序，之后我在同一目录中有了新的`output.heic`文件。\n\nAfter setting this file as a wallpaper I had only one image displayed during whole day. So it seems that this file have to contains something extra. I decided to check what metadata is inside original Mojave wallpaper. I downloaded [libheif](https://github.com/strukturag/libheif) library (I modified a little bit `heif-info` application) and I've got below result:\n将此文件设置为壁纸后，我在一整天中只显示了一个图像。所以似乎这个文件必须包含额外的东西。我决定检查原始Mojave壁纸中的元数据。我下载了[libheif](https://github.com/strukturag/libheif)库（修改了一下`heif-info`应用程序），然后得到了以下结果：\n```bash\nNumber of top level images: 16\n    image #0\n        id: 61\n        width: 5120\n        height: 2880\n        is primary: yes\n        number of metadata: 1\n        metadata type: mime\n        content type: application/rdf+xml\n        metadata size: 3302\n        metadata content:\n\n<?xpacket begin=\"\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?> <x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"XMP Core 5.4.0\"> <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"> <rdf:Description rdf:about=\"\" xmlns:apple_desktop=\"http://ns.apple.com/namespace/1.0/\" apple_desktop:solar=\"YnBsaXN0MDDRAQJSc2mvEBADDBAUGBwgJCgsMDQ4PEFF1AQFBgcICQoLUWlRelFhUW8QACNAcO7vOubr3yO/1e+pmkOtXBAB1AQFBgcNDg8LEAEjQFRxqCKOFiAjwCR6waUkDgHUBAUGBxESEwsQAiNAVZV4BI4c+CPAEP2uFrMcrdQEBQYHFRYXCxADI0BWtALKmrjwIz/2ObLnx6l21AQFBgcZGhsLEAQjQFfTrJlEjnwjQByrLle1Q0rUBAUGBx0eHwsQBSNAWPrrmI0ISCNAKiwhpSRpc9QEBQYHISIjCxAGI0BgJff9KDpyI0BENTOsilht1AQFBgclJicLEAcjQGbHdYIVQKojQEq3fAg86lXUBAUGBykqKwsQCCNAbTGmpC2YRiNAQ2WFOZGjntQEBQYHLS4vCxAJI0BwXfII2B+SI0AmLcjfuC7g1AQFBgcxMjMLEAojQHCnF6YrsxcjQBS9AVBLTq3UBAUGBzU2NwsQCyNAcTcSnimmjCPAGP5E0ASXJtQEBQYHOTo7CxAMI0BxgSADjxK2I8AoalieOTyE1AQFBgc9Pj9AEA0jQHNWsnnMcWIjwEO+oq1pXr8QANQEBQYHQkNEQBAOI0ABZpkFpAcAI8BKYGg/VvMf1AQFBgdGR0hAEA8jQErBKblRzPgjwEMGElBIUO0ACAALAA4AIQAqACwALgAwADIANAA9AEYASABRAFMAXABlAG4AcAB5AIIAiwCNAJYAnwCoAKoAswC8AMUAxwDQANkA4gDkAO0A9gD/AQEBCgETARwBHgEnATABOQE7AUQBTQFWAVgBYQFqAXMBdQF+AYcBkAGSAZsBpAGtAa8BuAHBAcMBzAHOAdcB4AHpAesB9AAAAAAAAAIBAAAAAAAAAEkAAAAAAAAAAAAAAAAAAAH9\"/> </rdf:RDF> </x:xmpmeta><?xpacket end=\"w\"?>\n\n    image #1\n        id: 123\n        width: 5120\n        height: 2880\n    image #2\n        id: 184\n        width: 5120\n        height: 2880\n    image #3\n        id: 245\n        width: 5120\n        height: 2880\n    image #4\n        id: 306\n        width: 5120\n        height: 2880\n    image #5\n        id: 367\n        width: 5120\n        height: 2880\n    image #6\n        id: 428\n        width: 5120\n        height: 2880\n    image #7\n        id: 489\n        width: 5120\n        height: 2880\n    image #8\n        id: 550\n        width: 5120\n        height: 2880\n    image #9\n        id: 611\n        width: 5120\n        height: 2880\n    image #10\n        id: 672\n        width: 5120\n        height: 2880\n    image #11\n        id: 733\n        width: 5120\n        height: 2880\n    image #12\n        id: 794\n        width: 5120\n        height: 2880\n    image #13\n        id: 855\n        width: 5120\n        height: 2880\n    image #14\n        id: 916\n        width: 5120\n        height: 2880\n    image #15\n        id: 977\n        width: 5120\n        height: 2880\n```\n\nThus we can see that in the first image we have additional [XMP metadata](https://www.adobe.com/products/xmp.html). Now I know that I have to modify a little bit my Swift application. It should also add metadata for the first image in the sequence.\n因此，我们可以看到在第一张图片中我们有额外的[XMP元数据](https://www.adobe.com/products/xmp.html)。现在我知道我必须修改一下我的Swift应用程序。它还应该为序列中的第一个图像添加元数据。\n```swift\nimport Foundation\nimport AppKit\nimport AVFoundation\n\nextension NSImage {\n    @objc var CGImage: CGImage? {\n        get {\n            guard let imageData = self.tiffRepresentation else { return nil }\n            guard let sourceData = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }\n            return CGImageSourceCreateImageAtIndex(sourceData, 0, nil)\n        }\n    }\n}\n\nlet output = \"wallpapers-new/output.heic\"\nlet quality = 0.9\nvar imageData: Data? = nil\n\nif let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n\n    let destinationData = NSMutableData()\n    if let destination = CGImageDestinationCreateWithData(destinationData, AVFileType.heic as CFString, 16, nil) {\n        let options = [kCGImageDestinationLossyCompressionQuality: quality]\n\n        for index in 1...16 {\n            let fileURL = dir.appendingPathComponent(\"wallpapers-new/\\(index).png\")\n            let orginalImage = NSImage(contentsOf: fileURL)\n\n            if let cgImage = orginalImage?.CGImage {\n\n                if index == 1 {\n                    let imageMetadata = CGImageMetadataCreateMutable()\n\n                    let imageMetadataTag = CGImageMetadataTagCreate(\"http://ns.apple.com/namespace/1.0/\" as CFString, \n                                                                    \"apple_desktop\" as CFString, \n                                                                    \"solar\" as CFString, \n                                                                    CGImageMetadataType.string, \n                                                                    \"YnBsaXN0MDDRAQJSc2mvEBADDBAUGBwgJCgsMDQ4PEFF1AQFB\" +\n                                                                    \"gcICQoLUWlRelFhUW8QACNAcO7vOubr3yO/1e+pmkOtXBAB1A\" +\n                                                                    \"QFBgcNDg8LEAEjQFRxqCKOFiAjwCR6waUkDgHUBAUGBxESEws\" +\n                                                                    \"QAiNAVZV4BI4c+CPAEP2uFrMcrdQEBQYHFRYXCxADI0BWtALK\" +\n                                                                    \"mrjwIz/2ObLnx6l21AQFBgcZGhsLEAQjQFfTrJlEjnwjQByrL\" +\n                                                                    \"le1Q0rUBAUGBx0eHwsQBSNAWPrrmI0ISCNAKiwhpSRpc9QEBQ\" +\n                                                                    \"YHISIjCxAGI0BgJff9KDpyI0BENTOsilht1AQFBgclJicLEAc\" +\n                                                                    \"jQGbHdYIVQKojQEq3fAg86lXUBAUGBykqKwsQCCNAbTGmpC2Y\" +\n                                                                    \"RiNAQ2WFOZGjntQEBQYHLS4vCxAJI0BwXfII2B+SI0AmLcjfu\" +\n                                                                    \"C7g1AQFBgcxMjMLEAojQHCnF6YrsxcjQBS9AVBLTq3UBAUGBz\" +\n                                                                    \"U2NwsQCyNAcTcSnimmjCPAGP5E0ASXJtQEBQYHOTo7CxAMI0B\" +\n                                                                    \"xgSADjxK2I8AoalieOTyE1AQFBgc9Pj9AEA0jQHNWsnnMcWIj\" +\n                                                                    \"wEO+oq1pXr8QANQEBQYHQkNEQBAOI0ABZpkFpAcAI8BKYGg/V\" +\n                                                                    \"vMf1AQFBgdGR0hAEA8jQErBKblRzPgjwEMGElBIUO0ACAALAA\" +\n                                                                    \"4AIQAqACwALgAwADIANAA9AEYASABRAFMAXABlAG4AcAB5AII\" +\n                                                                    \"AiwCNAJYAnwCoAKoAswC8AMUAxwDQANkA4gDkAO0A9gD/AQEB\" +\n                                                                    \"CgETARwBHgEnATABOQE7AUQBTQFWAVgBYQFqAXMBdQF+AYcBk\" +\n                                                                    \"AGSAZsBpAGtAa8BuAHBAcMBzAHOAdcB4AHpAesB9AAAAAAAAA\" +\n                                                                    \"IBAAAAAAAAAEkAAAAAAAAAAAAAAAAAAAH9\" as CFTypeRef)\n\n                    let success = CGImageMetadataSetTagWithPath(imageMetadata, nil, \"xmp:solar\" as CFString, imageMetadataTag!)\n                    if !success {\n                        print(\"Error!!!\")\n                    }\n\n                    CGImageDestinationAddImageAndMetadata(destination, cgImage, imageMetadata, options as CFDictionary)\n\n                } else {\n                    CGImageDestinationAddImage(destination, cgImage, options as CFDictionary)\n                }\n            }\n        }\n\n        CGImageDestinationFinalize(destination)\n        imageData = destinationData as Data\n\n        let outputURL = dir.appendingPathComponent(output)\n        try! imageData?.write(to: outputURL)\n    }\n}\n```\n\nNow we can set up our new file as a wallpaper. And this is the result:\n现在我们可以将新文件设置为壁纸。这就是结果：\nhttps://www.youtube.com/watch?v=_r0Qxblyz8U\n\n**It works!** We can prepare our custom dynamic wallpaper! And it's pretty easy.\n**它是有效的！**我们可以准备我们的自定义动态壁纸！这很容易。\n\n---\n\nNow the question is: what is in the `apple_desktop:solar` attribute? It seems that this is something encoded in base64. We can save value of that attribute as a text file (e.g. `text.base64`) and run following command:\n现在的问题是：`apple_desktop：solar`属性是什么？似乎这是base64编码的东西。我们可以将该属性的值保存为文本文件（例如`text.base64`）并运行以下命令：\n```bash\nbase64 -D text.base64 -o decoded.txt\n```\n\nAfter opening `decoded.txt` file we can notice that it starts from: `bplist00`. So it seems that it's binary `plist` file. We can run next command:\n打开`decoding.txt`文件后，我们可以注意到它从`bplist00`开始。所以它似乎是二进制`plist`文件。我们可以运行下一个命令：\n```bash\nplutil -convert xml1 decoded.txt\n```\n\nAnd now in `decoded.txt` file we have XML with data which was prepared by Apple.\n现在在`decoding.txt`文件中，我们拥有由Apple准备的XML数据。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n <key>si</key>\n <array>\n  <dict>\n   <key>a</key>\n   <real>-0.34275283875350282</real>\n   <key>i</key>\n   <integer>0</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>270.9334057827345</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-10.239758644725045</real>\n   <key>i</key>\n   <integer>1</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>81.775887144809985</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-4.2477344080754564</real>\n   <key>i</key>\n   <integer>2</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>86.33545030477751</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>1.3890866331008431</real>\n   <key>i</key>\n   <integer>3</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>90.812670374961954</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>7.167168970526129</real>\n   <key>i</key>\n   <integer>4</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>95.307409588765893</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>13.08619419164163</real>\n   <key>i</key>\n   <integer>5</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>99.920629632689383</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>40.415639464904281</real>\n   <key>i</key>\n   <integer>6</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>129.18652208191958</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>53.433472661727741</real>\n   <key>i</key>\n   <integer>7</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>182.23309425497911</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>38.793128200638634</real>\n   <key>i</key>\n   <integer>8</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>233.55159195809591</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>11.089423171265878</real>\n   <key>i</key>\n   <integer>9</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>261.87159046576664</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>5.1845753236736245</real>\n   <key>i</key>\n   <integer>10</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>266.44327370710511</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-6.2483093741227886</real>\n   <key>i</key>\n   <integer>11</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>275.44204536695247</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-12.20770735214888</real>\n   <key>i</key>\n   <integer>12</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>280.07031589401174</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-39.48933951993012</real>\n   <key>i</key>\n   <integer>13</integer>\n   <key>o</key>\n   <integer>0</integer>\n   <key>z</key>\n   <real>309.41857318745144</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-52.753181378799347</real>\n   <key>i</key>\n   <integer>14</integer>\n   <key>o</key>\n   <integer>0</integer>\n   <key>z</key>\n   <real>2.1750965538675473</real>\n  </dict>\n  <dict>\n   <key>a</key>\n   <real>-38.04743388682423</real>\n   <key>i</key>\n   <integer>15</integer>\n   <key>o</key>\n   <integer>0</integer>\n   <key>z</key>\n   <real>53.509085812513092</real>\n  </dict>\n </array>\n</dict>\n</plist>\n```\n\nWe have 16 `dict` elements (one for each image) with four keys:\n我们有16个`dict`元素（每个图像一个），有四个键：\n\n- a - (probably) some time marker\na - （可能）一些时间标记\n- i - image index\ni - 图像索引\n- o - ? (in current Mojave wallpaper it is always equal 0)\no - ？（在当前的Mojave壁纸中它始终等于0）\n- z - some time marker\nz - 一些时间标记\n\nUnfortunately I don't know yet how to convert above float numbers to time markers. If you have some ideas please let me know. Then I will have all mandatory pieces to build macOS application which based on chosen files will generate dynamic wallpaper.\n不幸的是我还不知道如何将浮点数转换为时间标记。如果您有任何想法，请告诉我。然后我将有所有强制性的部分来构建基于所选文件的macOS应用程序将生成动态壁纸。\n\nFor now I can build only wallpaper which will behave exactly the same way like Apple's wallpaper.\n现在我只能制作壁纸，其行为与Apple的壁纸完全相同。\n\n---\n\n![](/images/2019-02/1_YU1DYB5fNiLZnqjKQCxI-Q.png)\n\nIn my previous article I described how dynamic wallpapers works. I didn't know then what some of the properties in metadata means. I asked if somebody else knows what that properties means, and I've got a response really quickly. On Twitter @zwaldowski wrote to me explanation what all properties stands for.\n在我的上一篇文章中，我描述了动态壁纸的工作原理。我不知道元数据中的某些属性意味着什么。我问其他人是否知道这些属性意味着什么，而且我很快得到了答复。在Twitter上@zwaldowski给我写了解释所有属性的含义。\n\n![](/images/2019-02/1_Q4Uu6sT5PufFzDOxgAI9XQ.png)\n\nThus, as I wrote previously, in HEIC file we have metadata which looks like on below snippet.\n因此，正如我之前所写，在HEIC文件中，我们有一些元数据，如下面的代码片段所示。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n <key>si</key>\n <array>\n  <dict>\n   <key>a</key>\n   <real>-0.34275283875350282</real>\n   <key>i</key>\n   <integer>0</integer>\n   <key>o</key>\n   <integer>1</integer>\n   <key>z</key>\n   <real>270.9334057827345</real>\n  </dict>\n\n    ...\n\n </array>\n</dict>\n```\n\nWe have 16 `dict` elements (one for each image) with four keys:\n我们有16个`dict`元素（每个图像一个），有四个键：\n\n- a - altitude\na - 海拔高度\n- i - image index\ni - 图像索引\n- o - indicates in which desktop theme image should be displayed. 0 - displays in both mode (light/dark). 1 - displays only in light mode.\no - 表示应显示哪个桌面主题图像。0 - 以两种模式（亮/暗）显示。1 - 仅在灯光模式下显示。\n- z - azimuth\nz - 方位角\n\nThanks to [altitude and azimuth](https://en.wikipedia.org/wiki/Horizontal_coordinate_system) w exactly know where the Sun was when image was taken.\n感谢[海拔高度和方位角](https://en.wikipedia.org/wiki/Horizo​​ntal_coordinate_system)，可以确切知道拍摄图像时太阳的位置。\n\n![](/images/2019-02/1_yhrXm56MaqMLfRLYTWaTtw.png)\n\nThis idea is brilliant, because thanks to this information macOS can change images differently during Summer and during Winter. System knows where the Sun is and it will choose image which was taken in similar conditions. **Brilliant**.\n这个想法很棒，因为由于这些信息，macOS可以在夏季和冬季期间以不同方式更改图像。系统知道太阳在哪里，它将选择在类似条件下拍摄的图像。**太机智了**。\n\n---\n\nBased on that knowledge I prepared new dynamic wallpaper. Here is the video how it looks like:\n基于这些知识，我准备了新的动态壁纸。以下是视频：\nhttps://www.youtube.com/watch?v=TVqfPzdsbzY\n\nYou can download that wallpaper from my Dropbox:\n你可以从我的Dropbox下载这个壁纸：\nhttps://www.dropbox.com/s/kd2g59qswchsd0v/Earth%20View.heic?dl=0\n\nThank you for your help and feedback!\n感谢您的帮助和反馈！\n\n---\n\n**Update:** I created simple console application for macOS which can help you with creating custom dynamic wallpapers: https://github.com/mczachurski/wallpapper\n**更新：**我为macOS创建了简单的控制台应用程序，它可以帮助您创建自定义动态壁纸：https://github.com/mczachurski/wallpapper\n\n本文翻译自：\nhttps://itnext.io/macos-mojave-dynamic-wallpaper-fd26b0698223\nhttps://itnext.io/macos-mojave-dynamic-wallpapers-ii-f8b1e55c82f\n","tags":["Mac"],"categories":["技术"]},{"title":"十五的月亮十五圆","url":"/2019-02/十五的月亮十五圆/","content":"\n![](/images/2019-02/IMG_4634.jpg)\n\n> 摄于己亥年正月十六\n","tags":["摄影"],"categories":["其他"]},{"title":"用Telnet观看Bad Apple!!","url":"/2019-02/用Telnet观看Bad Apple!!/","content":"\n在前面的文章[用Telnet观看Nyancat动画](/2018-11/用Telnet观看Nyancat动画/)中，博主曾表示正在尝试搭建一个可以播放Bad Apple!!的Telnet服务器。以Nyancat为基础，改写的过程并不复杂（除了硬编码了一个头文件，存储了所有动画帧）；只是因为懒，所以现在才终于完工了。你可以通过执行`telnet zsq.im`查看效果。\n\n![](/images/2019-02/IMG_1061.jpg)\n\n下面附上安装方法。\n\n## 下载编译\n\n在命令行执行：\n```bash\ngit clone https://github.com/stevenjoezhang/badapple.git\ncd badapple\nmake\nmv src/badapple /usr/bin #or make install\n```\n这时，通过`badapple`或`badapple -t`命令就可以查看效果。接下来把Telnet配置好就行了。\n\n## 配置Telnet\n\n这与之前的那篇文章几乎完全相同，仍然需要使用`xinetd`。只要把`server`中的`/usr/bin/nyancat`替换为`/usr/bin/badapple`即可。\n","tags":["Linux"],"categories":["技术"]},{"title":"米米影视新片头震撼发布","url":"/2019-02/米米影视新片头震撼发布/","content":"\n新年快乐！值此新春佳节之际，米米影视的新版片头正式推出了。借助于Final Cut Pro，新片头成功地融合了理想与现实、传统与现代，让你体会到无与伦比的、直击心灵的震撼。\n\n{% video /files/intro.mp4 %}\n","categories":["其他"]},{"title":"鱼眼镜头与小行星特效","url":"/2019-01/鱼眼镜头与小行星特效/","content":"\n![](/images/2019-01/EclipsePrince_Vetter_1500.jpg)\n\nIn this beautifully rendered \"little planet\" image, photographer [Stephane Vetter](https://www.facebook.com/stephane.vetter.nuitsacrees) fuses both night and day captured from a single location at Magone Lake in Oregon during the August 21st solar eclipse. The shot required tons of careful planning, and here's an explanation of how he did it via [Astronomy Picture of the Day](https://apod.nasa.gov/apod/astropix.html):\n在8月21日的日食期间，摄影师[Stephane Vetter](https://www.facebook.com/stephane.vetter.nuitsacrees)于俄勒冈州马格纳湖的同一地点，融合了白天和黑夜的景象，完成了这个精美渲染的『小行星』图像。拍摄需要大量的精心策划，这里是他通过[Astronomy Picture of the Day](https://apod.nasa.gov/apod/astropix.html)解释他是如何做到的：\n\n> This featured little-planet, all-sky, double time-lapse, digitally-fused composite captured celestial action during both night and day from a single location. In this 360×180 panorama, north and south are at the image bottom and top, while east and west are at the left and right edges, respectively. During four hours the night before the eclipse, star trails were captured circling the north celestial pole (bottom) as the Earth spun. During the day of the total eclipse, the Sun was captured every fifteen minutes from sunrise to sunset (top), sometimes in partial eclipse. All of these images were then digitally merged onto a single image taken exactly during the total solar eclipse. Then, the Sun's bright corona could be seen flaring around the dark new Moon (upper left), while Venus simultaneously became easily visible (top). The tree in the middle, below the camera, is a Douglas fir.\n> 这是一个小行星、全天空、双时延、数字融合的复合材料，在同一个地方，从夜间到白天持续捕获天体运动。在这个360×180全景图中，北部和南部分别位于图像的底部和顶部，而东部和西部分别位于左右边缘。在日食前一个晚上的四个小时内，当地球旋转时，在北天极（底部）环绕着星轨。在日全食期间，从日出到日落（上图）每隔十五分钟拍摄一次太阳，有时是偏食。然后将所有这些图像数字合并到在日全食期间拍摄的单个图像上。然后，可以看到太阳的明亮日冕在黑暗的新月（左上）周围闪烁，而金星同时变得容易看见（顶部）。中间的树，在相机下面，是道格拉斯冷杉。\n\nSo, just your typical full eclipse, little-planet, all-sky, double time-lapse photo by a fir tree, really. You can see more of Vetter's photography on his [website](http://nuitsacrees.fr).\n所以，这就是典型的日全食、小行星、全天空、双时延照片，借助一棵冷杉拍摄，仅此而已。你可以在Vetter的[网站](http://nuitsacrees.fr)上看到更多他的摄影作品。\n\n---\n\n本文翻译自：[A Panoramic Full Eclipse Composite with Star Trails Captured by Stephane Vetter](https://www.thisiscolossal.com/2017/08/a-panoramic-eclipse-composite-with-star-trails-captured-by-stephane-vetter/)\n\n这样的『小行星』图像虽然具有鱼眼镜头的扭曲效果，但是并不一定需要使用鱼眼镜头拍摄。通过强大的图像后期处理技术，只要拍摄多个角度的照片，也可以合成出这样的效果。\n\n拓展阅读：[360度球状全景的照片是怎样拍出来的？ - 知乎](https://www.zhihu.com/question/27440901)\n\n更多小行星特效：\n[小行星转场+车内全景](http://720.jum8.com/quanjing/xx/)\n[天使眼中的天堂——华中师大一附中](https://720yun.com/t/eeb24mf59tn?scene_id=487241)\n","tags":["摄影"],"categories":["技术"]},{"title":"树莓派使用RFID RC522芯片","url":"/2019-01/树莓派使用RFID RC522芯片/","content":"\n实用教程：树莓派使用RFID RC522芯片进行数据的读写\n\n![](/images/2019-01/raspberry-pi-RFID-Reader.jpg)\n\nIn this Raspberry Pi RFID RC522 tutorial, I will be walking you through the steps on how to set up and wire the RFID RC522 chip with your Raspberry Pi. This project is a cool circuit to play around with and opens you up to quite a wide variety of different projects from using it as an attendance system to using it to open a lock.\n在这个Raspberry Pi RFID RC522教程中，我将介绍如何设置和连接Raspberry Pi和RFID RC522芯片。这是一个很实用的教程，以便于你之后各种不同的项目，例如使用它作为考勤系统、使用它来打开一个锁。\n\nThe RFID RC522 is a very low-cost RFID (Radio-frequency identification) reader and writer that is based on the MFRC522 microcontroller. This microcontroller provides its data through the SPI protocol and works by creating a 13.56MHz electromagnetic field that it uses to communicate with the RFID tags.\nRFID RC522是基于MFRC522微控制器的非常低成本的RFID（射频识别）读写器。该微控制器通过SPI协议提供数据，并通过创建一个13.56MHz的电磁场来工作，该电磁场用于与RFID卡片进行通信。\n\nMake sure that the tags you purchase for your RFID RC522 operate on the 13.56MHz frequency otherwise we will fail to read them.\n确保你的RFID RC522购买的卡片在13.56MHz的频率上运行，否则将无法读取。\n\nWe will be showing you how to wire up the RC522 as well as showing you how to write Python scripts to interact with the chip so you can both read and write your RFID Tags. You can extend this tutorial to use something like a [16×2 LCD for the Raspberry Pi](https://pimylifeup.com/raspberry-pi-lcd-16x2), handy if you want to show some information.\n本教程将示范如何连接RC522以及编写Python脚本以与芯片进行交互，以便读取和写入RFID卡片。如果你想展示一些数据信息，你可以使用像[16×2液晶显示器](https://pimylifeup.com/raspberry-pi-lcd-16x2)扩展这个教程。\n\n## Equipment List\n设备清单\n\nBelow are all the bits and pieces that I used for this Raspberry Pi RFID RC522 tutorial.\n下面列出的是我在这个教程中使用的东西。\n\nRecommended:\n推荐：\n\n- Raspberry Pi 2 or 3\n树莓派2或3\n\n- Micro SD Card\nMicro SD卡\n\n- Power Supply\n电源供应\n\n- RC522 RFID Reader\nRC522 RFID读卡器\n\n- Breadboard\n面包板\n\n- Breadboard Wire\n面包板接线\n\nOptional:\n可选：\n\n- Raspberry Pi Case\n树莓派外壳\n\n- Ethernet Network Connection or Wifi dongle (The Pi 3 has WiFi inbuilt)\n以太网或Wifi适配（树莓派3自带了）\n\n<!-- more -->\n## Assembling the RFID RC522\n组装RFID RC522\n\nOne thing you will notice when purchasing an RFID RC522 Reader is that 90% of them don't come with the header pins already soldered in. The missing pins mean you will have to do it yourself, luckily soldering header pins is a rather simple task, even for beginners.\n购买RFID RC522读卡器时你会注意到的一件事情是，90％的读卡器没有使用已经焊接好的插头引脚。这意味着你必须自己做，幸运的是，焊接插头引脚是一个相当简单的任务，即使是对于初学者而言。\n\nFirst off, if the header pins you received with your RC522 isn't the correct size, then snap them down, so you only have a single row of eight pins.\n首先，如果你使用RC522收到的插头引脚不是正确的大小，那么你只有一行8个引脚。\n\nPlace the header pins up through the holes of your RC522. One handy trick is to put the long side of the header pins into a breadboard and then putting the circuit over the top of the header pins. The breadboard will hold the pins tightly making it easier to solder them to the RFID RC522 circuit.\n将插头引脚向上穿过RC522的孔。一个小窍门是把插头引脚的长边插入面包板，然后把电路放在接头引脚的顶部。面包板将固定住引脚，使其更容易焊接到RFID RC522电路。\n\nNow using a hot soldering iron and some solder, slowly solder each of the pins. Remember it is best to heat the joint slightly before applying solder to it, this will ensure that the solder will adhere more to the joint and reduce the chances of creating a cold joint. We also recommend being careful with the amount of solder you apply.\n现在使用热的烙铁和一些焊锡，慢慢地焊接每个引脚。请记住，在焊接之前，最好稍微加热接头，这样可以确保焊锡更多地粘附在接头上，并减少了形成冷接头的机会。我们还建议小心使用焊锡，避免过量。\n\nWith the header pins now soldered to your RFID circuit, it is now ready to use, and you can continue with the tutorial.\n现在插头引脚已经焊接到你的RFID电路上，现在可以使用了，你可以跟着这个教程继续。\n\n## Wiring the RFID RC522\n连接RFID RC522\n\nOn your RFID RC522 you will notice that there are 8 possible connections on it, these being **SDA** (Serial Data Signal), **SCK** (Serial Clock), **MOSI** (Master Out Slave In), **MISO** (Master In Slave Out), **IRQ** (Interrupt Request), **GND** (Ground Power), **RST** (Reset-Circuit) and **3.3v** (3.3v Power In). We will need to wire all of these but the **IRQ** to our Raspberry Pi's GPIO pins.\n在你的RFID RC522上，你会发现，它有8个可能的引脚，这分别是**SDA**（串行数据信号），**SCK**（串行时钟），**MOSI**（主出从入），**MISO**（主入从出），**IRQ**（中断请求），**GND**（地面电源），**RST**（复位电路）和**3.3V**（3.3V电源输入）。我们需要把所有这些引脚，除了**IRQ**之外，都连接到Raspberry Pi的GPIO引脚。\n\nYou can either wire these directly to the GPIO Pins or like we did in this tutorial, plug the RFID RC522 into our Breadboard then wire from there to our Raspberry Pi's GPIO Pins.\n你可以将这些直接连接到GPIO引脚，或者像我们在本教程中所做的那样，将RFID RC522插入我们的面包板，然后从那里连接到我们的Raspberry Pi的GPIO引脚。\n\nWiring your RFID RC522 to your Raspberry Pi is fairly simple, with it requiring you to connect just 7 of the GPIO Pins directly to the RFID reader. Follow the table below, and check out our GPIO guide to see the positions of the GPIO pins that you need to connect your RC522 to.\n将RFID RC522连接到Raspberry Pi相当简单，只需要将7个GPIO引脚直接连接到RFID读卡器。请遵循下表，并查阅我们的GPIO指南，查看连接RC522所需的GPIO引脚位置。\n\n- **SDA** connects to Pin 24.\n**SDA**连接到引脚24。\n\n- **SCK** connects to Pin 23.\n**SCK**连接到引脚23。\n\n- **MOSI** connects to Pin 19.\n**MOSI**连接到引脚19。\n\n- **MISO** connects to Pin 21.\n**MISO**连接到引脚21。\n\n- **GND** connects to Pin 6.\n**GND**连接到引脚6。\n\n- **RST** connects to Pin 22.\n**RST**连接到引脚22。\n\n- **3.3v** connects to Pin 1.\n**3.3V**连接到引脚1。\n\n![](/images/2019-01/RFID-Fritz-v2.png)\n\n![](/images/2019-01/RFID-GPIO-Connection.jpg)\n\n## Setting up Raspbian for the RFID RC522\n为RFID RC522设置Raspbian\n\nBefore we begin the process of utilizing the RFID RC522 on our Raspberry Pi, we will first have to make changes to its configuration. By default, the Raspberry Pi has the SPI (Serial Peripheral Interface) disabled, which is a bit of a problem as that is what our RFID reader circuit runs through.\n在我们开始在Raspberry Pi上使用RFID RC522之前，我们将首先对其配置进行更改。默认情况下，树莓派的SPI（串行外设接口）是被禁用的。\nDon't worry though as it is fairly simple to re-enable this interface, just follow our steps below to configure your Raspberry Pi and Raspbian to utilize the SPI interface.\n不要担心，因为重新启用此接口非常简单，只需按照以下步骤配置Raspberry Pi和Raspbian即可使用SPI接口。\n\nLet's begin by first opening the **raspi-config** tool, and we can do this by opening the terminal and running the following command.\n首先打开**raspi-config**工具，打开终端并运行以下命令：\n```bash\nsudo raspi-config\n```\nThis tool will load up a screen showing a variety of different options. If you want a more in-depth look into these options, you can check [out our raspi-config guide](https://pimylifeup.com/raspi-config-tool).\n该工具将加载一个显示各种不同选项的界面。如果你想深入了解这些选项，可以参阅我们的[raspi-config指南](https://pimylifeup.com/raspi-config-tool)。\n\nOn here use the **arrow keys** to select **\"5 Interfacing Options\"**. Once you have this option selected, press **Enter**.\n在这里使用**方向键**选择『**5 Interfacing Options**』。选中此选项后，按**回车**。\n\nNow on this next screen, you want to use your **arrow keys** to select **\"P4 SPI\"**, again press Enter to select the option once it is highlighted.\n现在在下一个界面上，你需要使用**方向键**选择『**P4 SPI**』，再次按回车选择高亮显示的选项。\n\nYou will now be asked if you want to enable the SPI Interface, select **Yes** with your **arrow keys** and press **Enter** to proceed. You will need to wait a little bit while the **raspi-config** tool does its thing in enabling SPI.\n现在将询问你是否要启用SPI接口，使用**方向键**选择**Yes**，然后按**回车**继续。你需要等一会儿，**raspi-config**工具会启用SPI。\n\nOnce the SPI interface has been successfully enabled by the **raspi-config** tool you should see the following text appear on the screen, **\"The SPI interface is enabled\"**.\n一旦通过**raspi-config**工具成功启用了SPI接口，你应该会看到屏幕上出现以下文本：『**The SPI interface is enabled**』。\n\nBefore the SPI Interface is fully enabled we will first have to restart the Raspberry Pi. To do this first get back to the terminal by pressing **Enter** and then <kbd>**Esc**<kbd>.\n在SPI接口完全启用之前，我们将首先重新启动Raspberry Pi。要做到这一点首先回到终端按**回车**，然后按<kbd>**Esc**<kbd>。\n\nType the following [Linux command into the terminal](https://pimylifeup.com/linux-commands-cheat-sheet) on your Raspberry Pi to restart your Raspberry Pi.\n在Raspberry Pi的终端中输入以下[Linux命令](https://pimylifeup.com/linux-commands-cheat-sheet)来重启。\n```bash\nsudo reboot\n```\n\nOnce your Raspberry Pi has finished rebooting, we can now check to make sure that it has in fact been enabled. The easiest way to do this is to run the following command to see if **spi_bcm2835** is listed.\n在Raspberry Pi完成重启后，我们现在可以检查确认它已经被启用。最简单的方法是运行以下命令，查看是否列出了**spi_bcm2835**。\n```bash\nlsmod | grep spi\n```\nIf you see **spi_bcm2835**, then you can proceed on with this tutorial and skip on to the next section. If for some reason it had not appeared when you entered the previous command, try following the next three steps.\n如果你看到**spi_bcm2835**，那么你可以继续，直接跳到下一节。如果由于某种原因，当你输入上一个命令时没有出现，请尝试执行以下3个步骤。\n\nIf for some reason the SPI module has not activated, we can edit the boot configuration file manually by running the following command on our Raspberry Pi.\n如果由于某种原因SPI模块没有激活，我们可以通过在我们的Raspberry Pi上运行以下命令来手动编辑启动配置文件。\n```bash\nsudo nano /boot/config.txt\n```\n\nWithin the configuration file, use <kbd>Ctrl</kbd>+<kbd>W</kbd> to find **\"dtparam=spi=on\"**.\n在配置文件中，使用<kbd>Ctrl</kbd>+<kbd>W</kbd>查找『**dtparam=spi=on**』。\n\nIf you have found it, check to see if there is a # in front of it. If there is, remove it as this is commenting out the activation line. If you can't find the line at all, add \"dtparam=spi=on\" to the bottom of the file.\n如果你找到了，请检查前面是否有`#`号。如果有，就删除它，因为这是用来注释一行代码的。如果找不到该行，只需在文件底部添加『dtparam = spi = on』即可。\n\nOnce you have made the changes, you can press <kbd>Ctrl</kbd>+<kbd>X</kbd> then pressing <kbd>Y</kbd> and then Enter to save the changes.\n完成更改后，可以按<kbd>Ctrl</kbd>+<kbd>X</kbd>，然后按<kbd>Y</kbd>，然后按回车以保存更改。\n\nYou can now proceed from Step 5 again, rebooting your Raspberry Pi then checking to see if the module has been enabled.\n现在，你可以回到前面的步骤，重新启动Raspberry Pi，然后检查模块是否已启用。\n\n## Getting Python ready for the RFID RC522\n为RFID RC522准备好Python\n\nNow that we have wired up our RFID RC522 circuit to the Raspberry Pi we can now power it on and begin the process of programming simple scripts in Python to interact with the chip.\n现在我们已经将RFID RC522电路连接到Raspberry Pi。我们可以启动它，开始编写简单的Python脚本以与芯片进行交互。\n\nThe scripts that we will be showing you how to write will show you how to read data from the RFID chips and how to write to them. These will give you the basic idea of how data is dealt with and will be the basis of further RFID RC522 tutorials.\n我们将向你展示如何编写脚本，以及脚本如何从RFID芯片读取和写入数据。这将为你提供处理数据的基本概念，并将成为更多RFID RC522教程的基础。\n\nBefore we start programming, we first need to update our Raspberry Pi to ensure it's running the latest version of all the software. Run the following two commands on your Raspberry Pi to update it.\n在开始编程之前，我们首先需要更新我们的Raspberry Pi，以确保其运行所有软件的最新版本。在Raspberry Pi上运行以下两个命令来更新它。\n```bash\nsudo apt update\nsudo apt upgrade\n```\n\nNow the final thing we need before we can proceed is to install the python2.7-dev package, simply run the following command on your Raspberry Pi to install it.\n现在我们需要做的最后一件事是安装python2.7-dev包，只需在Raspberry Pi上运行以下命令即可安装它。\n```bash\nsudo apt install python2.7-dev\n```\n\nTo begin, we must first clone the Python Library SPI Py and install it to our Raspberry Pi. This library helps handle interactions with the SPI and is a key component to this tutorial as we need it for the Raspberry Pi to interact with the RFID RC522.\n首先，我们必须首先克隆Python Library SPI Py并将其安装到我们的Raspberry Pi。这个库有助于处理与SPI的交互，并且是本教程的关键组件，因为我们需要Raspberry Pi与RFID RC522进行交互。\n\nRun the following two commands on your Raspberry Pi to clone the source code.\n在Raspberry Pi上运行以下两个命令来克隆源代码。\n```bash\ncd ~\ngit clone https://github.com/lthiery/SPI-Py.git\n```\n\nWith the SPI Py Python Library now cloned to our Raspberry Pi, we need to install it, this is incredibly simple, as all we need to do is change into its directory and run a simple Python command on our Raspberry Pi.\n现在将Python Py Python库克隆到我们的Raspberry Pi中，我们需要安装它，这是非常简单的，因为我们需要做的就是更改它的目录并在Raspberry Pi上运行一个简单的Python命令。\n```bahs\ncd ~/SPI-Py\nsudo python setup.py install\n```\n\nNow that we have installed SPI-Py we can now clone our RFID RC522 Python code from the PiMyLifeUp Github. There are two files included in this repository:\n现在我们已经安装了SPI-Py，现在我们可以从PiMyLifeUp的Github仓库中克隆我们的RFID RC522 Python代码。这个仓库中包含两个文件：\n\n- MFRC522.py which is an implementation of the RFID RC522 circuit.\nMFRC522.py是RFID RC522电路的一个实现。\n\n- SimpleMFRC522.py that takes the MFRC522.py file and greatly simplifies it.\nSimpleMFRC522.py采用MFRC522.py文件，并大大简化它。\n\nTo clone this repository, you can type the following two commands into your Raspberry Pi.\n为了克隆这个仓库，你可以在Raspberry Pi中输入以下两个命令。\n```bash\ncd ~\ngit clone https://github.com/pimylifeup/MFRC522-python.git\n```\n\nWith the repository now saved to our Raspberry Pi, we can begin programming for our RFID RC522. To start off with we will be showing you how to write data to your RFID cards by using the RC522. Simply go onto our next section to begin programming our first Python script.\n现在将存储库保存到我们的Raspberry Pi中，我们可以开始为我们的RFID RC522进行编程。首先，我们将向你展示如何使用RC522将数据写入RFID卡。只需进入下一节开始编程我们的第一个Python脚本。\n\n## Writing with the RFID RC522\n用RFID RC522写入\n\nFor our first Python script, we will be showing you how to write data from the RC522 to your RFID tags. Thanks to the SimpleMFRC522 script this will be relatively simple, but we will still go into how each part of the code words.\n对于我们的第一个Python脚本，我们将向你展示如何将数据通过RC522写入你的RFID卡片。借助于SimpleMFRC522脚本，这相对来说是很简单的，但我们仍然会进入每个代码片段详细解释。\n\nBegin by changing directory into our newly cloned folder, and begin writing our Write.py Python script.\n首先将目录切换到我们新克隆的文件夹，然后开始编写我们的Write.py Python脚本。\n```bash\ncd ~/MFRC522-python\nsudo nano Write.py\n```\n\nWithin this file, write the following lines of code. This code will basically ask you for text to input and then write that text to the RFID Tag.\n在这个文件中，写下面几行代码。这会要求你输入文字，然后将文字写入RFID卡片。\n```python\n#!/usr/bin/env python\n\nimport RPi.GPIO as GPIO\nimport SimpleMFRC522\n```\nThe first line of this segment of code helps tell the terminal how to interpret the file, and it lets it know that it should use Python when executing it and not something else such as Bash.\n这段代码的第一行有助于告诉终端如何解释文件，它让它知道它应该在执行时使用Python，而不是其他的东西，如Bash。\n\nOur first import, RPi.GPIO has all the functions needed to interact with the GPIO Pins, and we need this to make sure they are cleared when the script finishes running.\n我们的第一个`import`，RPi.GPIO具有与GPIO引脚交互所需的所有功能，我们需要这个来确保在脚本运行完成后它们被清除。\n\nThe second import, imports in our SimpleMFRC522 library, this is what we will use actually to talk with the RFID RC522, it greatly simplifies dealing with the chip compared to the base MFRC522 library.\n第二个`import`，导入了SimpleMFRC522库，这是我们将用来实际与RFID RC522进行通信的地方，与基本的MFRC522库相比，它极大地简化了处理芯片。\n```python\nreader = SimpleMFRC522.SimpleMFRC522()\n```\nThis line creates a copy of the SimpleMFRC522 as an object, runs its setup function then stores it all in our reader variable.\n这一行创建一个SimpleMFRC522作为对象的副本，运行它的设置功能，然后将它存储在我们的reader变量中。\n```python\ntry:\n    text = raw_input('New data:')\n    print(\"Now place your tag to write\")\n    reader.write(text)\n    print(\"Written\")\n```\nOur next block of code we keep within a try statement, this is so we can catch any exceptions and clean up properly. Make sure that you retain the 'tabs' after try: as Python is whitespace sensitive, and it is how it differs between blocks of code.\n我们的下一个代码块保存在一个try语句中，这样我们就可以捕获任何异常并正确处理。确保在输入时正确地使用`tab`或者空格缩进：因为Python对缩进敏感，并且缩进是用来区分代码块的。\n\nThe second line here reads in an input from the command line, and we use raw_input in Python 2.7 to read in all input and store it in our text variable.\n这里的第二行是从命令行读入一个输入，我们使用Python 2.7中的raw_input来读入所有的输入并将其存储在`text`变量中。\n\nWith the third line, we utilize print() to notify the user that they can now place their RFID tag down onto the reader for writing.\n通过第三行，我们利用`print()`来通知用户，他们现在可以将RFID卡片放在读卡器上进行书写。\n\nAfterward, on our fourth line of code we use our reader object to write the values we stored in the text variable to the RFID tag, this will tell the RFID RC522 Circuit to write the text values to a certain sector.\n之后，在我们的第四行代码中，我们使用`reader`对象将存储在文本变量中的值写入RFID卡片，这基本上告诉RFID RC522电路将文本值写入某个扇区。\n\nFinally, on the 5th line of code, we use print() again to notify the user that we have successfully written to the RFID tag.\n最后在第五行代码中，我们再次使用`print()`来通知用户我们已经成功写入RFID卡片。\n```python\nfinally:\n    GPIO.cleanup()\n```\nOur final two lines of code handle exiting of the script. Finally, always occurs after the try statement, meaning no matter what we run the GPIO.cleanup() function. These lines are crucial as failing to clean up can prevent other scripts from working correctly.\n我们最后的两行代码处理脚本的退出。`finally`总是在`try`语句之后出现，意思是不管发生什么错误，都运行`GPIO.cleanup()`函数。这是至关重要的，因为清理失败可能会阻止其他脚本正常工作。\n\nOnce you have finished writing in your script, it should look something like below.\n一旦你完成了你的脚本的编写，它应该看起来如下所示。\n```python\n#!/usr/bin/env python\n\nimport RPi.GPIO as GPIO\nimport SimpleMFRC522\n\nreader = SimpleMFRC522.SimpleMFRC522()\n\ntry:\n    text = raw_input('New data:')\n    print(\"Now place your tag to write\")\n    reader.write(text)\n    print(\"Written\")\nfinally:\n    GPIO.cleanup()\n```\nOnce you are happy that the code looks correct, you can save the file by pressing <kbd>Ctrl</kbd>+<kbd>X</kbd> then pressing <kbd>Y</kbd> and then finally hitting Enter.\n一旦你感到代码看起来是正确的，你可以通过按下<kbd>Ctrl</kbd>+<kbd>X</kbd>然后按下<kbd>Y</kbd>，然后最后按回车来保存文件。\n\nNow that we have written our script, we will want to test it out. Before testing out the script make sure that you have an RFID tag handy. Once ready, type the following command into your Raspberry Pi's terminal.\n现在我们已经写好了脚本，是时候来测试一下了。在测试脚本之前，确保你有一个可用的RFID卡片。准备好之后，在Raspberry Pi的终端中输入以下命令。\n```bash\nsudo python Write.py\n```\n\nYou will be asked to write in the new data, in our case we are going to just type in pimylifeup as its short and simple. Press Enter when you are happy with what you have written.\n你将被要求写入新的数据，在我们的例子中，我们只是简单地输入pimylifeup。当你对自己写的东西满意的时候，按下回车键。\n\nWith that done, simply place your RFID Tag on top of your RFID RC522 circuit. As soon as it detects it, it will immediately write the new data to the tag. You should see \"Written\" appear in your command line if it was successful.\n完成后，将RFID卡片放在RFID RC522电路的读卡区域上。一旦检测到，它会立即将新数据写入卡片。如果成功，你应该看到『Written』出现在你的命令行中。\n\nYou can look at our example output below to see what a successful run looks like.\n你可以查看下面的示例输出以查看成功运行的样子。\n```bash\npi@raspberrypi:~/MFRC522-python $ sudo python Write.py\nNew data:pimylifeup\nNow place your tag to write\nWritten\n```\nYou have now successfully written your Write.py script, and we can now proceed to show you how to read data from the RFID RC522 in the next segment of this tutorial.\n现在，你已经成功编写了你的Write.py脚本，现在我们可以继续向你展示如何在本教程的下一部分中从RFID RC522读取数据。\n\n## Reading with the RFID RC522\n用RFID RC522读取\n\nNow that we have written our script to write to RFID tags using our RC522 we can now write a script that will read this data back off the tag.\n现在我们已经写了我们的脚本来使用我们的RC522来写入RFID卡片，现在我们可以编写一个脚本来读取这个数据。\n\nLet's start off by changing the directory to make sure we are in the right place, and then we can run nano to begin writing our Read.py script.\n首先，通过更改目录来确保我们位于正确的位置，然后运行nano开始编写Read.py脚本。\n```bash\ncd ~/MFRC522-python\nsudo nano Read.py\n```\n\nWithin this file, write the following lines of code. This script will basically sit and wait till you put your RFID tag on the RFID RC522 reader, it will then output the data it reads off the tag.\n在这个文件中，写下面几行代码。这个脚本会一直等待，直到你将你的RFID卡片放在RFID RC522读卡器上，它将输出卡片上读取的数据。\n```python\n#!/usr/bin/env python\n\nimport RPi.GPIO as GPIO\nimport SimpleMFRC522\n```\nThe first line of code tells the operating system how to handle the file when a user executes it. Otherwise, it will try and just run it as a regular script file and not a Python file.\n当用户执行它时，第一行代码告诉操作系统如何处理文件。否则，它会尝试运行它作为一个普通的脚本文件，而不是一个Python文件。\n\nThe first import is, RPi.GPIO. This library contains all the functions to deal with the Raspberry Pi's GPIO pins, and we mainly import this to ensure that we clean up when the script finishes executing.\n第一个导入是RPi.GPIO。这个库包含了所有处理Raspberry Pi的GPIO引脚的函数，我们导入这个主要是来确保在脚本执行完成后进行清理。\n\nThe second import is, SimpleMFRC522. This script contains a few helper functions to make it an awful lot easier to deal with writing and reading from the RFID RC522, without it the scripts would become quite long.\n第二个导入是SimpleMFRC522。这个脚本包含一些帮助功能，使得从RFID RC522的写入和读取处理变得非常容易，没有它，我们简单的脚本将变得相当长。\n```python\nreader = SimpleMFRC522.SimpleMFRC522()\n```\nThis line is quite important as it calls SimpleMFRC522's creation function and then stores that into our reader variable as an object so we can interact with it later.\n这一行非常重要，因为它调用SimpleMFRC522的创建函数，然后将其作为对象存储到我们的reader变量中，以便稍后与之交互。\n```python\ntry:\n    id, text = reader.read()\n    print(id)\n    print(text)\n```\nThis next block of code is contained within a try statement, and we use this so we can catch any exceptions that might occur and deal with them nicely. You need to ensure that you use the ‘tabs‘ as shown after try: as Python is whitespace sensitive.\n下一个代码块包含在一个try语句中，我们使用它来捕获可能发生的异常，并很好地处理它们。你需要确保在try之后使用`tab`或者空格缩进，因为Python对缩进敏感。\n\nThe second line in this block of code makes a call to our reader object, in this case, it tells the circuit to begin reading any RFID tag that is placed on top of the RC522 reader.\n这段代码中的第二行调用我们的读卡器对象，在这种情况下，它告诉电路开始读取放置在RC522读卡器顶部的任何RFID卡片。\n\nWith the third and fourth lines we utilize print() to print out the information that we received from reading the RFID Chip, this includes the ID associated with the RFID tag and the text that is stored on the tag.\n通过第三行和第四行，我们利用`print()`打印出读取RFID芯片时收到的信息，其中包括与RFID卡片关联的ID和存储在卡片上的文本。\n```python\nfinally:\n    GPIO.cleanup()\n```\nThe two last lines of code handle the termination of the script. The finally statement always triggers after the try statement even if we get an exception.\n最后两行代码处理脚本的终止。`finally`语句总是在`try`语句之后触发，即使我们得到一个异常。\n\nThis try statement ensures that no matter what we run the GPIO.cleanup() function. It is quite crucial as failing to clean up the GPIO can prevent other scripts from working correctly.\n这个`try`语句可以确保不管发生什么，都会运行`GPIO.cleanup()`函数。这非常重要，因为如果未能清除GPIO，其他脚本将无法正常工作。\n\nNow that you have finished writing your Read.py script for your RFID RC522 it should look something like what is shown below.\n现在你已经完成了为你的RFID RC522编写Read.py脚本，它应该看起来如下所示：\n```python\n#!/usr/bin/env python\n\nimport RPi.GPIO as GPIO\nimport SimpleMFRC522\n\nreader = SimpleMFRC522.SimpleMFRC522()\n\ntry:\n    id, text = reader.read()\n    print(id)\n    print(text)\nfinally:\n    GPIO.cleanup()\n```\nOnce you are sure you have entered the code correctly, you can save the file by pressing <kbd>Ctrl</kbd>+<kbd>X</kbd> then pressing <kbd>Y</kbd> and then finally hitting Enter.\n一旦你确定你已经输入了正确的代码，你可以通过按<kbd>Ctrl</kbd>+<kbd>X</kbd>然后按<kbd>Y</kbd>，然后最后按回车来保存文件。\n\nNow that we have finally finished our Read.py script we need to test it out. Before we test out the script, grab one of the RFID tags that you want to read. Once that you are ready, type the following command into your Raspberry Pi's terminal.\n现在我们已经完成了我们的Read.py脚本，我们需要测试它。在我们测试脚本之前，准备一个你想读的RFID卡片。一旦你准备好了，在Raspberry Pi的终端中输入以下命令。\n```bash\nsudo python Read.py\n```\n\nWith the script now running, all you need to do is place your RFID Tag on top of your RFID RC522 circuit. As soon as the Python script detects the RFID tag being placed on top, it will immediately read the data and print it back out to you.\n现在脚本正在运行，你只需将你的RFID卡片放在RFID RC522电路的顶部。一旦Python脚本检测到RFID卡片被放置在顶部，它将立即读取数据并将其打印回给你。\n\nAn example of what a successful output would look like is displayed below.\n下面显示了一个成功输出的例子。\n```bash\npi@raspberrypi:~/MFRC522-python $ sudo python Read.py\n7843705425\npimylifeup\n```\n\nIf you successfully receive data back from your Read.py script with the text that you pushed to the card using your Write.py script then you have successfully set up your Raspberry Pi to connect with your RFID RC522 Circuit.\n如果你成功从你的Read.py脚本接收到数据，并使用你的Write.py脚本将文本推送到卡上，那么你已经成功设置了Raspberry Pi来连接RFID RC522电路。\n\n## 后记\n\nWe will be going into more depth with these scripts and the RFID chip in later tutorials. It will include exploring how to set up an attendance system among other cool DIY Pi projects.\n在稍后的教程中，我们将会深入探讨这些脚本和RFID芯片。这包括探索如何在其他酷派DIY Pi项目中设置考勤系统。\n\nIf you have enjoyed this Raspberry RFID RC522 tutorial or have any feedback, then feel free to drop a comment over at our forum.\n如果你喜欢这款Raspberry RFID RC522教程，或有任何反馈，请随时在下面留言！\n\n---\n\n本文翻译自：[How to setup a Raspberry Pi RFID RC522 Chip](https://pimylifeup.com/raspberry-pi-rfid-rc522)\n","tags":["Linux","Python"],"categories":["程序设计"]},{"title":"如何进行曲线拟合","url":"/2019-01/如何进行曲线拟合/","content":"\n考完了计算物理（Numerical Analysis），用一张图表达一下心情。感觉像是考了一次高等代数，加一点点统计学。\n本来计划寒假里把所有作业的代码整理并开源，结果最近自己审视了一下，愈发感觉代码写得惨不忍睹，就不献丑了。\n\n![](/images/2019-01/curve_fitting.png)\n\n图片来源：[Curve-Fitting](https://www.xkcd.com/2048)\n","categories":["幽默"]},{"title":"什么是CAT等级？","url":"/2019-01/什么是CAT等级？/","content":"\n根据国际电子电工委员会IEC1010-1的定义，我们把电工工作的区域分为四个等级，分别称作CAT I，CAT II，CAT III和CAT IV。CAT等级是向下兼容的，也就是说，一块CAT IV的表用在CAT I，CAT II，CAT III下使用是完全安全的，但是一块CAT I的万用表用在CAT II，CAT III和CAT IV环境下使用就不保证安全了。\n\n## CAT等级对用户意味着什么\n\nCAT等级意味着对客户的人身安全承诺，它不仅仅是耐高压！CAT等级严格规定了电气工作人员在不同级别的电气环境中可能遇到的电气设备的类型以及在这样的区域中工作所使用的测量工具必须要遵循的安全标准。CAT后面的电压数值则表示了他们能够收到电压冲击的上限。\n例如，一个CAT III 600V的万用表，表示该表可以在CAT I，II和III区域安全使用，在这三个区域里如果该表收到最高600V的电压冲击，表不会对人体安全产生威胁，但是这款表在CAT IV域使用时，或者到700V的高压冲击的时候，就不能保证同样的安全了。CAT等级是向下兼容的，也就是说，一块CAT IV的表用在CAT I，CAT II，CAT III下使用是完全安全的，但是一块CAT I的万用表用在CAT II，CAT III和CAT IV环境下使用就不保证安全了，表可能发生爆炸、燃烧威胁到你的安全。\n\n## CAT等级划分\n\n- CAT I：通过变压器或者类似设备连接到墙上插座的二次电气线路，例如电子仪器设备类。有保护措施的电子设备、任何高压、低压回路，如办公室内部的复印机等。\n- CAT II：通过电源线连接到室内插座的用电设备的一次电气线路，如移动式工具，家电等。家用电器、便携工具（电钻等）、家用插座，距离三类线路10米以上的插座或者距离四类线路20米以上的插座。\n- CAT III：直接连接到配电盘的大型设备的一次线路及配电盘与插座之间的电路线路（三相分配电路包括单个商业照明电路）。位置固定的设备，如多相马达、多相闸盒；大型建设物内部的照明设备、线路；工业现场（车间）的机床、电源配电盘等。\n- CAT IV：三相公用供电设备和室外供电线路设备。涉及到『初始连接』的设备，如电站的电力分配系统；电力仪表，前端过置保护，任何室外输电线路。\n\n![](/images/2019-01/2ccd70dcb7a54444c2cfeb2fc78c23a3.png)\n\n## 如何理解CAT等级\n\nCAT等级有各自的工作电压和瞬时峰值电压。CAT等级的工作电压分为：50V，150V，300V，600V，1000V。工作电压越高意味着能够承受的瞬时峰值电压也越高。\n如下表所示：\n\n等级 | 瞬时峰值\n- | -\nCAT IV 600V | 8kV impulse\nCAT III 600V | 6kV impulse\nCAT III 1000V | 8kV impulse\nCAT II 600V | 4kV impluse\nCAT II 1000V | 6kV impulse\n\n下图有更详细的数据：\n\n![](/images/2019-01/5e0693d4c540a6d44ba986dc647409cd.png)\n\n## CAT III 600V比CAT II 1000V更安全\n\n人们往往无法理解这一点，为什么只能承受600V电压的设备的比1000V更安全？\n这里涉及到信号源阻抗的问题。信号源阻抗越大，CAT等级越低。由表1可知，CAT III等级的阻抗为2欧姆，CAT II等级的阻抗时12欧姆，即CAT II等级的源阻抗是CAT III等级阻抗的6倍。所以，虽然CAT III等级的电压虽小，但阻抗也小，电流大，从而能够承受更高能量的信号，所以说CAT III 600V比CAT II 1000V安全。\n同一个CAT等级下，工作电压越高，其安全等级也越高（同一CAT等级的源阻抗相同）。例如：CAT III 1000V（8kV 瞬时高发）比CAT II 600V（6kV瞬时高压）更安全。\n如果您需要测试一个电力电路，你应该会用到一个CAT III 600V或CAT IV 600V/CAT III 1000V的仪表，配套CAT IV-600V/CAT III-1000V测试线和探头。\n\n## 常见问题\n\n问：PicoScope的CAT I等级的高压探头TA044为什么配套 CAT III 1000V等级的探头尖端？是不是厂家弄错了。\n答：不是。Pico所有的高压差分探头配套的都是CAT III等级的探头尖端。如下图所示。TA044整体上是一个在CAT I 环境中能够安全使用的设备，能够测量的最大单端电压7kV。探头尖端采用的是工作电压1000V的CAT III等级，该等级下能够承受的瞬时最大尖峰电压是8kV，所以CAT III等级的探头尖端 用起来更加安全。\n\n![](/images/2019-01/4fbf3af969c5f5b73093dbfd1600be96.png)\n\n---\n\n本文转载自：[CAT 等级](http://www.eepw.com.cn/article/274406.htm)\n","categories":["技术"]},{"title":"成功召唤独角兽","url":"/2019-01/成功召唤独角兽/","content":"\n![](/images/2019-01/Unicorn.png)\n\n> 当你的代码出现未定义行为时，你会得到一个`segmentation fault`和一堆损坏的数据。当Jeff Dean的代码出现未定义行为时，一个独角兽会踏着彩虹从天而降并给每个人提供免费的冰激凌。\n","tags":["GitHub"],"categories":["幽默"]},{"title":"炉石卡组代码解析","url":"/2018-12/炉石卡组代码解析/","content":"\n在前面的文章[Base64编码的原理与实现](/2018-12/Base64编码的原理与实现/)中，讲到了Base64编码的诸多用处，例如编码图片以嵌入HTML代码。如果你对此有所了解，同时还是一个炉石玩家，就不难发现，暴雪推出的卡组代码功能，本质上就是用一个Base64编码的字符串来存储卡组信息。毕竟，你有时会见到以`=`或者`==`结尾的卡组代码，这正是Base64编码的典型特征。\n\n## 注释\n\n当把卡组代码粘贴到炉石传说时，客户端将忽略以`#`字符开头的任何行，这就提供了在卡组代码中插入注释的可能性。一个例外是在卡组代码最前面的，以`###`开头的第一行。如果可以的话，它将被用作套牌名称。你可以从炉石中复制一套卡组到文本编辑器看看效果。\n没有被注释的那一行，包含了除套牌名称外的所有信息。玩家在各大论坛、社区分享卡组时，也往往只需要这一行卡组代码。\n\n## DBF ID\n\n为了了解编码的机制，我们需要先介绍DBF ID。这是每张炉石卡牌（包括可收集卡牌、衍生卡牌、冒险模式专属卡牌、英雄皮肤等）的唯一标识符——是的，这也是能够卡出下图这种BUG的原因。皮肤被标记为了一张紫卡。\n\n![](/images/2018-12/tyrande.png)\n\n而炉石卡组代码正是使用DBF ID来表示每张卡牌。DBF ID可在游戏文件中找到。更加方便的方法是通过[HearthstoneJSON](https://hearthstonejson.com)，这上面提供了相关API。你也可以在[这个网站上](https://hearthstonejson.com/docs/cards.html)直接下载最新的`cards.collectible.json`，这里面包含了所有可收集卡牌的信息，例如各种语言的卡牌名称、描述等。\n\n## 格式\n\n**除非另有说明，否则后面的每个值都是一个整数，编码为无符号的[varint](https://en.wikipedia.org/wiki/Variable-length_quantity)。**\n如前所述，卡组代码是Base64编码的字节串。我们先来解码它。许多编程语言都可以做到这一点，以最好的语言$PHP为例：\n```php\n$deckstring = \"AAEBAf0GAA/OBpcHzAjiDP8PyBTmFrasAq6wAqW+Avi/Avm/AqLNAvjQAqbvAgA=\";\n#这是一个非常有趣的萨满卡组\n$binary = base64_decode($deckstring);\n$hex = bin2hex($binary);\n#对于这个卡组，$hex=\"00010101fd06000fce069707cc08e20cff0fc814e616b6ac02aeb002a5be02f8bf02f9bf02a2cd02f8d002a6ef0200\"\n```\n这样就能得到初步解码后的十六进制字符串。如果你不是很擅长编程，也可以搜索一些现成的Base64解码工具，看看它是如何工作的。\n将这个十六进制字符串按每两个元素切割，再把它们从16进制字符串转化为整型。也就是说，它们可以是00-ff，即0-255。一种实现的方法是这样：\n```php\n$arr = str_split($hex, 2);\n$arr = array_map(\"hexdec\", $arr);\n```\n`$arr`是一个由整数组成的数组。更具体的来说，就是varint。我们还需要进一步的解码，才能读取出有用的信息：\n```php\nfunction read_varint(&$data) {\n    $shift = 0;\n    $result = 0;\n    do {\n        $c = array_shift($data);\n        $result |= ($c & 0x7f) << $shift;\n        $shift += 7;\n    }\n    while ($c & 0x80);\n    return $result;\n}\n```\n这里的`array_shift`会将数组的第一个元素移出数组，并返回它的值。在其它的编程语言中，类似的方法可能被叫做`lpop`，`pop`，`shift`等等。而`|`，`&`，`<<`等都是位运算的运算符。`read_varint`函数完成了解码过程，如果有兴趣的话可以试试用C或Python实现它。\n不断地执行`read_varint($arr)`，直到取完`$arr`中的元素，就能把内容全部解码出来。\n\n根据作用，我们可以把解码后的卡组代码分为两个部分：元数据块和卡牌块。\n\n<!-- more -->\n### 元数据块\n\n在`$arr`中，前五个元素分别为：\n\n- 保留字节0x00\n- 版本号（固定为1）\n- 模式（1为狂野，2为标准）\n- 使用英雄卡牌的数量（固定为1）\n- 使用的英雄卡牌的类型（长度不确定，一般是1-3位）\n\n可见卡组代码以字节0x00开头。然后是编码版本号，目前始终为1。虽然这五个元素并没有官方名称，不过从作用上可以看作元数据。\n还有一点是，所谓『英雄卡牌的类型』就是你所使用的英雄皮肤。这个参数必不可少。英雄的职业决定了套牌所用的职业，但是套牌表面上是为英雄制作的，而不是为一个职业。如果卡组代码指定的英雄是皮肤而不是默认的英雄，那么在你复制卡组时，系统就会选择使用皮肤而不是默认英雄（前提是你买了这个皮肤）。\n**关于英雄的注意事项：**尽管它是一个数组，但它是用于*初始英雄*，而不是*可打出的英雄牌*（如冰封王座的DK）。\n\n### 卡牌块\n\n在元数据块之后，继续读取`$arr`的元素，那么接下来就轮到卡牌块了。它按以下顺序分为三对长度+数组的组合：\n\n- 卡组中存在一张的卡\n- 卡组中存在两张的卡\n- 卡组中存在n张的卡\n\n**每对都有一个前导varint，指定数组中的项目数。**这种结构的目标是使卡组代码尽可能紧凑。**如前所述，每张卡都用varint型的DBF ID表示。**\n\n所谓『卡组中存在n张的卡』，指的是卡组中的所有其他卡牌。此数组是一个varint对组成的列表，每一对的第一个元素表示DBF ID，第二个元素是该卡牌在卡组中出现的次数。它**应该**只包含在牌组中至少出现三次的牌，因而意味着它（在这种情况下）对于构筑卡组应当是空的（毕竟一张卡至多只能带两张）；但理论上它也可以包含有一张的卡和有两张的卡。\n\n尽管最终排序无关紧要，但卡牌仍会在各自所在的数组中，按DBF ID的升序进行排序，以便始终为相同的卡组生成相同的卡组代码。我们称所有按照这种方式排列卡牌列表（包括英雄）的卡组代码为规范的卡组代码。下面的参考实现应该已经可以生成规范的卡组代码。\n\n## 一种实现\n\n看代码可能比文字描述更加直观。下面的`parse_deck()`函数就会按照前面介绍的方法，依次读取元数据块和卡牌块的信息。\n```php\nfunction parse_deck($data) {\n    $reserve = read_varint($data);\n    if ($reserve != 0) {\n        printf(\"Invalid deckstring\");\n        die;\n    }\n    $version = read_varint($data);\n    if ($version != 1) {\n        printf(\"Unsupported deckstring version %s\", $version);\n        die;\n    }\n    $format = read_varint($data);\n    $heroes = [];\n    $num_heroes = read_varint($data);\n    for ($i = 0; $i < $num_heroes; $i++) {\n        $heroes[] = read_varint($data);\n    }\n    $cards = [];\n    $num_cards_x1 = read_varint($data);\n    for ($i = 0; $i < $num_cards_x1; $i++) {\n        $card_id = read_varint($data);\n        $cards[] = [$card_id, 1];\n    }\n    $num_cards_x2 = read_varint($data);\n    for ($i = 0; $i < $num_cards_x2; $i++) {\n        $card_id = read_varint($data);\n        $cards[] = [$card_id, 2];\n    }\n    $num_cards_xn = read_varint($data);\n    for ($i = 0; $i < $num_cards_xn; $i++) {\n        $card_id = read_varint($data);\n        $count = read_varint($data);\n        $cards[] = [$card_id, $count];\n    }\n    return [$cards, $heroes, $format];\n}\nparse_deck($arr);\n```\n这时，再通过建立DBF ID与卡牌对应关系的数据库，就能够实现在游戏外导入、导出和编辑卡组的功能了。不论是官方的[卡牌工具](https://hs.blizzard.cn/cards)，还是第三方平台（如旅法师营地）的[套牌编辑](https://www.iyingdi.com/web/tools/hearthstone/decks)功能，原理都是相似的。\n所有代码已开源：[hearthstone-deck](https://github.com/stevenjoezhang/hearthstone-deck)，这是本文中所使用的PHP版本。博主后来又用Node.js重写了这个应用，方便在Heroku上部署：[hsdeck](https://github.com/stevenjoezhang/hsdeck)。\n其他语言的实现方式可以在[HearthSim](https://github.com/HearthSim)的官方GitHub账户下找到。\n\n---\n\n博主搭建的API：[炉石传说卡组](https://hsdeck.herokuapp.com)\n\n拓展阅读：\n[在网页上展示你的炉石卡组吧](https://2heng.xin/2018/12/12/embed-hearthstone-deck-with-iframe)\n[炉石传说卡组代码生成机制](https://www.darkerror.com/2018/05/hearth-stone-deck-string-decoding)\n[Hearthstone Deckstrings](https://hearthsim.info/docs/deckstrings)\n","tags":["PHP"],"categories":["电子游戏"]},{"title":"Command Line Russian Roulette","url":"/2018-12/Command Line Russian Roulette/","content":"\n![](/images/2018-12/Strip-Roulette-russe-650-finalenglish.jpg)\n\n图片来源：[Russian roulette](http://www.commitstrip.com/en/2014/05/16/russian-roulette)\n","categories":["幽默"]},{"title":"Base64编码的原理与实现","url":"/2018-12/Base64编码的原理与实现/","content":"\n在数据传输的时候，并不是所有的字符都可以受到支持，很多时候只能传输可见字符，对于不可见字符的传输需要经过特殊处理，这就是Base64产生的原因。Base64编码是一种基于64个可打印字符来表示二进制数据的表示方法。由于$2^6=64$，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。\nBase64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。用Base64编码图片也是互联网上常见的做法。\n\nBase64的字符索引如下表所示：\n\n数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符\n- | - | - | - | - | - | - | -\n0 | A | 16 | Q | 32 | g | 48 | w\n1 | B | 17 | R | 33 | h | 49 | x\n2 | C | 18 | S | 34 | i | 50 | y\n3 | D | 19 | T | 35 | j | 51 | z\n4 | E | 20 | U | 36 | k | 52 | 0\n5 | F | 21 | V | 37 | l | 53 | 1\n6 | G | 22 | W | 38 | m | 54 | 2\n7 | H | 23 | X | 39 | n | 55 | 3\n8 | I | 24 | Y | 40 | o | 56 | 4\n9 | J | 25 | Z | 41 | p | 57 | 5\n10 | K | 26 | a | 42 | q | 58 | 6\n11 | L | 27 | b | 43 | r | 59 | 7\n12 | M | 28 | c | 44 | s | 60 | 8\n13 | N | 29 | d | 45 | t | 61 | 9\n14 | O | 30 | e | 46 | u | 62 | +\n15 | P | 31 | f | 47 | v | 63 | /\n\n这是一个根据上表进行编码的例子：\n\n![](/images/2018-12/1.png)\n\n如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。也就是说，当最后剩余两个八位字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位字节（1个byte）时，最后一个6位的Base字节块有两位是0值，最后附加一个等号。可以参考下面的例子：\n\n![](/images/2018-12/2.png)\n\n<!-- more -->\n这是一个用Python实现Base64编码的脚本：\n```python\n#!/usr/bin/env python3\n\ndef myBase64Encode(preCoding):\n    charTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' #字符表\n \n    if len(preCoding) < 0:\n        return ''  #字符串为空则返回空\n    lackCharNums = 3 - len(preCoding) % 3\n    if lackCharNums == 3 : lackCharNums = 0 #整除说明不缺字符\n    #待转换字符不是3的倍数的情况补全它\n    for i in range(lackCharNums) :\n        preCoding = preCoding + b'\\x00'\n    result = '' #用于保存最终结果的str数据\n    rp = '' #处理补全字符时的暂存变量\n    #每三个字符处理一轮\n    for i in range(int(len(preCoding) / 3)):\n        threeChar = preCoding[i * 3 : i * 3 + 3] #取三个字符出来\n        tCode = '' #用于存放三个字符拼接后的二进制数值 文本形式\n        pCode = '' #暂存变量\n        for j in range(3) :\n            pCode = bin(threeChar[j])[2 :]  #把省略的0补上\n            lackZeroNums = 8 - len(pCode) #省略的0的个数\n            for x in range(lackZeroNums):\n                pCode = '0' + pCode\n            tCode = tCode + pCode\n        pCode = ''\n        for j in range(4): #每6位一个字符\n            pCode = tCode[j * 6 : j * 6 + 6]\n            rp = rp + charTable[int(pCode, 2)]\n        #处理补全的00字符\n        result = rp[: len(rp) - lackCharNums]\n        for j in range(lackCharNums):\n            result = result + '='\n    return bytes(result, encoding = \"utf-8\")\n \ndef myBase64Decode(encodedBin) :\n    charTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' #字符表\n \n    #如果字符不是4的倍数 返回空\n    if not len(encodedBin) % 4 == 0 :\n        return ''\n \n    tCode = '' #用于存放最终的二进制文本字符串\n    pCpde = '' #暂存变量\n    #遍历encodedBin每一个字符\n    for i in encodedBin:\n        for j in range(len(charTable)): #找到表中对应坐标\n            if chr(i) == charTable[j]:\n                pCode = bin(j)[2 :]  #转二进制去除开头的0b\n                lackZeroNums = 6 - len(pCode) #省略的0的个数\n                for x in range(lackZeroNums):\n                    pCode = '0' + pCode\n                tCode = tCode + pCode\n    pCode = ''\n    result = '' #储存最终结果\n    for i in range(int(len(tCode) / 8)):\n        pCode = tCode[i * 8 : i * 8 + 8]\n        result = result + chr(int(pCode, 2))\n    return bytes(result, encoding = \"utf-8\")\n\nprint(myBase64Encode(b\"helloworld\"))\nprint(myBase64Decode(b\"aGVsbG93b3JsZA==\"))\n```\n浏览器中可以直接调用相关的API：\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\"/>\n<title>文件base64——直接拖进来</title>\n</head>\n<style>\nbody {\n    word-break: break-all;\n}\n</style>\n<body>\n<script>\nwindow.addEventListener(\"dragenter\", function(event) {\n    event.preventDefault();\n}, false);\nwindow.addEventListener(\"dragover\", function(event) {\n    event.preventDefault();\n}, false);\nwindow.addEventListener(\"drop\", function(event) {\n    var reader = new FileReader();\n    reader.onload = function(e) {\n        document.body.insertAdjacentHTML(\"afterBegin\", '<p>' + e.target.result + '</p>'); \n        //base64 encoded file data!\n    };\n    reader.readAsDataURL(event.dataTransfer.files[0]);\n    event.preventDefault();\n}, false);\n</script>\n</body>\n</html>\n```\n这是加载Base64编码的图片的方法。这可以将图片硬编码到网页中。\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\"/>\n<title>Base64 Encode编码实现1x1px透明(黑白)图片</title>\n<style>\nbody {\n    text-align: center;\n}\n</style>\n</head>\n<body>\n<h1>以下是透明图片</h1>\n<img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" width=\"500\" height=\"100\" />\n<h1>以下是黑色图片</h1>\n<img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\" width=\"500\" height=\"100\" />\n</body>\n</html>\n```\n\n---\n\n拓展阅读：\n[Base64 - 维基百科](https://zh.wikipedia.org/wiki/Base64)\n[Base64编码原理及脚本的简单实现](https://www.52pojie.cn/thread-831202-1-1.html)\n","tags":["HTML","Python"],"categories":["技术"]},{"title":"十二月天象","url":"/2018-12/十二月天象/","content":"\n即将到来的12月天宇将先后上演『金星最亮』『双子座流星雨极大』『水星西大距』和『小熊座流星雨极大』等多部天象大片，天文爱好者们千万不要错过。\n\n## 火星合海王星\n\n2018年12月7日入夜后西南方天空将可观赏到火星合海王星的天象，火星将至海王星北面0.04度（相当于2角分）的近距离通过，位于宝瓶座。火星视亮度+0.1等，海王星+7.9等，需用小型望远镜观测。\n\n![](/images/2018-12/mars.png)\n\n## 双子座流星雨极大期\n\n每到岁末，双子座流星雨（Geminids，00004 GEM）都会如期而至。作为北半球三大流星雨之一，它的流量非常稳定，并且全球绝大多数地区的公众都有机会观测到它。今年双子座流星雨的观测条件不错，预报的极大值出现在12月14日晚20时30分，天顶每时出现率ZHR为120。\n\n辐射点在12月14日入夜后自东北偏东方升起，即入夜后就有机会见到双子座流星出现。今年月相接近上弦，但对观测影响不大，尤其是后半夜观测条件很好，但要注意防寒保暖。\n\n![](/images/2018-12/Comet_holmes_and_Geminid121307.jpg)\n\n## 水星西大距\n\n12月15日，今年最后一次水星西大距将上演。如果大气透明度足够高，在此后几天的日出前，用肉眼或借助双筒望远镜均可在黎明前的东方低空寻觅到水星的神秘身影。\n\n![](/images/2018-12/mercury.png)\n\n水星的视运动是这样的：东大距 → 半轮 → 近日点 → 留 → 下合 → 极长视直径 → 留 → 降交点 → 半轮 → 西大距 → 远日点 → 极短视直径 → 上合 → 升交点 → 东大距，周期是116日（水星的会合周期），而水星东大距 → 西大距平均间隔为41天。这次水星西大距，日出时位于东南方天空，与太阳的最大角距为21度，亮度约-0.5等，是今年观测水星的第四次最佳时机。\n\n## 小熊座流星雨\n\n小熊座流星雨（Ursids，00015 URS）往往是全年精彩天象的收官之作，该流星雨的活动期为12月17日至12月26日。天文预报显示，今年该流星雨极大可能出现在12月22日4时53分。\n\n![](/images/2018-12/Murahashi1.jpg)\n\n小熊座流星雨在1949年和1986年曾出现过两次爆发，但今年没有爆发的预期，届时每小时最大天顶流量为10颗左右，而且极大正好赶上满月，观测条件不是太好。\n\n---\n\n> 部分图片来自维基百科，采用CC BY-SA 3.0许可证，作者为Brocken Inaglory以及Brian Murahashi和Jim Albers。部分图片来自Stellarium，该软件为开源软件，采用GPL3.0协议。\n\n拓展阅读：[Can You Spot December’s Ursid Meteors?](https://www.skyandtelescope.com/astronomy-news/spot-decembers-ursid-meteors)\n","tags":["天文"],"categories":["物理"]},{"title":"Safari顶栏彩虹效果","url":"/2018-11/Safari顶栏彩虹效果/","content":"\n从OS X Yosemite系统开始，Safari浏览器的顶部工具栏加入了类似iOS中的半透明毛玻璃效果。Safari会自动根据页面的颜色来显示工具栏的毛玻璃特效颜色，而通过CSS中的`body:before`类，我们可以对其进行定制。具体代码如下：\n```css\n@media screen and (-webkit-min-device-pixel-ratio: 0) {\n    body:before {\n        right: 0;\n        top: 0;\n        left: 0;\n        height: 100px;\n        z-index: 2147483647;\n        position: fixed;\n        content: \"\";\n        display: block;\n        -webkit-transform: translateY(-99.99px);\n        background: linear-gradient(124deg,\n        #FF0000,\n        #FF7F00,\n        #FFFF00,\n        #7FFF00,\n        #00FF00,\n        #00FF7F,\n        #00FFFF,\n        #007FFF,\n        #0000FF,\n        #7F00FF,\n        #FF00FF,\n        #FF007F,\n        #FF0000);\n        animation: rainbow 15s ease infinite;\n        background-size: 1000% 1000%;\n    }\n}\n@keyframes rainbow {\n    0% {\n        background-position: 0% 80%;\n    }\n    50% {\n        background-position: 100% 20%;\n    }\n    100% {\n        background-position: 0% 80%;\n    }\n}\n```\n将它们添加到页面中的`<style>`标签内，并在`<body>`中加入适当的内容。当使用Safari浏览器打开时，**略微向下滚动页面**，便可以看到顶部栏出现炫酷的彩虹效果。快去试试吧！\n**注意：一些老旧浏览器不能正确识别`transform`，会导致彩色条挡住`<body>`，`-webkit-min-device-pixel-ratio`可以防止这一问题。**\nGitHub项目地址：[rainbowsafari](https://github.com/koole/rainbowsafari)\n","tags":["Mac","CSS"],"categories":["Web开发"]},{"title":"国际单位制基本单位的重新定义","url":"/2018-11/国际单位制基本单位的重新定义/","content":"\n## 前言\n\n国际单位制以一组基本单位为基础，所有其他单位都是用基本单位建立起来的。麦克斯韦最初提出一致单位制的概念时，列出了三个可用的基本单位：质量、长度及时间单位。之后，吉奥尔吉提倡加入电的基本单位。理论上，电流、电势、电阻、电荷等物理量的单位都可以做基本单位，当选定其中一个做基本单位后，其余的电单位都可以通过物理定律从基本单位推导得出；国际单位制最终选择了使用电流。后期又加入了三个分别量度物质的量、温度及发光强度的基本单位。\n国际单位制希望其单位定义的基准是源自于对自然的测量。但此单位制于1799在法国被引入时，由当时技术上的限制，因此利用了米原器与千克原器做为米与千克的定义。\n1960年，米的定义被改写为由特定光源所发出的光波长（后又改为根据真空光速定义），因此米定义的基准也成为了对自然测量的结果。现今，只留下了千克还是以人造的物品做为定义的基准。\n**2018年11月16日，第26届国际计量大会一致通过了新国际单位制基本单位定义的提案。新的定义将于2019年5月20日生效。**\n国际度量衡局提案，除了光速以外，下列所示的四个自然常数也应被定义为确定的数值：\n- 普朗克常数$h=6.62607015\\times10^{−34}(J\\cdot s)$\n- 基本电荷$e=1.602176634\\times10^{−19}(C)$\n- 玻尔兹曼常数$k=1.380649\\times10^{−23}(J\\cdot K^{−1})$\n- 阿伏伽德罗常量$N_A=6.02214076\\times10^{23}(mol^{−1})$\n\n这些常数在2006年版的SI指南就已经出现，但在此版本中后三个常数被定义为『由实验所得的常数』，而不是直接的『定义常数』。\n国际度量衡局也提案，以下这些自然常数的数值应继续保持不变。\n- 光速$c=299,792,458(m\\cdot s^{-1})$\n- 铯133原子基态超精细能级分裂频率$\\Delta\\nu(^{133}Cs)\\_{hfs}=9,192,631,770(Hz)$\n- 频率为$540\\times10^{12}Hz$辐射的发光效率$K_{cd}=683(lm\\cdot W^{-1})$\n\n这是以上七个定义改写为以基本单位表示的形式：\n- $\\Delta\\nu(^{133}Cs)\\_{hfs}=9,192,631,770(s^{−1})$\n- $c=299,792,458(m\\cdot s^{−1})$\n- $h=6.62607015\\times10^{−34}(kg\\cdot m^2\\cdot s^{−1})$\n- $e=1.602176634\\times10^{−19}(A\\cdot s)$\n- $k=1.380649\\times10^{−23}(kg\\cdot m^2\\cdot K^{−1}\\cdot s^{−2})$\n- $N_A=6.02214076\\times1023(mol^{−1})$\n- $K_{cd}=683(cd\\cdot sr\\cdot s^3\\cdot kg^{−1}\\cdot m^{−2})$\n\n此外国际度量衡局也要求：\n- 目前千克的定义应废除并使国际千克原器退休\n- 目前安培的定义应废除\n- 目前开尔文的定义应废除\n- 目前摩尔的定义应修改\n\n这些改变会影响到基本单位的定义，但对于导出单位的表达形式则不会有所影响。\n\n<!-- more -->\n## 改变历史\n\n我们可以回顾国际单位制基本单位定义的改变历史。\n\n### 米\n\n最初（1793年）：从北极至赤道经过巴黎的子午线长度的一千万分之一。（法国政府）\n过渡（1799年）：国际米原器的长度。\n过渡（1960年）：氪-86原子在$2p^{10}$和$5d^5$量子能级之间跃迁所发出的电磁波在真空中的波长的1,650,763.73倍。\n目前（1983年）：光在$\\frac{1}{299,792,458}$秒内在真空中行进的距离。\n\n### 千克\n\n最初（1793年）：最初法文名为grave，定义为在冰点下体积为一立方分米的纯水的重量（质量）。（法国政府）\n目前（1889年）：国际千克原器的质量。\n未来（2019年）：由精确的普朗克常数$h=6.62607015\\times10^{−34}(kg\\cdot m^2\\cdot s^{−1})$、米和秒所定义。\n\n### 秒\n\n最初（中世纪）：一天时长的86,400分之一。\n过渡（1956年）：1900年1月0日历书时12时算起的回归年时长的$\\frac{1}{31,556,925.9747}$。\n目前（1967年）：铯-133原子基态的两个超精细能级之间跃迁所对应的辐射周期时长的9,192,631,770倍。\n\n### 安培\n\n最初（1881年）：CGS电磁单位制中电流单位的十分之一。CGS电流单位的定义是，在半径为1厘米、长度为1厘米的圆弧上流通，并在圆心产生1奥斯特电场的电流。（国际电工委员会）\n目前（1946年）：在真空中相距1米的两根横截面为圆形、粗度可忽略不计的无限长平行直导线，各通上相等的恒定电流，当两根导线之间每米长度所受力为$2\\times10^{−7}$牛顿时，各导线上的电流定义为1安培。\n未来（2019年）：由新的元电荷$e=1.602176634\\times10^{−19}(A\\cdot s)$和秒所定义。\n\n### 开尔文\n\n最初（1743年）：摄氏温标将0°C和100°C分别定义为水的熔点和沸点。\n过渡（1954年）：273.16K定义为水的三相点（0.01°C）。\n目前（1967年）：水的三相点热力学温度的$\\frac{1}{273.16}$。\n未来（2019年）：由新的玻尔兹曼常数$k=1.380649\\times10^{−23}(kg\\cdot m^2\\cdot K^{−1}\\cdot s^{−2})$、千克、米和秒所定义。\n\n### 摩尔\n\n最初（1900年）：物质的克数等于其分子量时的数量。（国际原子量委员会）\n目前（1967年）：物质所含的粒子数量相等于0.012千克碳-12所含的原子数量。\n未来（2019年）：1摩尔包含$6.02214076×10^{23}$个基本实体，这一数字是新的阿伏伽德罗常数。\n\n### 坎德拉\n\n最初（1946年）：整个辐射体在铂凝固温度下的亮度，定义为60新坎德拉每平方厘米。\n目前（1979年）：频率为$5.4×10^{14}$赫兹的单色光源在特定方向辐射强度为$\\frac{1}{683}W/sr$时的发光强度。\n\n## 依赖关系\n\n由于定义的变化，这些单位之间的依赖关系也发生了改变。\n\n![](/images/2018-11/Unit_relations_in_the_old_SI.svg)\n![](/images/2018-11/Unit_relations_in_the_new_SI.svg)\n\n## 不确定度\n\n同样，由于定义的变化，一些物理量的不确定度也发生了改变。例如，真空磁导率$\\mu_0$将不再具有定义值$4\\pi\\times10^{-7}m\\cdot kg\\cdot s^{-2}\\cdot A^{-2}$，水的三相点温度也不再严格地等于273.16K。下表给出了它们在改动后的影响：\n\nConstant | Symbol | Relation to directly measured and fixed constants (Previous) | Significant factor(s) in uncertainty (Previous) | Relative uncertainty (Previous) | Relation to directly measured and fixed constants (2019) | Significant factor(s) in uncertainty (2019) | Relative uncertainty (2019)\n- | - | - | - | - | - | - | -\nMass of IPK | $m(\\mathcal{K})$ | 1 kg | None | Exact|$m(\\mathcal{K})$ | $m(\\mathcal{K})$ | $1.2 \\times 10^{-8} = u_\\text{r}(m(\\mathcal{K}))$\nPlanck constant | $h$ | $\\frac{8 \\alpha}{c \\mu_0 K_\\text{J}^2}$ | $K_\\text{J}^2$ | $1.2 \\times 10^{-8} \\approx 2 u_\\text{r}(K_\\text{J})$ | $6.62607015\\times10^{-34} kg\\cdot m^2\\cdot s^{−1}$ | None | Exact\nJosephson constant | $K_\\text{J}$ | $K_\\text{J}$ | $K_\\text{J}$ | $6.1 \\times 10^{-9} = u_\\text{r}(K_\\text{J})$ | $\\frac{2 e}{h}$ | None | Exact\nVon Klitzing constant | $R_\\text{K}$ | $\\frac{c \\mu_0}{2 \\alpha}$ | $\\alpha$ | $2.3 \\times 10^{-10} = u_\\text{r}(\\alpha)$ | $\\frac{h}{e^2}$ | None | Exact\nElementary charge | $e$ | $\\frac{4 \\alpha}{c \\mu_0 K_\\text{J}}$ | $K_\\text{J}$ | $6.1 \\times 10^{-9} \\approx u_\\text{r}(K_\\text{J})$ | $1.602176634\\times10^{-19} A\\cdot s$ | None | Exact\nMagnetic constant | $\\mu_0$ | $4\\pi\\times10^{-7} m\\cdot kg\\cdot s^{−2}\\cdot A^{−2} $ | None | Exact | $\\frac{2 h \\alpha}{c e^2}$ | $\\alpha$ | $2.3 \\times 10^{-10} = u_\\text{r}(\\alpha)$\nVacuum permittivity | $\\varepsilon_0$ | $\\frac{1}{c^2 \\mu_0}$ | None | Exact | $\\frac{e^2}{2 h c \\alpha}$ | $\\alpha$ | $2.3 \\times 10^{-10} = u_\\text{r}(\\alpha)$\nImpedance of free space | $Z_0$ | $c \\mu_0$ | None | Exact|$\\frac{2 h \\alpha}{e^2}$ | $\\alpha$ | $2.3 \\times 10^{-10} = u_\\text{r}(\\alpha)$\nElectron mass | $m_\\text{e}$ | $\\frac{16 R_{\\infty}}{c^2 \\alpha \\mu_0 K_\\text{J}^2}$ | $K_\\text{J}^2$ | $1.2 \\times 10^{-8} \\approx 2 u_\\text{r}(K_\\text{J})$ | $\\frac{2 h R_{\\infty}}{c \\alpha^2}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nElectron molar mass | $M(\\text{e})$ | $A_\\text{r}(\\text{e}) M_\\text{u}$ | $A_\\text{r}(\\text{e})$ | $2.9 \\times 10^{-11} = u_\\text{r}(A_\\text{r}(\\text{e}))$ | $\\frac{2 h R_{\\infty} N_\\text{A}}{c \\alpha^2}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nUnified atomic mass unit or dalton | \\begin{align\\*}m_u & = 1u \\\\\\\\ & = 1Da\\end{align\\*} | $\\frac{16 R_{\\infty}}{c^2 \\alpha \\mu_0 K_\\text{J}^2 A_\\text{r}(\\text{e})}$ | $K_\\text{J}^2$ | $1.2 \\times 10^{-8} \\approx 2 u_\\text{r}(K_\\text{J})$| $\\frac{2 h R_{\\infty}}{c \\alpha^2 A_\\text{r}(\\text{e})}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nMolar mass constant | $M_\\text{u}$ | $0.001kg\\cdot mol^{−1}$ | None | Exact| $\\frac{2 h R_{\\infty} N_\\text{A}}{c \\alpha^2 A_\\text{r}(\\text{e})}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nAvogadro constant | $N_\\text{A}$ | $\\frac{c^2 \\alpha \\mu_0 K_\\text{J}^2 A_\\text{r}(\\text{e}) M_\\text{u}}{16 R_{\\infty}}$ | $K_\\text{J}^2$ | $1.2 \\times 10^{-8} \\approx 2 u_\\text{r}(K_\\text{J})$ | $6.02214076\\times10^{23} mol^{−1}$ | None | Exact\nAtomic mass of carbon-12 | $m(^{12}\\text{C})$ | $\\frac{192 R_{\\infty}}{c^2 \\alpha \\mu_0 K_\\text{J}^2 A_\\text{r}(\\text{e})}$ | $K_\\text{J}^2$ | $1.2 \\times 10^{-8} \\approx 2 u_\\text{r}(K_\\text{J})$ | $\\frac{24 h R_{\\infty}}{c \\alpha^2 A_\\text{r}(\\text{e})}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nMolar mass of carbon-12 | $M(^{12}\\text{C})$ | $0.012kg\\cdot mol^{−1}$ | None | Exact | $\\frac{24 h R_{\\infty} N_\\text{A}}{c \\alpha^2 A_\\text{r}(\\text{e})}$ | $\\alpha^2$ | $4.7 \\times 10^{-10} \\approx 2 u_\\text{r}(\\alpha)$\nFaraday constant | $F$ | $\\frac{c \\alpha^2 K_\\text{J} A_\\text{r}(\\text{e}) M_\\text{u}}{4 R_{\\infty}}$ | $K_\\text{J}, \\alpha^2$ | $6.2 \\times 10^{-9} \\approx u_\\text{r}(K_\\text{J})$ | $e N_\\text{A}$ | None | Exact\nTemperature of triple point of water | $T_\\text{TPW}$ | 273.16 K | None | Exact | $T_\\text{TPW}$ | $T_\\text{TPW}$ | $5.7 \\times 10^{-7} = u_\\text{r}(T_\\text{TPW})$\nMolar gas constant | $R$ | $R$ | $R$ | $5.7 \\times 10^{-7} = u_\\text{r}(R)$ | $k N_\\text{A}$ | None | Exact\nBoltzmann constant | $k$ | $\\frac{16 R R_{\\infty}}{c^2 \\alpha \\mu_0 K_\\text{J}^2 A_\\text{r}(\\text{e}) M_\\text{u}}$ | $R$ | $5.7 \\times 10^{-7} \\approx u_\\text{r}(R)$ | $1.380649\\times10^{-23} kg\\cdot m^2\\cdot K^{−1} \\cdot s^{−2}$ | None | Exact\nStefan–Boltzmann constant | $\\sigma$ | $\\frac{256 \\pi^5 R^4 R_{\\infty}^4}{15 c^7 \\alpha^7 \\mu_0 K_\\text{J}^2 A_\\text{r}(\\text{e})^4 M_\\text{u}^4}$ | $R^4$ | $2.3 \\times 10^{-6} \\approx 4 u_\\text{r}(R)$ | $\\frac{2 \\pi^5 k^4}{15 h^3 c^2}$ | None | Exact\n\n注：其中，$c$为光速（speed of light），$\\alpha$为精细结构常数（fine-structure constant），$R_\\infty$为里德伯常量（Rydberg constant）。\n\n---\n\n参考文章：\n[Redefinition of SI base units - 维基百科](https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units)\n[国际单位制 - 维基百科](https://en.wikipedia.org/wiki/International_System_of_Units)\n\n拓展阅读：\n[刚刚，『千克』被重新定义！大K从此成为历史](https://mp.weixin.qq.com/s/bYIHtP3B33rPAHYWIvNatQ)\n","categories":["物理"]},{"title":"在网页上实现3D Touch效果","url":"/2018-11/在网页上实现3D Touch效果/","content":"\n![](/images/2018-11/3d_touch_cover_.jpg)\n\n2016年9月14日凌晨，iOS 10正式版开始向用户推送更新，而iOS 10搭载的Safari10亦带来了不少新特性，其中就有3D Touch事件的支持（官方文档[《What's New in Safari 10》](https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html)）。\n\n## Force Touch与3D Touch\n\n说到3D Touch不能不提与之相似的Force Touch。Force Touch是苹果公司在2014年9月公布的一项压力敏感屏幕技术，最早用于Apple Watch，可识别轻点、轻按两种操作。随后Force Touch于2015年9月在iPhone 6S上得到改进并更名为3D Touch，提供了更高灵敏度的触控力度识别、及更强的触感反馈，支持轻点、轻按及重按三个维度。\n\n支持3D Touch的设备，目前有iPhone 6S、iPhone 6S Plus、iPhone 7以及iPhone 7 Plus（注：截止2018年，还要加上iPhone 8和iPhone X等）。这是后文的硬件要求。\n\n## 感受3D Touch\n\n3D Touch最为典型的交互有Quick Actions和Peek and Pop两种。在APP图标上重按呼出一组快捷操作菜单，这即是典型的Quick Actions：\n\n![](/images/2018-11/quick_actions.jpg)\n\n而使用Peek and Pop则可以快速地对内容进行预览，以及后续的其他操作：\n\n![](/images/2018-11/peek_and_pop.jpg)\n\n如上图所示，在系统的邮件APP中，以一定的力度按压邮件列表中的某一项，会触发Peek弹出一个内容预览窗口（在Peek状态下上滑还能触发Quick Actions调出一些快捷操作项哦），如果继续加大按压力度，则会触发Pop进入邮件内容界面，这整个过程就称之为Peek and Pop。\n\n除了邮件APP以外，信息、照片等多个系统APP以及一些第三方APP（如微信、Facebook、Twitter等）也都很好的支持了Peek and Pop这种3D Touch交互形式。\n\n## 网页中的3D Touch\n\n要在网页中实现3D Touch，需要用到以下两个知识点：\n- touch.force\n在touch对象中包含有一个名为`force`的只读属性，它的取值从0到1，表示的是触碰点的按压力度，0表示没有检测到压力，而1则是设备能识别出的最大压力。\n\n- touchforcechange\n`touchforcechange`是Safari 10新增的事件，该事件会在按压力度改变时被触发。\n\n（注：在MacOS Safari上也有与之对应的`webkitmouseforcechanged`事件，该事件会在支持Force Touch的Trackpad上反应出按压力度值force的变化，但本文仅讨论手机设备的情况）\n\n## 实现3D Touch效果\n\n要实现3D Touch效果，关键在于实时地获取touch.force的值。而由于网页上的3D Touch很大程度上受限于设备及浏览器的支持情况，因此我们划分以下3种情况，分别来看看要如何实现：\n- 支持3D Touch且升级到了iOS 10的设备\n在这种最为理想的情况下，只需要监听touchforcechange事件即可获取到force的当前值，将force值的变化以适当的形式反馈在界面上以实现3D Touch效果。\n\n- 支持3D Touch但系统版本低于iOS 10的设备\n这种情况虽然无法监听touchforcechange事件，但Touch对象的force属性仍然可以反应出正确的按压力度，可以巧妙地设置一个定时器，以轮询的方式获取force的当前值。\n\n- 不支持3D Touch的设备\n这种情况下touch.force的取值始终为0，虽然可以用长按的交互形式来代替，但建议还是以优雅降级的方式，索性就不处理了吧。\n\n## 一个3D Touch的例子\n\n看到这里你肯定想说\"Shut up and show me the code...\"。好的，那我们来看一个例子，在这个示例页面，用支持3D Touch的设备按压蓝色按钮可以将树懒兄逗笑哦，嘿嘿嘿～\n\n<!-- more -->\n![](/images/2018-11/demo.png)\n\n你可扫描以上二维码，或[戳我进行预览](http://jdc.jd.com/demo/3d-touch)，**注意请使用iOS Safari浏览器进行访问！使用iOS Safari浏览器！！使用iOS Safari浏览器！！！**重要的事情要说三遍，因为目前微信WebView并不支持3D Touch。\n\n实现思路其实比较简单，根据刚刚说到的知识，我们分别监听touchforcechange、touchstart、touchend、touchcancel事件：\n- 在touchstart事件中，启动一个定时器轮询地去获取touch.force的值；\n- 在touchforcechange事件中获取当前touch.force的值，并清除touchstart事件中设置的定时器，因为支持touchforcechange事件的话就没必要轮询了；\n- 在touchend及touchcancel事件中把touch.force重置为0，并清除定时器。\n\n而树懒兄大笑的动画则用的是以下这张雪碧图，根据当前touch.force值来设置background-position以显示对应的动画帧来实现的。\n\n![](/images/2018-11/sloth.png)\n\n你可以访问这个[Github项目](https://github.com/hihuimin/3d-touch)来查看源码，核心代码位于ThreeDTouch.js，该文件封装了一个名为ThreeDTouch的类，事例化时传入一个DOM对象即可在callback中获取到按压力度值的变化。\n\n```javascript\n/**\n * 3D Touch 事件处理器，传入要监听的 DOM 对象，在 callback 回调中获取当前 force 值\n *\n * @param { HTMLElement } el - 要监听的 DOM 对象\n * @param { Function } callback - 带有 force 值的回调函数\n *\n */\nfunction ThreeDTouch(el, callback) {\n    this.el = el\n    this.callback = callback\n    this._bindEvents()\n}\nThreeDTouch.prototype = {\n    //绑定相关 touch 事件\n    _bindEvents: function() {\n        var events = ['touchforcechange', 'touchstart', 'touchend', 'touchcancel']\n        events.forEach(function(event) {\n            this.el.addEventListener(event, this, false)\n        }.bind(this))\n    },\n    //分派 touch 事件\n    handleEvent: function(ev) {\n        switch (ev.type) {\n            case 'touchforcechange':\n                this._touchForceDidChange(ev)\n                break\n            case 'touchstart':\n                this._touchDidStart(ev)\n                break\n            case 'touchend':\n            case 'touchcancel':\n                this._touchDidEnd(ev)\n        }\n    },\n    //force 值改变时\n    _touchForceDidChange: function(ev) {\n        var force = ev.touches[0].force\n        this.callback(force)\n        clearTimeout(this.timeoutId) //支持 touchforcechange 的话则取消轮询\n    },\n    _touchDidStart: function(ev) {\n        var touch = ev.touches[0]\n        this._checkForce(touch)\n    },\n    _touchDidEnd: function(ev) {\n        this.callback(0)\n        clearTimeout(this.timeoutId)\n    },\n    //轮询地获取 force 值\n    _checkForce: function(touch) {\n        this.callback(touch.force)\n        this.timeoutId = setTimeout(this._checkForce.bind(this, touch), 16)\n    }\n}\n```\n\n---\n\n本文转载自：[在网页上实现 3D Touch 效果 - 凹凸实验室](https://aotu.io/notes/2016/09/28/3d-touch)\n","tags":["JavaScript"],"categories":["Web开发"]},{"title":"使用示波器播放Bad Apple!!","url":"/2018-11/使用示波器播放Bad Apple!!/","content":"\n本视频于某次物理竞赛集训时拍摄于华中科技大学，音频为后期加上。\n为了对上音轨，前后各有一段黑屏，这是feature而非bug。敬请欣赏。\n\n{% video /files/badapple.mp4 %}\n","categories":["物理"]},{"title":"用Telnet观看Nyancat动画","url":"/2018-11/用Telnet观看Nyancat动画/","content":"\n## 前言\n\n最近在知乎上看到一个关于VPS有趣的用途的问题，[其中一个回答](https://www.zhihu.com/question/24284566/answer/27291403)提到了可以搭建Telnet服务器，成功运行后别人用Telnet连接你的主机将会看到Nyancat动画。大致效果如图所示：\n\n![](/images/2018-11/nyancat.png)\n\n然而，回答中给出的Demo已经失效，`telnet nyancat.dakko.us`会返回一个`Connection refused`错误。不过值得庆幸的是，这个项目的官方网站[Nyan Cat Telnet Server](http://nyancat.dakko.us)和[GitHub Repo](https://github.com/klange/nyancat)都还可以正常访问，因此可以尝试重新把它搭起来。不用着急，这个过程并不复杂，请按照以下方法操作即可。\n\n## 下载编译\n\n在命令行执行：\n```bash\ngit clone https://github.com/klange/nyancat.git\ncd nyancat\nmake\nmv src/nyancat /usr/bin #or make install\n```\n这时，通过`nyancat`或`nyancat -t`命令就可以查看效果。接下来把Telnet配置好就行了。\n\n## 配置Telnet\n\n使用包管理工具安装`xinetd`，例如\n```bash\nyum install xinetd\n```\n然后在`/etc/xinetd.d`目录下新建文件`nyancat`，内容为：\n```bash\nservice telnet\n{\n    flags          = REUSE\n    socket_type    = stream\n    wait           = no\n    user           = root\n    group          = root\n    server         = /usr/bin/nyancat\n    server_args    = -t\n    log_on_failure += USERID\n    disable        = no\n    instances      = 10\n    per_source     = 2\n}\n```\n其中`instances`和`per_source`限制了总的连接数和单个IP的连接数。\n接下来，重启`xinetd`服务：\n```bash\nsystemctl restart xinetd\n```\n这时，你就可以通过`telnet localhost`查看是否一切正常。如果没有问题，配置防火墙开放23端口，就可以从公网访问了。试试用Telnet连接你的主机，效果是不是非常酷炫？\n不过，博主在实践中发现，开放telnet的23端口可能会产生大量异常流量。解决方法是修改telnet的端口号，编辑`/etc/services`，找到telnet，将23改为一个你喜欢的数字（比如8080）。或者，可以在不需要使用时直接关闭这个服务，在`nyancat`中设置`disable: yes`即可。\n\n## 更多\n\n俗话说，有光的地方就有Bad Apple!!。很久以前的一篇文章[近期完成的数个游戏及应用](/2017-12/近期完成的数个游戏及应用/)中，就提到博主成功使用HTML页面播放Bad Apple!!字符画。目前，博主正在尝试搭建一个可以播放Bad Apple!!的Telnet服务器，敬请期待。\n\n---\n\n本文更新于2019年2月14日：\n博主通过魔改Nyancat的代码，成功地实现了可以播放Bad Apple!!的Telnet服务器。可以阅读文章[用Telnet观看Bad Apple!!](/2019-02/用Telnet观看Bad%20Apple!!/)查看。\n","tags":["Linux"],"categories":["技术"]},{"title":"Heavens Above爬虫的实现","url":"/2018-10/Heavens Above爬虫的实现/","content":"\n[Heavens Above](https://www.heavens-above.com)是一个天文数据库网站，可以查询到诸如卫星过境的很多信息。虽然数据很全面，但是检索方式非常繁琐，在网站上需要依次打开多个链接进行比对，难以迅速地获取需要的信息。故博主决定写一个爬虫，以直观地展现所有数据。由于Heavens Above采取了大量的反爬虫措施，例如校验Cookie、限制单个IP的访问次数等，因此必须严格地模拟浏览器请求，才能正确爬取数据。\n\n![](/images/2018-10/iss.png)\n\n博主也参考了大量GitHub上已有的Heavens Above爬虫项目，不过它们大部分失去维护，停留在数年前，已经不再适用。具体的逻辑还是要自行测试。\n\n项目地址：[heavens-above](https://github.com/stevenjoezhang/heavens-above)\n","tags":["GitHub","天文"],"categories":["程序设计"]},{"title":"Thanks for inventing Javascript","url":"/2018-10/Thanks for inventing Javascript/","content":"\n![](/images/2018-10/thanks-for-inventing-javascript.jpg)\n","tags":["JavaScript"],"categories":["幽默"]},{"title":"使用OpenCV进行星轨的后期处理","url":"/2018-10/使用OpenCV进行星轨的后期处理/","content":"\n贴上部分代码，择日填坑。\n```python\n#!/usr/bin/env python3\n\nimport os\nimport cv2\n\ndef addImage(img_orig, img_path, alpha = 0.5):\n    img = cv2.imread(img_path)\n    h, w, _ = img_orig.shape\n    beta = 1 - alpha\n    gamma = 0\n    return cv2.addWeighted(img_orig, alpha, img, beta, gamma)\n\ndef test():\n    img_root = \"\" #这里写你的文件夹路径，比如：/home/youname/data/img/ 注意最后一个文件夹要有斜杠\n    fps = 24 #保存视频的FPS，可以适当调整\n\n    #可以用(*\"DVIX\")或(*\"X264\")，如果都不行先装ffmepg: sudo apt install ffmepg\n    fourcc = cv2.VideoWriter_fourcc(*\"MJPG\")\n    videoWriter = cv2.VideoWriter(\"saveVideo.mp4v\", fourcc, fps, (3168, 4752)) #最后一个是保存图片的尺寸\n\n    for i in range(99):\n        #frame = cv2.imread(img_root+str(i+1)+\".jpg\")\n        frame = addImage(\"IMG_3866.jpg\", \"IMG_3869.jpg\")\n        videoWriter.write(frame)\n    videoWriter.release()\n\nif __name__ == \"__main__\":\n    folder = input(\"请输入照片所在文件夹\") or \".\"\n    prefix = input(\"请输入照片前缀\") or \"IMG_\"\n    suffix = input(\"请输入照片后缀\") or \"jpg\"\n    digits = int(input(\"请输入照片序号位数\") or 4)\n    start = int(input(\"请输入第一张照片序号\") or 0)\n    end = int(input(\"请输入最后一张照片序号\") or 1)\n    fps = int(input(\"请输入视频帧率\") or 24)\n    fpp = int(input(\"请输入每张照片持续的帧数\") or 2)\n\n    imgArray = []\n    for i in range(start, end + 1):\n        imgPath = folder + \"/\" + prefix + i + \".\" + suffix\n        if os.path.exists(imgPath):\n            imgArray.append(imgPath)\n\n    frame = cv2.imread(imgArray[0])\n    h, w, _ = frame.shape\n    fourcc = cv2.VideoWriter_fourcc(*\"MJPG\")\n    videoWriter = cv2.VideoWriter(\"saveVideo.mp4v\", fourcc, fps, (w, h))\n    #videoWriter.write(frame)\n    for i in range(len(imgArray)):\n        #frame = cv2.imread(img_root+str(i+1)+\".jpg\")\n        frame = addImage(frame, imgArray[i], i / (i + 1))\n        videoWriter.write(frame)\n        print(i + \"/\" + (i + 1))\n    videoWriter.release()\n```\n\n---\n\n参考文章：\n[Python-OpenCV 图像叠加or图像混合加权](https://blog.csdn.net/zh_jessica/article/details/77992578)\n[python + opencv 将图片保存为视频](https://blog.csdn.net/aa846555831/article/details/53070314)\n\n拓展阅读：[叠加法星轨的拍摄及后期方法](http://www.imgzone.cn/article-377-1.html)\n","tags":["Python","天文"],"categories":["程序设计"]},{"title":"古惑狼游戏牵扯出的硬件bug","url":"/2018-10/古惑狼游戏牵扯出的硬件bug/","content":"\nIt's kind of painful to re-live this one. As a programmer, you learn to blame your code first, second, and third... and somewhere around 10,000th you blame the compiler. Well down the list after that, you blame the hardware. \n回想起这个bug，仍然让我感觉有些痛苦。作为一个程序员，在发现bug时，你学会了首先在自己代码中找问题，一次、两次、三次……或许在测试一万次之后，你会把问题归咎于编译器。只有在这所有的都不起作用之后，你才会把问题归咎于硬件。\n\nThis is my hardware bug story.\n这是我遭遇硬件bug的故事。\n\nAmong other things, I wrote the memory card (load/save) code for Crash Bandicoot. For a swaggering game coder, this is like a walk in the park; I expected it would take a few days. I ended up debugging that code for six weeks. I did other stuff during that time, but I kept coming back to this bug -- a few hours every few days. It was agonizing.\n抛开别的不说，我曾为古惑狼（Crash Bandicoot，PS1游戏）写存储卡（读写）代码。对于一个自大的游戏程序员，这就像是在公园里散步一样轻松愉快；我预计只要几天就可以写完。我最终用了六个礼拜把那些代码调试完毕。在此期间我也做过一些其他的事情，但却一直绕不开这个bug——每几天内就要花上好几个小时来处理。这个bug实在烦人。\n\nThe symptom was that you'd go to save your progress and it would access the memory card, and almost all the time, it worked normally... But every once in a while the write or read would time out... for no obvious reason. A short write would often corrupt the memory card. The player would go to save, and not only would we not save, we'd wipe their memory card. D'Oh.\n这个bug的症状是，当你需要保存你的进度时，代码会访问存储卡，而大部分情况下没有什么问题…但是偶尔读写会超时…没有任何明显的原因。一个简短的写入经常毁掉存储卡。玩家要保存进度，我们不仅不保存，还擦除他们存储卡上的全部东西。天哪。\n\nAfter a while, our producer at Sony, Connie Booth, began to panic. We obviously couldn't ship the game with that bug, and after six weeks I still had no clue what the problem was. Via Connie we put the word out to other PlayStation 1 developers -- had anybody seen anything like this? Nope. Absolutely nobody had any problems with the memory card system.\n过了一段时间，我们在Sony的制作人Connie Booth慌了。我们显然不能发布带有这个bug游戏，而六个星期之后我对于问题出在哪一点线索都没有。通过Connie我们向其他PS1开发者求助：有没有人出现过像我们这样的情况？没有。绝对没有任何人在存储卡系统上出现任何问题。\n\nAbout the only thing you can do when you run out of ideas debugging is divide and conquer: keep removing more and more of the errant program's code until you're left with something relatively small that still exhibits the problem. You keep carving parts away until the only stuff left is where the bug is.\n在你绞尽脑汁之后，你能做的唯一一个调试方法就是分而治之：一点点去除错误程序中的代码，直到留下的代码相对很少，但仍然表现出问题。像雕刻一样去除没有问题的代码，留下的就是你的bug所在。\n\n<!-- more -->\nThe challenge with this in the context of, say, a video game is that it's very hard to remove pieces. How do you still run the game if you remove the code that simulates gravity in the game? Or renders the characters? \n在这样的背景下挑战在于，视频游戏是很难去除某一部分的。在你删除模拟重力或者显示字符的代码后，如何运行游戏？\n\nWhat you have to do is replace entire modules with stubs that pretend to do the real thing, but actually do something completely trivial that can't be buggy. You have to write new scaffolding code just to keep things working at all. It is a slow, painful process.\n你必须做的是用一个假装做真正的事情，但实际上只是做很简单的不会出现bug事情的东西来替换掉整个模块。你必须写新的支撑代码来让这些玩意正常工作。这是一个缓慢而痛苦的过程。\n\nLong story short: I did this. I kept removing more and more hunks of code until I ended up, pretty much, with nothing but the startup code -- just the code that set up the system to run the game, initialized the rendering hardware, etc. Of course, I couldn't put up the load/save menu at that point because I'd stubbed out all the graphics code. But I could pretend the user used the (invisible) load/save screen and asked to save, then write to the card.\n长话短说：我做完了。我移除了大片大片的代码，相当多，只留下了初始化代码——就是准备游戏运行系统，初始化渲染硬件等等。当然，我不能显示加载/保存菜单，因为我掐掉了所有的图像代码。但是我能够假装用户使用（不可见的）加载/保存屏幕并且请求保存，然后写入卡中。\n\nI ultimately ended up with a pretty small amount of code that exhibited the problem -- but still randomly! Most of the time, it would work, but every once in a while, it would fail. Almost all of the actual Crash Bandicoot code had been removed, but it still happened. This was really baffling: the code that remained wasn't really doing anything.\n我最终以一个带有这个bug的很少量的代码结束——但问题仍然随机出现！在大多数情况下没啥问题，但是偶尔会失效。基本上所有古惑狼游戏的实际代码都被移除了，但问题还是会复现。这实在是莫名其妙：留下来的代码基本上都没做什么事。\n\nAt some moment -- it was probably 3 am -- a thought entered my mind. Reading and writing (I/O) involves precise timing. Whether you're dealing with a hard drive, a compact flash card, a Bluetooth transmitter -- whatever -- the low-level code that reads and writes has to do so according to a clock.\n在那时——估计是凌晨3点——一个想法蹦了出来。读写（I/O）涉及精确定时。无论是硬盘、存储卡、蓝牙发送器——随便啥——做读写的底层代码都是根据时钟来的。\n\nThe clock lets the hardware device -- which isn't directly connected to the CPU -- stay in sync with the code the CPU is running. The clock determines the baud rate -- the rate at which data is sent from one side to the other. If the timing gets messed up, the hardware or the software -- or both -- get confused. This is really, really bad, and usually results in data corruption.\n时钟让不直接连接到CPU的硬件设备和CPU运行的代码同步。时钟决定了波特率——数据从一头传到另一头的速率。如果计时有什么问题，硬件或者软件或者两者都会乱七八糟的。这真的，真的很糟糕，并且通常导致数据损坏。\n\nWhat if something in our setup code was messing up the timing somehow? I looked again at the code in the test program for timing-related stuff, and noticed that we set the programmable timer on the PlayStation 1 to 1 kHz (1000 ticks/second). This is relatively fast; it was running at something like 100 Hz in its default state when the PlayStation 1 started up. Most games, therefore, would have this timer running at 100 Hz.\n如果我们的初始化代码以某种方式弄乱了计时会怎么样？我又看了一遍测试程序中和计时有关的代码，并注意到我们将PS1上的可编程计时器设置到了1kHz（1000跳每秒）。这是比较快了，当PS1启动的时候，默认状态大概是100Hz。因此，大多数游戏将他们的计时器设置为100Hz。\n\nAndy, the lead (and only other) developer on the game, set the timer to 1 kHz so that the motion calculations in Crash Bandicoot would be more accurate. Andy likes overkill, and if we were going to simulate gravity, we ought to do it as high-precision as possible!\n这个游戏的带头（和除我外的唯一）开发者Andy，将计时器设置为1kHz，使得古惑狼的动作计算更加准确。Andy喜欢简单粗暴的做法，如果我们要模拟重力，我们应该尽可能的提高精度！\n\nBut what if increasing this timer somehow interfered with the overall timing of the program, and therefore with the clock used to set the baud rate for the memory card?\n然而如果提高计时器频率莫名其妙的干扰了整个程序的计时，故而将这个计时器设置到存储卡的波特率上会怎样呢？\n\nI commented the timer code out. I couldn't make the error happen again. But this didn't mean it was fixed; the problem only happened randomly. What if I was just getting lucky?\n我将计时器代码注释掉。然后我就无法复现这个bug了。但是这并不表示bug被修复了，这个问题是随机发生的。万一我只是运气好呢？\n\nAs more days went on, I kept playing with my test program. The bug never happened again. I went back to the full Crash Bandicoot code base, and modified the load/save code to reset the programmable timer to its default setting (100 Hz) before accessing the memory card, then put it back to 1 kHz afterwards. We never saw the read/write problems again.\n几天过去了，我还是在玩我的测试程序。Bug没有再出现。我又回到完整的古惑狼游戏代码中，修改了加载/保存代码，在访问存储卡之前将可编程计时器重置为默认设置（100Hz），之后设置回1kHz。从此之后没有发现问题再次出现。\n\nBut why?\n但是…为什么？\n\nI returned repeatedly to the test program, trying to detect some pattern to the errors that occurred when the timer was set to 1 kHz. Eventually, I noticed that the errors happened when someone was playing with the PlayStation 1 controller. Since I would rarely do this myself -- why would I play with the controller when testing the load/save code? -- I hadn't noticed it. But one day one of the artists was waiting for me to finish testing -- I'm sure I was cursing at the time -- and he was nervously fiddling with the controller. It failed. \"Wait, what? Hey, do that again!\"\n我重新回到测试程序上，试着检测当计时器设置为1kHz时出现的那些错误的模式。终于，我注意到这些错误出现在使用PS1手柄的人身上。因为我自己很少这样做，所以我没有注意到（为啥我要在测试加载/保存代码的时候用手柄）。但是有一天我们的美工等我去完成测试（我确定那时候我在爆粗口），而他紧张的摆弄着手柄。卡损坏了。『等下，怎么回事？喂，再来一次！』\n\nOnce I had the insight that the two things were correlated, it was easy to reproduce: start writing to memory card, wiggle controller, corrupt memory card. Sure looked like a hardware bug to me.\n一旦我发现了这两件事是联系着的，就很容易重现bug：开始写入存储卡，动一下手柄，存储卡损坏。在我看来这完全是硬件bug。\n\nI went back to Connie and told her what I'd found. She relayed this to one of the hardware engineers who had designed the PlayStation 1. \"Impossible,\" she was told. \"This cannot be a hardware problem.\" I told her to ask if I could speak with him.\n我去找Connie告诉他我的发现。她转述给设计过PS1的硬件工程师。她被告知：『不可能，这不可能是硬件问题。』我跟她说问一下我能不能直接和硬件工程师交流。\n\nHe called me and, in his broken English and my (extremely) broken Japanese, we argued. I finally said, \"just let me send you a 30-line test program that makes it happen when you wiggle the controller.\" He relented. This would be a waste of time, he assured me, and he was extremely busy with a new project, but he would oblige because we were a very important developer for Sony. I cleaned up my little test program and sent it over.\n那个工程师给我打电话了，我们争论了起来——他用着他的烂英语，我用着我更烂的日语。我最后说：『我给你一个30行的测试程序，让你在动手柄的时候能够出现这问题。』他答应了。『这是浪费时间』，他向我保证，而他正忙于一个新项目，但因为我们是Sony的重要开发者，他会帮忙看看的。我整理了这个测试程序，然后发送给了他。\n\nThe next evening (we were in LA and he was in Tokyo, so it was evening for me when he came in the next day) he called me and sheepishly apologized. It was a hardware problem.\n第二天晚上（我们在洛杉矶，而他在东京，所以对于我来说是晚上而他是到了第二天），他给我打电话，很难为情地向我道歉。这确实是个硬件问题。\n\nI've never been totally clear on what the exact problem was, but my impression from what I heard back from Sony HQ was that setting the programmable timer to a sufficiently high clock rate would interfere with things on the motherboard near the timer crystal. One of these things was the baud rate controller for the memory card, which also set the baud rate for the controllers. I'm not a hardware guy, so I'm pretty fuzzy on the details.\n我还是没有完全搞清楚问题到底在哪，但是我的印象中，从Sony总部的反馈听到的是，如果将可编程计时器设置到足够高的时钟频率，会影响到主板上时钟晶振附近的一些东西。这些东西之一就是存储卡的波特率控制器，而它同时也设置手柄的波特率。我不是搞硬件的，所以对于细节我相当模糊。\n\nBut the gist of it was that crosstalk between individual parts on the motherboard, and the combination of sending data over both the controller port and the memory card port while running the timer at 1 kHz would cause bits to get dropped... and the data lost... and the card corrupted.\n但是主旨是主板上两个独立部分的串扰，以及手柄接口和存储卡接口数据发送的结合在1kHz的时钟频率下会导致丢位，从而数据丢失，以致卡损坏。\n\nThis is the only time in my entire programming life that I've debugged a problem caused by quantum mechanics.\n这是我整个编程生涯中，唯一一次因为量子力学而debug的问题。\n\nFootnotes for posterity: \n后记：\n\nA few people have pointed out that this bug really wasn't a product of quantum mechanical effects, any more than any other bug is. Of course I was being hyperbolic mentioning quantum mechanics. But this bug did feel different to me, in that the behavior was -- at least at the level of the source code -- non-deterministic.\n有小部分人指出这个bug实际上不是量子力学的副效应，在这点上和其它bug也没什么不同。当然我提到量子力学确实是夸张了。不过这个bug给我的感觉很不相同，特别是它的行为——至少在源代码层面上——不是很具有确定性。\n\nSome people have said I should have taken more electronics classes. That is absolutely true; I consider myself a \"full stack\" programmer, but my stack really only goes down to hand-writing assembly code, not to playing with transistors. Perhaps some day I will learn more about the \"bare metal\"...\n有人说我应该学习更多的电子线路课程。这当然没毛病；我自称『全栈工程师』，但我的技术栈只开到了手写汇编代码，而没有涉及晶体管之类。也许有一天我会更多地了解『裸金属』。\n\nFinally, a few have questioned whether a better development methodology would have prevented this kind of bug in the first place. I don't think so, but it's possible. I use test-driven development for some coding tasks these days, but it's doubtful we could have usefully applied these techniques given the constraints of the systems and tools we were using.\n最后，一些人质疑一种更好的开发方法是否能够首先防止这种错误。我不这么认为，但这是可能的。我现在使用测试驱动开发来完成某些编码任务，但考虑到我们使用的系统和工具的限制，我们可以有效地应用这些技术。\n\n---\n\n本文翻译自：[What's the hardest bug you've debugged?](https://www.quora.com/Programming-Interviews/Whats-the-hardest-bug-youve-debugged/answer/Dave-Baggett)\n\n拓展阅读：\n更多关于Bug和Feature的故事：\n[Zune 'bug' fixed, says Microsoft](http://news.bbc.co.uk/2/hi/technology/7807797.stm)\n[Berners-Lee 'sorry' for slashes](http://news.bbc.co.uk/2/hi/technology/8306631.stm)\n\n一个人为制造异常的故事：[Chaos Monkey](https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey)\n","categories":["程序设计"]},{"title":"关于黎曼猜想","url":"/2018-09/关于黎曼猜想/","content":"\n前几日关于黎曼猜想（Riemann Hypothesis）被证明的消息在网络上炒得沸沸扬扬，菲尔兹奖、阿贝尔奖双料得主Michael Francis Atiyah爵士声称他证明了这个困扰了数学界160年的问题，且其目的是为了研究精细结构常数。然而，在他公布了他的Simple Proof后，却不被学界所看好，甚至遭到了一些尖锐的批评。毕竟，这篇只有五页纸的文章，刨去介绍等内容，并没有展示太多的细节；其证明过程，又依赖于一个存疑的Todd function。如果如证明中所说，黎曼猜想真的指向了精细结构常数，这对于由第一性原理出发构建物理学体系将有极大的启发性，其结果无疑是令人激动的。但是经过计算，却发现文中所声称的极限存在问题，整个理论的正确性难以得到证实。\n有鉴于此，博主研究该证明过程的计划搁置了（毕竟没有什么价值，大概可以用来提升读Paper的能力#捂脸），还是写篇文章介绍下黎曼猜想本身吧。\n\n## 猜想的提出\n\n时间回到1859年，著名的德国数学家波恩哈德·黎曼（Bernhard Riemann）在他的论文《Über die Anzahl der Primzahlen unter einer gegebenen Größe》中提及了这个著名的猜想。黎曼本人在数学界颇有建树，但他却并没有试图对论文中的猜想给出证明。\n这个猜想是关于黎曼$\\zeta$函数的，该函数的定义为：\n$$\\zeta(s)=\\frac{1}{1^s}+\\frac{1}{2^s}+\\frac{1}{3^s}+\\frac{1}{4^s}+\\cdots$$\n注意，$\\zeta$函数必须经过解析延拓，才能在全复平面上有定义，稍后将给出解析延拓的过程。\n而黎曼猜想就是：$\\zeta(s)$的所有非平凡零点的实部均为$\\frac{1}{2}$。\n\n## $\\zeta$函数的解析延拓\n\n### 前言\n\n在中学数学中，我们所接触到的函数都是实变函数，即从实数集到实数集的映射，写为$f:\\mathbb{R}\\rightarrow\\mathbb{R}$。在接触了虚数单位i和复数后，就可以开始定义复变函数，即复数集到复数集的映射，写为$f:\\mathbb{C}\\rightarrow\\mathbb{C}$。实变函数的定义域被限制在了实轴上，而为了表示出一个与之对应的复变函数，就需要扩充其定义域到复平面上。这样，可以定义出复数域上的各种函数：指数、对数、三角函数等。由于复数的性质，还需要根据枝点规定割线、单值分支等，来确定出函数值。而原本定义域只在复平面上某一区域的复变函数，经过严格的数学推导（例如级数展开等），也可以扩充其定义域。这时，解析延拓的办法应运而生。对于$\\zeta(s)$函数而言，非常明显，当$s$取在实轴上（即作为实变函数时），若$s\\le 1$，其函数值发散；而$s>1$时收敛。特别的，$s=1$时为调和级数，而$s=2$时由高斯最早计算出了其函数值$\\frac{\\pi^2}{6}$。\n在复数域上，可以证明，$\\zeta(s)$在$Re(s)>1$上解析。接下来，我们需要将其定义域扩展到全复平面；之前的级数定义将不在对$Re(s)<1$的情况使用，因为它不收敛，无法采用Cauchy和。\n\n### 梅林变换\n\n梅林（Mellin）变换是一个积分变换，它把一个正实数域$\\mathbb{R}^+$上的函数变换为一个复数域$\\mathbb{C}$上的函数。设$f:\\mathbb{R}^+\\rightarrow\\mathbb{C}$是一个函数，定义：\n$$\\mathcal{M}f(z)=\\int_0^{+\\infty}f(s)s^z\\frac{ds}{s}$$\n称$\\mathcal{M}f:\\mathbb{C}\\rightarrow\\mathbb{C}$为$f$的梅林变换。\n取$f(s)$为$f_\\lambda (s)=e^{-\\lambda s}$，则有：\n\\begin{align\\*}\n\\mathcal{M}f(z)&=\\int_0^{+\\infty}e^{-\\lambda s}s^z\\frac{ds}{s}\\\\\\\\\n&=\\lambda^{-z}\\int_0^{+\\infty}e^{-s}s^{z-1}ds\\\\\\\\\n&=\\lambda^{-z}\\Gamma(z)\n\\end{align\\*}\n这里的$\\Gamma(z)$就是一般数理方程中会涉及到的$\\Gamma$函数，其性质不再赘述。\n记住以上结论，取$\\lambda=\\pi n^2$，继续构造函数：\n$$f(s)=\\sum_{n=1}^{\\infty}f_{\\pi n^2}(s)=\\sum_{n=1}^{\\infty}e^{-\\pi n^2 s}$$\n注意到梅林变换是线性的，这时，\n\\begin{align\\*}\n\\mathcal{M}f(z)&=\\sum_{n=1}^{\\infty}\\mathcal{M}f_{\\pi n^2}(z)\\\\\\\\\n&=\\sum_{n=1}^{\\infty}(\\pi n^2)^{-z}\\Gamma(z)\\\\\\\\\n&=\\pi^{-z}\\sum_{n=1}^{\\infty}n^{-2z}\\Gamma(z)\\\\\\\\\n&=\\pi^{-z}\\zeta(2z)\\Gamma(z)\n\\end{align\\*}\n最后一个等号使用了$\\zeta$函数的原始定义。考虑到：\n$$\\mathcal{M}f(z)=\\int_0^{+\\infty}(\\sum_{n=1}^{\\infty}e^{-\\pi n^2 s})s^{z-1}ds$$\n于是，利用$\\mathcal{M}f(z)$的两个等价表达式，我们得到了一个重要结论：\n$$\\pi^{-z}\\zeta(2z)\\Gamma(z)=\\int_0^{+\\infty}(\\sum_{n=1}^{\\infty}e^{-\\pi n^2 s})s^{z-1}ds$$\n注意，这里的推导并非十分严谨，还需要证明其收敛性，才能交换积分与极限。这要求$Re(z)>\\frac{1}{2}$。\n\n<!-- more -->\n### 泊松求和\n\n再来看一下Fourier变换\n$$\\mathcal{F}f(x)=\\int_{-\\infty}^{+\\infty}f(t)e^{ixt}dt$$\n对于足够『好』的函数$f$，可以证明泊松（Poisson）求和公式\n$$\\sum_{n\\in\\mathbb{Z}}f(n)=\\sum_{n\\in\\mathbb{Z}}\\mathcal{F}f(n)$$\n这部分我们就证明这个公式。\n假设$f$足够『好』（要多好有多好），定义\n$$F(t)=\\sum_{n\\in\\mathbb{Z}}f(n+t)$$\n则$F$是$\\mathbb{R}$上周期为$1$的函数，于是可以构造$F$的Fourier级数：令\n$$c_k=\\int_0^1F(t)e^{-2\\pi ikt}dt$$\n是第$k$个Fourier系数，则\n$$F(t)\\sim\\sum_{k\\in\\mathbb{Z}}c_ke^{2\\pi ikt}$$\n而这个系数\n\\begin{align\\*}\nc_k&=\\int_0^1F(t)e^{-2\\pi ikt}dt\\\\\\\\\n&=\\int_0^1\\sum_{n\\in\\mathbb{Z}}f(n+t)e^{-2\\pi ik(n+t)}dt\\\\\\\\\n&=\\int_{-\\infty}^{+\\infty}f(t)e^{-2\\pi ikt}dt\\\\\\\\\n&=\\mathcal{F}f(k)\n\\end{align\\*}\n从而\n$$\\sum_{n\\in\\mathbb{Z}}f(n)=F(0)\\sim\\sum_{k\\in\\mathbb{Z}}c_k=\\sum_{k\\in\\mathbb{Z}}\\mathcal{F}f(k)$$\n就得到了Poisson求和公式形式上的『证明』。\n那么$f$究竟要满足什么条件呢？\n如果周期函数$F\\in C^2[0,1]$，就有$F(t)=\\sum_{k\\in\\mathbb{Z}}c_ke^{2\\pi ikt}$。因此，我们要求$f$二阶连续可导，并且\n$$\\sum_{n\\in\\mathbb{Z}}||f||\\_{[n.n+1],\\infty}+||f'||\\_{[n.n+1],\\infty}+||f''||\\_{[n.n+1],\\infty}<+\\infty$$\n使用导数一致收敛的判别法则，就得到$F\\in C^2[0,1]$啦。\n也就是说，如果$f\\in C^2(\\mathbb{R})$，并且满足以上条件，就有Poisson求和公式\n$$\\sum_{n\\in\\mathbb{Z}}f(n)=\\sum_{n\\in\\mathbb{Z}}\\mathcal{F}f(n)$$\n\n### 解析延拓\n\n设$\\lambda>0$，令\n\\begin{eqnarray\\*}\n\\theta(\\lambda)&=&\\sum_{n\\in\\mathbb{Z}}e^{-\\pi n^2\\lambda}\\\\\\\\\n\\psi(\\lambda)&=&\\sum_{n=1}^\\infty e^{-\\pi n^2\\lambda}\n\\end{eqnarray\\*}\n很显然$\\theta(\\lambda)=2\\psi(\\lambda)+1$。\n考虑$f(t)=e^{-\\pi t^2\\lambda}$，计算得$\\mathcal{F}f(x)=\\frac{1}{\\sqrt{\\lambda}}e^{-\\pi\\frac{x^2}{\\lambda}}$，而且满足相应条件，因此用Poisson求和公式，\n$$\\sum_{n\\in\\mathbb{Z}}e^{-\\pi n^2\\lambda}=\\frac{1}{\\sqrt{\\lambda}}\\sum_{n\\in\\mathbb{Z}}e^{-\\pi\\frac{n^2}{\\lambda}}$$\n即$\\theta(\\lambda)=\\frac{1}{\\sqrt{\\lambda}}\\theta\\left(\\frac{1}{\\lambda}\\right)$。\n换成$\\psi$就是$\\psi\\left(\\frac{1}{\\lambda}\\right)=\\sqrt{\\lambda}\\psi(\\lambda)+\\frac{\\sqrt{\\lambda}-1}{2}$。\n第二部分的最后，得到了\n\\begin{align\\*}\n\\pi^{-z}\\zeta(2z)\\Gamma(z)&=\\int_0^{+\\infty}\\left(\\sum_{n=1}^\\infty e^{-\\pi n^2s}\\right)s^{z-1}ds\\\\\\\\\n&=\\int_0^{+\\infty}\\psi(s)s^{z-1}ds\n\\end{align\\*}\n因此\n\\begin{align\\*}\n\\pi^{-z}\\zeta(2z)\\Gamma(z)&=\\int_0^{+\\infty}\\psi(s)s^{z-1}ds\\\\\\\\\n&=\\int_1^{+\\infty}\\psi(s)s^{z-1}ds+\\int_0^1\\psi(s)s^{z-1}ds\\\\\\\\\n&=\\int_1^{+\\infty}\\psi(s)s^{z-1}ds+\\int_1^{+\\infty}\\psi\\left(\\frac{1}{s}\\right)s^{1-z}\\frac{ds}{s^2}\\\\\\\\\n&=\\int_1^{+\\infty}\\psi(s)s^{z-1}ds+\\int_1^{+\\infty}\\left(\\psi(s)\\sqrt{s}+\\frac{\\sqrt{s}-1}{2}\\right)s^{-1-z}ds\\\\\\\\\n&=\\int_1^{+\\infty}\\psi(s)(s^{z-1}+s^{-z-\\frac{1}{2}})ds+\\int_1^{+\\infty}\\frac{s^{-z-\\frac{1}{2}}-s^{-z-1}}{2}ds\\\\\\\\\n&=\\int_1^{+\\infty}\\psi(s)(s^{z-1}+s^{-z-\\frac{1}{2}})ds+\\frac{1}{2z(2z-1)}\n\\end{align\\*}\n以上计算的前提是$Re(z)>\\frac{1}{2}$。\n令$w=2z$，则当$Re(w)>1$时，\n$$\\sqrt{\\pi}^{-w}\\zeta(w)\\Gamma\\left(\\frac{w}{2}\\right)=\\int_1^{+\\infty}\\psi(s)(\\sqrt{s}^{w-2}+\\sqrt{s}^{-w-1})ds-\\frac{1}{w(1-w)}$$\n现在观察：等号右边是一个亚纯函数（亚纯函数就是『能表示成两个解析函数的商』的函数，或者『没有本性奇点』的函数，两个亚纯函数经过四则运算仍然是亚纯函数），而等号左边的$\\sqrt{\\pi}^{-w}$、$\\Gamma\\left(\\frac{w}{2}\\right)$也都是亚纯函数。这样，上式相当于给出了$\\zeta(w)$在$w\\in\\mathbb{C}$上的定义！\n\n## 所有自然数的『和』\n\n这还没完，试试在等号右边把$w$换为$1-w$，你会发现式子根本没变。这就说明：\n$$\\sqrt{\\pi}^{-w}\\zeta(w)\\Gamma\\left(\\frac{w}{2}\\right)=\\sqrt{\\pi}^{w-1}\\zeta(1-w)\\Gamma\\left(\\frac{1-w}{2}\\right)$$\n现在让$w=-1$，就有\n$$\\sqrt{\\pi}\\zeta(-1)\\Gamma\\left(-\\frac{1}{2}\\right)=\\sqrt{\\pi}^{-2}\\zeta(2)\\Gamma(1)$$\n我们知道\n$$\\zeta(2)=\\sum_{n=1}^\\infty\\frac{1}{n^2}=\\frac{\\pi^2}{6}$$\n并且，\n\\begin{eqnarray\\*}\n\\Gamma(1)&=&1\\\\\\\\\n\\Gamma\\left(\\frac{1}{2}\\right)&=&\\sqrt{\\pi}\\\\\\\\\n\\Gamma\\left(-\\frac{1}{2}\\right)&=&\\frac{\\Gamma\\left(\\frac{1}{2}\\right)}{-\\frac{1}{2}}=-2\\sqrt{\\pi}\n\\end{eqnarray\\*}\n因此：\n$$\\zeta(-1)=\\frac{\\sqrt{\\pi}^{-2}\\zeta(2)\\Gamma(1)}{\\sqrt{\\pi}\\Gamma\\left(-\\frac{1}{2}\\right)}=\\frac{\\frac{\\pi^2}{6}}{\\sqrt{\\pi}^3(-2)\\sqrt{\\pi}}=-\\frac{1}{12}$$\n我们便得出了全体自然数的『和』为$-\\frac{1}{12}$这一结论。\n\n## 黎曼猜想与素数\n\n### 欧拉乘积公式\n\n从$\\zeta$函数的原始定义出发：\n$$\\zeta(s)=\\frac{1}{1^s}+\\frac{1}{2^s}+\\frac{1}{3^s}+\\cdots$$\n在等式两边同时乘以第二项：\n$$\\frac{1}{2^s}\\times\\zeta(s)=\\frac{1}{2^s}+\\frac{1}{4^s}+\\frac{1}{6^s}+\\cdots$$\n两式相减得：\n$$(1-\\frac{1}{2^s})\\times\\zeta(s)=\\frac{1}{1^s}+\\frac{1}{3^s}+\\frac{1}{5^s}+\\cdots$$\n这时，等号右边的分母上已经没有2的倍数了。重复这一过程：\n$$\\frac{1}{3^s}\\times(1-\\frac{1}{2^s})\\zeta(s)=\\frac{1}{3^s}+\\frac{1}{9^s}+\\frac{1}{15^s}+\\cdots$$\n以上两式相减，又有：\n$$(1-\\frac{1}{3^s})(1-\\frac{1}{2^s})\\zeta(s)=\\frac{1}{1^s}+\\frac{1}{5^s}+\\frac{1}{7^s}+\\cdots$$\n等号右边也没有3的倍数了。无限重复此过程，就有：\n$$\\cdots(1-\\frac{1}{11^s})(1-\\frac{1}{7^s})(1-\\frac{1}{5^s})(1-\\frac{1}{3^s})\\zeta(s)=1$$\n即：\n$$\\zeta(s)=\\frac{1}{1-\\frac{1}{2^s}}\\times\\frac{1}{1-\\frac{1}{3^s}}\\times\\frac{1}{1-\\frac{1}{5^s}}\\times\\frac{1}{1-\\frac{1}{7^s}}\\times\\cdots$$\n可以写成：\n$$\\zeta(s)=\\sum_n\\frac{1}{n^s}=\\prod_p\\frac{1}{1-p^{-s}}$$\n这就是欧拉乘积公式，该表达式首先出现在1737年一篇题为《Variae observationes circa series infinitas》（无穷级数的各种观察）的论文中。\n该恒等式展示了素数与$\\zeta$函数间的联系。\n\n### 莫比乌斯函数\n\n奥古斯特·费迪南德·莫比乌斯之后重写了欧拉乘积公式，创造了一个新的求和。首先引入莫比乌斯函数：\n$$\\mu(n)=\n\\begin{cases}\n1 & n是偶数个不同的素数相乘\\\\\\\\\n-1 & n是奇数个不同的素数相乘\\\\\\\\\n0 & n被某个素数的平方整除\n\\end{cases}\n$$\n和式用$\\mu(n)$表示如下：\n$$\\frac{1}{\\zeta(s)}=\\sum_{n\\in\\mathbb{N}}\\frac{\\mu(n)}{n^s}$$\n\n### 素数计数函数\n\n定义为\n$$\\pi(x)=\\sum_{p\\le x}1$$\n表示不超过x的素数个数。\n在间断点处用左右平均代替更好，重新定义：\n$$\\pi(x)=\\frac{1}{2}\\left(\\sum_{p\\le x}1+\\sum_{p< x}1\\right)$$\n令\n$$\\Pi(x)=\\sum_n\\frac{1}{n}\\pi(x^{\\frac{1}{n}})$$\n有莫比乌斯反转\n$$\\pi(x)=\\sum_n\\frac{\\mu(n)}{n}\\Pi(x^{\\frac{1}{n}})$$\n\n### 素数定理\n\n素数定理由高斯和勒让德独立地阐述：\n$$\\mathop{\\lim}\\_{x\\rightarrow\\infty}\\frac{\\pi(x)}{\\frac{x}{\\ln(x)}}=1$$\n目前人类证明的素数定理的误差界是\n$$\\pi(x)=Li(x)+O\\left(x\\exp\\left({-\\frac{A(\\ln x)^{0.6}}{(\\ln\\ln x)^{0.2}}}\\right)\\right)$$\n从概率的角度来说，素数定理说明若你随机选择一个自然数$x$，那么该数字为素数的概率约为$\\frac{1}{\\ln(x)}$。这意味着前$x$个整数中相邻素数之间的平均间隙约为$\\ln(x)$。\n\n### 对数积分函数\n\n定义\n$$Li(x)=\\int_2^x\\frac{1}{\\ln(t)}dt$$\n称为对数积分函数。\n那么\n$$\\Pi(x)=Li(x)-\\sum_{\\rho}Li(x^{\\rho})-\\ln 2+\\int_x^\\infty\\frac{dt}{t(t^2-1)\\ln t}$$\n其中求和号的$\\rho$取$\\zeta(s)$的非平凡零点，求和之后通常表现为震荡。至于剩下的常数和积分，对较大的$x$可以忽略。\n\n## 未完待续\n\n敬请期待\n\n---\n\n参考文章：\n[黎曼猜想 - 维基百科](https://en.wikipedia.org/wiki/Riemann_hypothesis)\n[为什么全体自然数的和是负十二分之一？ - 知乎](https://zhuanlan.zhihu.com/p/35397224)\n[黎曼猜想跟素数分布有怎样的联系 - 知乎](https://zhuanlan.zhihu.com/p/45240901)\n[黎曼猜想，及其解释（上） - 知乎](https://zhuanlan.zhihu.com/p/25055731)\n[黎曼猜想，及其解释（下） - 知乎](https://zhuanlan.zhihu.com/p/25222934)\n\n拓展阅读：[The Euler-Maclaurin formula, Bernoulli numbers, the zeta function, and real-variable analytic continuation](https://terrytao.wordpress.com/2010/04/10/the-euler-maclaurin-formula-bernoulli-numbers-the-zeta-function-and-real-variable-analytic-continuation)\n","tags":["数学"],"categories":["其他"]},{"title":"月下独酌","url":"/2018-09/月下独酌/","content":"\n**月下独酌**\n*李白*\n花间一壶酒，独酌无相亲。\n举杯邀明月，对影成三人。\n月既不解饮，影徒随我身。\n暂伴月将影，行乐须及春。\n我歌月徘徊，我舞影零乱。\n醒时同交欢，醉后各分散。\n永结无情游，相期邈云汉。\n\n**八月十五夜月**\n*杜甫*\n满月飞明镜，归心折大刀。\n转蓬行地远，攀桂仰天高。\n水路疑霜雪，林栖见羽毛。\n此时瞻白兔，直欲数秋毫。\n\n**十五夜望月**\n*王建*\n中庭地白树栖鸦，冷露无声湿桂花。\n今夜月明人尽望，不知秋思落谁家！\n\n**南斋玩月**\n*王昌龄*\n高卧南斋时，开帷月初吐。\n清辉澹水木，演漾在窗户。\n荏苒几盈虚，澄澄变今古。\n美人清江畔，是夜越吟苦。\n千里共如何，微风吹兰杜。\n\n**中秋月**\n*苏轼*\n暮云收尽溢清寒，银汉无声转玉盘。\n此生此夜不长好，明月明年何处看。\n\n**中秋月**\n*齐已*\n空碧无云露湿衣，众星光外涌清规。\n东林莫碍渐高势，四海正看当路时。\n还许分明吟皓魄，肯教幽暗取丹枝。\n可怜关夜婵娟影，正对五候残酒卮。\n\n<!-- more -->\n**关山月**\n*李白*\n明月出天山，苍茫云海间。\n长风几万里，吹度玉门关。\n汉下白登道，胡窥青海湾。\n由来征战地，不见有人还。\n戍客望边色，思归多苦颜。\n高楼当此夜，叹息未应闲。\n\n**静夜思**\n*李白*\n床前明月光，疑是地上霜。\n举头望明月，低头思故乡。\n\n**月夜**\n*刘方平*\n更深月色半人家，北斗阑干南斗斜。\n今夜偏知春气暖，虫声新透绿窗纱。\n\n**嫦娥**\n*李商隐*\n云母屏风烛影深，长河渐落晓星沈。\n嫦娥应悔偷灵药，碧海青天夜夜心。\n\n**月夜忆舍弟**\n*杜甫*\n戍鼓断人行，秋边一雁声。\n露从今夜白，月是故乡明。\n有弟皆分散，无家问死生。\n寄书长不达，况乃未休兵。\n\n**望月怀远**\n*张九龄*\n海上生明月，天涯共此时。\n情人怨遥夜，竟夕起相思！\n灭烛怜光满，披衣觉露滋。\n不堪盈手赠，还寝梦佳期。\n\n**霜月**\n*李商隐*\n初闻征雁已无蝉，百尺楼高水接天。\n青女素娥俱耐冷，月中霜里斗婵娟\n\n**秋宵月下有怀**\n*孟浩然*\n秋空明月悬，光彩露沾湿。\n惊鹊栖未定，飞萤卷帘入。\n庭槐寒影疏，邻杵夜声急。\n佳期旷何许！望望空伫立。\n\n**中秋待月**\n*陆龟蒙*\n转缺霜输上转迟，好风偏似送佳期。\n帘斜树隔情无限，烛暗香残坐不辞。\n最爱笙调闻北里，渐看星潆失南箕。\n何人为校清凉力，欲减初圆及午时。\n\n**倪庄中秋**\n*元好问*\n强饭日逾瘦，狭衣秋已寒。\n儿童漫相忆，行路岂知难。\n露气入茅屋，溪声喧石滩。\n山中夜来月，到晓不曾看。\n\n**八月十五夜桃源玩月**\n*刘禹锡*\n尘中见月心亦闲，况是清秋仙府间。\n凝光悠悠寒露坠，此时立在最高山。\n碧虚无云风不起，山上长松山下水。\n群动悠然一顾中，天高地平千万里。\n少君引我升玉坛，礼空遥请真仙官。\n云軿欲下星斗动，天乐一声肌骨寒。\n金霞昕昕渐东上，轮欹影促犹频望。\n绝景良时难再并，他年此日应惆怅。\n\n**中秋月**\n*晏殊*\n十轮霜影转庭梧，此夕羁人独向隅。\n未必素娥无怅恨，玉蟾清冷桂花孤。\n\n**中秋月**\n*苏轼*\n暮云收尽溢清寒，银汉无声转玉盘。\n此生此夜不长好，明月明年何处看。\n\n**八月十五日夜湓亭望月**\n*白居易*\n昔年八月十五夜，曲江池畔杏园边。\n今年八月十五夜，湓浦沙头水馆前。\n西北望乡何处是，东南见月几回圆。\n昨风一吹无人会，今夜清光似往年。\n\n**天竺寺八月十五日夜桂子**\n*皮日休*\n玉颗珊珊下月轮，殿前拾得露华新。\n至今不会天中事，应是嫦娥掷与人。\n\n**中秋见月和子由**\n*苏轼*\n明月未出群山高，瑞光千丈生白毫。\n一杯未尽银阙涌，乱云脱坏如崩涛。\n谁为天公洗眸子，应费明河千斛水。\n遂令冷看世间人，照我湛然心不起。\n西南火星如弹丸，角尾奕奕苍龙蟠。\n今宵注眼看不见，更许萤火争清寒。\n何人舣舟昨古汴，千灯夜作鱼龙变。\n曲折无心逐浪花，低昂赴节随歌板。\n青荧灭没转山前，浪飐风回岂复坚。\n明月易低人易散，归来呼酒更重看。\n堂前月色愈清好，咽咽寒螀鸣露草。\n卷帘推户寂无人，窗下咿哑唯楚老。\n南都从事莫羞贫，对月题诗有几人。\n明朝人事随日出，恍然一梦瑶台客。\n\n**中秋登楼望月**\n*米芾*\n目穷淮海满如银，万道虹光育蚌珍。\n天上若无修月户，桂枝撑损向西轮。\n\n**明月何皎皎**\n*佚名*\n明月何皎皎，照我罗床帏。\n夜愁不能寐，揽衣起徘徊。\n客行虽云乐，不如早旋归。\n出户独彷徨，愁思当告谁！\n引领还入房，泪下沾裳衣。\n\n**水调歌头**\n*苏轼*\n明月几时有，把酒问青天。\n不知天上宫阙，今夕是何年。\n我欲乘风归去，惟恐琼楼玉宇，高处不胜寒。\n起舞弄清影，何似在人间。\n转朱阁，低绮户，照无眠。\n不应有恨，何事长向别时圆。\n人有悲欢离合，月有阴晴圆缺，此事古难全。\n但愿人长久，千里共婵娟。\n\n**西江月**\n*苏轼*\n顷在黄州，春夜行蕲水中。过酒家饮酒，醉。乘月至一溪桥上，解鞍曲肱，醉卧少休。及觉已晓。乱山攒拥，流水铿然，疑非人世也。书此语桥柱上。\n照野弥弥浅浪，横空隐隐层霄。障泥未解玉骢骄，我欲醉眠芳草。\n可惜一溪风月，莫教踏碎琼瑶。解鞍欹枕绿杨桥，杜宇一声春晓。\n","categories":["其他"]},{"title":"十个UI设计的基本原理","url":"/2018-09/十个UI设计的基本原理/","content":"\nIt's no great mystery that truly great user interfaces are the ones that are engineered to stay out of the way.\n真正优秀的用户界面都是那些设计得『不挡路』的——这并不是什么奥秘。\n'Staying out of the way' means not distracting your users. Rather, good UIs let your users complete goals. The result? A reduction in training and support costs, and happier, satisfied and highly engaged users.\n『不挡路』意味着不会分散用户的注意力。事实上，良好的用户界面可以让你的用户完成目标。结果呢？减少培训和支持的成本，以及让用户更快乐、更满意并被深深吸引。\nCheck out our other [design courses](https://teamtreehouse.com/library/topic:design) at Treehouse.\n在Treehouse查看我们的其他[设计课程](https://teamtreehouse.com/library/topic:design)。\nWhen getting started on a new interface, make sure to remember these fundamentals:\n在开始设计新的用户界面时，请务必记住以下原则：\n\n## Know your user\n\n了解你的用户\n\n> \"Obsess over customers: when given the choice between obsessing over competitors or customers, always obsess over customers. Start with customers and work backward.\" -- Jeff Bezos\n『对顾客的关注：当在关注竞争对手或顾客之间做出选择时，总是应该关注顾客。从顾客开始，用逆向思维工作。』 —— Jeff Bezos\n\nYour user's goals are your goals, so learn them. Restate them, repeat them. Then, learn about your user's skills and experience, and what they need. Find out what interfaces they like and sit down and watch how they *use* them. Do not get carried away trying to keep up with the competition by mimicking trendy design styles or adding new features. By focusing on your user first, you will be able to create an interface that lets them achieve their goals.\n你的用户的目标就是你的目标，因此请了解它们。重申它们，重复它们。然后，了解你的用户的技能和经验，以及他们需要什么。找出他们喜欢的界面，坐下来看看他们如何*使用*这些界面。不要试图通过模仿时尚的设计风格或添加新功能来跟上竞争对手，而忘乎所以。通过首先关注你的用户，你将能够创建一个让他们完成目标的界面。\n\n## Pay attention to patterns\n\n注意UI样式\n\nUsers spend the majority of their time on interfaces other than your own (Facebook, MySpace, Blogger, Bank of America, school/university, news websites, etc). There is no need to reinvent the wheel. Those interfaces may solve some of the same problems that users perceive within the one you are creating. By using familiar UI patterns, you will help your users feel at home.\n用户会将大部分时间花在除你以外的其他界面上（Facebook，MySpace，Blogger，美国银行，学校/大学，新闻网站等等）。没有必要重新发明轮子。这些接口可以解决用户在你正在创建的问题中感知的一些相同问题。通过使用熟悉的UI模式，你将让你的用户有宾至如归的感觉。\n\n## Stay consistent\n\n保持一致性\n\n> \"The more users' expectations prove right, the more they will feel in control of the system and the more they will like it.\" -- Jakob Nielson\n『越多用户的期望被证明是正确的，他们对系统的控制感越强，他们就会越喜欢它。』 —— Jakob Nielson\n\nYour users *need* consistency. They need to know that once they learn to do something, they will be able to do it again. Language, layout, and design are just a few interface elements that need consistency. A consistent interface enables your users to have a better understanding of how things will work, increasing their efficiency.\n你的用户*需要*一致性。他们需要知道，一旦他们学会做某事，他们就能再次做到。语言、布局和设计只是需要一致性的一些界面元素。一致的界面使你的用户能够更好地了解事物的运作方式，从而提高效率。\n\n<!-- more -->\n## Use visual hierarchy\n\n使用视觉层次结构\n\n> \"Designers can create normalcy out of chaos; they can clearly communicate ideas through the organizing and manipulating of words and pictures.\" -- Jeffery Veen, [The Art and Science of Web Design](http://veen.com/artsci)\n『设计师可以摆脱混乱的局面；他们可以通过组织和操纵文字和图片清晰地传达思想。』 —— Jeffery Veen，[网页设计的艺术与科学](http://veen.com/artsci)\n\nDesign your interface in a way that allows the user to focus on what is most important. The size, color, and placement of each element work together, creating a clear path to understanding your interface. A clear hierarchy will go great lengths in reducing the appearance of complexity (even when the actions themselves are complex).\n以允许用户专注于最重要的方式设计界面。每个元素的大小、颜色和位置协同工作，为理解界面创建了清晰的途径。明确的层次结构将大大减少复杂性的出现（即使行动本身很复杂）。\n\n## Provide feedback\n\n提供反馈信息\n\nYour interface should at all times speak to your user, when his/her actions are both right and wrong or misunderstood. Always inform your users of actions, changes in state and errors, or exceptions that occur. Visual cues or simple messaging can show the user whether his or her actions have led to the expected result.\n无论用户的行为正确、错误还是被误解时，你的界面应始终向你的用户提供反馈。始终通知用户操作、状态和错误的改变或发生的异常。视觉提示或简单消息可以向用户显示他或她的行为是否已导致预期结果。\n\n## Be forgiving\n\n对用户宽容\n\nNo matter how clear your design is, people will make mistakes. Your UI should allow for and tolerate user error. Design ways for users to undo actions, and be forgiving with varied inputs (no one likes to start over because he/she put in the wrong birth date format). Also, if the user does cause an error, use your messaging as a teachable situation by showing what action was wrong, and ensure that she/he knows how to prevent the error from occurring again.\n无论你的设计多么清晰，人们都会犯错误。你的UI应该允许并容忍用户错误。设计用户撤销操作的方式，并对不同的输入进行宽容（没有人希望因为他/她输错了出生日期的格式，就得全部重新输入）。此外，如果用户确实导致错误，请通过显示哪些操作出错来将你的消息传递作为可接受的情况，并确保他/她知道如何防止错误再次发生。\nA great example can be seen in [How to increase signups with easier captchas](http://carsonified.com/blog/design/how-to-increase-sign-ups-with-easier-captchas).\n在[如何使用更简单的验证码增加注册](http://carsonified.com/blog/design/how-to-increase-sign-ups-with-easier-captchas)中可以看到一个很好的例子。\n\n## Empower your user\n\n为你的用户提供支持\n\nOnce a user has become experienced with your interface, reward him/her and take off the training wheels. The breakdown of complex tasks into simple steps will become cumbersome and distracting. Providing more abstract ways, like keyboard shortcuts, to accomplish tasks will allow your design to get out of the way.\n一旦用户熟悉你的界面，奖励他/她并把『辅助轮』取下来（注：就像在学习骑自行车时那样）。将复杂任务分解为简单的步骤将变得麻烦和分散注意力。提供更抽象的方法，如键盘快捷键，来完成任务——这将使你的设计摆脱困境。\n\n## Speak their language\n\n说出他们的语言\n\n> \"If you think every pixel, every icon, every typeface matters, then you also need to believe every letter matters. \" -- [Getting Real](https://basecamp.com/books/getting-real)\n『如果你认为每个像素，每个图标，每个字体都很重要，那么你还需要相信每个字母都很重要。』 —— [Getting Real](https://basecamp.com/books/getting-real)\n\nAll interfaces require some level of copywriting. Keep things conversational, not sensational. Provide clear and concise labels for actions and keep your messaging simple. Your users will appreciate it, because they won't hear you -- they will hear themselves and/or their peers.\n所有接口都需要一定程度的文案。让它们亲切随和，而不是耸人听闻。为操作提供清晰简洁的标签，并使你的消息保持简单。你的用户会很感激，因为他们不会听到你的声音——他们会听到自己和/或他们的同伴的声音。\n\n## Keep it simple\n\n把事情简单化\n\n> \"A modern paradox is that it's simpler to create complex interfaces because it's so complex to simplify them.\" -- Pär Almqvist\n『一个现代悖论是，创建复杂的界面更简单，因为简化这些界面非常复杂。』 —— Pär Almqvist\n\nThe best interface designs are [invisible](http://www.uie.com/articles/experiencedesign). They do not contain UI-bling or unnecessary elements. Instead, the necessary elements are succinct and make sense. Whenever you are thinking about adding a new feature or element to your interface, ask the question, \"Does the user really need this?\" or \"Why does the user want this very clever animated gif?\" Are you adding things because you like or want them? Never let your UI ego steal the show.\n最好的界面设计是[无形](http://www.uie.com/articles/experiencedesign)的。它们不包含UI-bling或不必要的元素。相反，必要的元素是简洁而有意义的。无论何时考虑在界面中添加新功能或元素，都要问『用户真的需要这个吗？』或『为什么用户想要这个巧妙的gif动图？』。你是否只是因为喜欢或想要而添加新东西？永远不要让你的UI自身抢了风头。\n\n## Keep moving forward\n\n不忘初心，继续前进\n\n**Grandpa Bud**: If I gave up every time I failed, I would never have invented my fireproof pants!\n\\[Pants burn up, revealing his underwear\\]\n**Grandpa Bud**: Still working the kinks out a bit.\nfrom [Meet the Robinsons](https://www.imdb.com/title/tt0396555)\n> **巴德爷爷**：如果我每次失败就放弃了，我永远都不会发明我的防火裤！\n\\[裤子烧了，露出他的内衣\\]\n**巴德爷爷**：仍然在努力解决问题。\n来自[拜见罗宾逊一家](https://www.imdb.com/title/tt0396555)\n\n*Meet the Robinsons* is one of my all time favorite movies. Throughout the movie Lewis, the protagonist, is challenged to \"keep moving forward.\" This is a key principle in UI design.\n*拜见罗宾逊一家*是我最喜欢的电影之一。在整个电影中，主角刘易斯面临着『继续前进』的挑战。这是UI设计的关键原则。\nIt is often said when developing interfaces that you need to fail fast, and iterate often. When creating a UI, you *will* make mistakes. Just keep moving forward, and remember to keep your UI out of the way.\n在开发接口时经常会说你需要快速失败，并经常迭代。在创建UI时，你*会*犯错误。继续前进，并记住保持你的UI不受影响。\n\n---\n\n*本文由[Kyle Sollenberger](https://twitter.com/kyle)撰写。*\n*This article was written by [Kyle Sollenberger](https://twitter.com/kyle).*\n\n本文翻译自：[10 User Interface Design Fundamentals](https://blog.teamtreehouse.com/10-user-interface-design-fundamentals)\n","categories":["Web开发"]},{"title":"手机淘宝的flexible方案","url":"/2018-09/手机淘宝的flexible方案/","content":"\n## 前言\n\n手机淘宝从2014年中开始，全面推行flexible设计。什么叫flexible呢？其实flexible就是responsive的低端形态和基础。对我们来说，最直观的感受就是，在超宽屏幕上，网页显示不会两边留白。以前pc时代大家经常讲的流体布局，其实就是一种flexible design。只不过，流体的表述角度是实现，flexible的表述角度是结果，为了跟高大上的responsive保持一致，我们这里使用了flexible这个说法。\n讨论方案之前，需要先了解三个关键概念：\n- 单位英寸像素数（Pixel Per Inch，PPI）：现实世界的一英寸内像素数，决定了屏幕的显示质量\n- 设备像素比率（Device Pixel Ratio，DPR）：物理像素与逻辑像素（px）的对应关系\n- 分辨率（Resolution）：屏幕区域的宽高所占像素数\n\n当我们决定不同屏幕的字体和尺寸的单位时，屏幕的这几个参数非常重要。\n\n## Resolution适配\n\n一张banner图片，当你面对不同的屏幕时你希望它的行为是怎样的？\n在这个场景中，我们主要需要面对的是分辨率适配问题，考虑到多数网页都是纵向滚动的，在不同的屏幕尺寸下，banner的行为应该是总是铺满屏幕宽度以及总是保持宽高比。\n最自然的思路是使用百分比宽度，但是假如使用百分比宽度，即width:100%，我们又有两种思路来实现固定宽高比：一是利用img标签的特性，只设宽度等图片加载完，这种方法会导致大量的重排，并且非固定高度会导致懒加载等功能难以实现，所以果断放弃；二是使用before伪元素的margin撑开高度，这种方法是比较干净的纯css实现，但是不具备任何复用性而且要求特定html结构，所以也只好放弃了。\n于是，剩下最合适的办法是使用其它相对单位，本来最合适的单位是vw，它的含义是视口宽度，但是这个单位存在严重的兼容问题，所以也只好放弃。\n最后我们只好配合js来做，硬算也是一条路，但是同样不具备任何可复用性，最终我们选择了rem，我们用js给html设置一个跟屏幕宽度成正比的font-size，然后把元素宽高都用rem作为单位。\n这是我们目前的线上方案了，它是一个近乎Hack的用法，已知的问题包括：\n- 某些Android机型会丢掉rem小数部分\n- 占用了rem单位\n- 不是纯css方案\n\n## PPI适配\n\n一段文字，当你面对不同的屏幕时你希望它的行为是怎样的？\n显然，我们在iPhone3G和iPhone4的Retina屏下面，希望看到的文字尺寸是相同的，也就是说，我们不希望文字在Retina屏尺寸变小，此外，我们在大屏手机上，希望看到更多文字，以及，现在绝大多数的字体文件，是自带一些点阵尺寸的，通常是16px和24px，所以我们不希望出现13px、15px这样的奇葩尺寸。\n这样的特征决定了，场景1中的rem方案，不适合用到段落文字上。所以段落文字应该使用px作为单位，考虑到Retina，我们利用media query来指定不同的字体，考虑到dpr判定的兼容性，我们用宽度替换来代替：\n```css\n.a {\n    font-size: 12px;\n}\n@media (min-width: 401px) {\n    .a {\n        font-size: 24px;\n    }\n}\n```\n另一种场景，一些标题性文字，希望随着屏幕宽而增大的，我们可以仍然使用rem作为单位。超过35px（个人直观感受）的文字，已经不用太考虑点阵信息了，靠字体的矢量信息也能渲染的很好。\n\n## DPR匹配\n\n一个区块，设计稿上有1像素边框，当你面对不同的屏幕时你希望它的行为是怎样的？\n这个场景，需求很简单，设计师希望在任何屏幕上这条线都是1物理像素。\n好吧，当然这个问题的答案不是写1px那么简单。在retina屏下面，如果你写了这样的meta：\n```xml\n<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n```\n你将永远无法写出1px宽度的东西，除此之外，inline的SVG等元素，也会按照逻辑像素来渲染，整个页面的清晰度会打折。\n所以，手机淘宝用JS来动态写meta标签，代码类似这样：\n```javascript\nvar metaEl = document.createElement('meta');\nvar scale = isRetina ? 0.5 : 1;\nmetaEl.setAttribute('name', 'viewport');\nmetaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\nif (document.documentElement.firstElementChild) {\n    document.documentElement.firstElementChild.appendChild(metaEl);\n}\nelse {\n    var wrap = document.createElement('div');\n    wrap.appendChild(metaEl);\n    document.write(wrap.innerHTML);\n}\n```\n\n## 结语\n\n总的来说，手机淘宝的flexible方案是综合运用rem和px两种单位+js设置scale和html字体。\n这些JS的内容，可以在我们开源的库[ml](https://github.com/amfe/ml)中找到，也可以参考[lib-flexible](https://github.com/amfe/lib-flexible)。\n\n---\n\n参考文章：\n[手机淘宝的flexible设计与实现](http://www.html-js.com/article/2402)\n[关于webapp中的文字单位的一些捣腾](http://www.html-js.com/article/2400)\n","tags":["HTML","CSS"],"categories":["Web开发"]},{"title":"JavaScript的函数调用与this","url":"/2018-08/JavaScript的函数调用与this/","content":"\nJavaScript函数有4种调用方式。每种方式的不同方式在于this的初始化。对this关键字有解释：*一般而言，在JavaScript中，this指向函数执行时的当前对象。*注意this是保留关键字，你不能修改this的值。\n\n## 作为一个函数调用\n\n先看一个最简单的实例，在浏览器中：\n```javascript\nfunction myFunction() {\n    return this;\n}\nalert(myFunction()); // [object Window]\n```\n而当函数没有被自身的对象调用时，this的值就会变成全局对象。在Web浏览器中全局对象是浏览器窗口（window 对象）。该实例返回this的值是window对象。也就是此函数即为window对象的函数，`myFunction()`等同于`window.myFunction()`。但是此处在使用内部函数时存在一个this指向的问题，看下面的例子：\n```javascript\n// 注意此处在node环境和浏览器环境下值不同,\n// node环境下必须去掉var使value成为全局变量。\nvalue = 4;\n\nvar myObject = {\n    value: 1,\n    double: function () {\n        //var that = this;\n        var helper = function () {\n            this.value = add(this.value, this.value);\n        };\n        helper();\n    }\n};\n\nfunction add(a, b) {\n  return a + b;\n}\n\nmyObject.double();\nalert(value); // 8\nalert(myObject.value); // 1\n```\n在这里的myObject对象中，我们在double这个函数中使用了内部函数并赋值给helper，**但是此处的this.value的this指向了全局对象**，所以在执行这个函数后全局变量value的值变了但Object中的value属性值仍然是1，这不是我们想要的结果。《js语言精粹》中指出这里是语言设计上的一个错误，this应该仍然绑定到外部函数的this变量中。这个设计错误的后果就是方法不能利用内部函数来帮助它工作，因为内部函数的this被绑定了错误的值，所以不能共享该方法对对象的访问权。但是我们可以有一个很容易的解决方案去解决这个问题，对myObject进行修改：\n```javascript\nvar myObject = {\n    value: 1,\n    double: function () {\n        var that = this;\n        var helper = function () {\n            that.value = add(that.value, that.value);\n        };\n        helper();\n    }\n};\n\nmyObject.double();\nalert(value); // 4\nalert(myObject.value); // 2\n```\n这里使用了一个that变量来指向double方法中this的值即myObject本身，这样就可以对myObject对象的属性value进行修改。\n\n## 函数作为方法调用\n\n这种方式即为，一个函数被保存为一个对象的属性，在此时此函数被成为一个方法。调用时this关键字被绑定到该对象，即：**函数作为对象方法调用，会使得this的值成为对象本身。**实例如下：\n```javascript\nvar myObject = {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    fullName: function() {\n        return this.firstName + \" \" + this.lastName;\n    }\n}\nmyObject.fullName(); //返回 \"John Doe\"\n```\n另一个例子：\n```javascript\nvar myObject = {\n    value: 0,\n    increment: function (inc) {\n        this.value += typeof inc === 'number' ? inc : 1;\n    }\n};\n\nmyObject.increment();\nconsole.log(myObject.value); // 1\n\nmyObject.increment(2);\nconsole.log(myObject.value); // 3\n```\n在此例中，increment方法对myObject对象中的value属性进行增加操作，increment函数中的this即指向myObject对象本身。\n\n<!-- more -->\n## 构造器调用模式\n\n如果函数调用前使用了new关键字，则是调用了构造函数。这看起来就像创建了新的函数，但实际上JavaScript函数是重新创建的对象：\n```javascript\n// 构造函数\nfunction myFunction(arg1, arg2) {\n    this.firstName = arg1;\n    this.lastName = arg2;\n}\n// This creates a new object\nvar x = new myFunction(\"John\", \"Doe\");\nx.firstName; //返回 \"John\"\n```\n构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法。\n构造函数中this关键字没有任何的值。this的值在函数调用时实例化对象(new object)时创建。\n\n看另一个例子：\n```javascript\nvar Quo = function (string) {\n    this.status = string;\n};\n\nQuo.prototype.get_status = function () {\n    return this.status;\n};\n\nvar myQuo = new Quo(\"confused\");\nconsole.log(myQuo.get_status()); // confused\n```\n输出结果为confused。在这里使用new来调用时，会创建一个连接到该函数的prototype成员的新对象，同时this会被绑定到这个新对象上。即此时我们创建了myQuo对象，其连接到了Quo的prototype，且创建时的`this.status = string;`中的this指向这个创建的新对象，status为新对象myQuo的属性，而不是Quo函数prototype的属性，可以做如下验证：\n```javascript\nconsole.log(myQuo.hasOwnProperty(\"status\")); //true\n```\n作为对比，我们对Quo函数增加一个属性id：\n```javascript\nvar Quo = function (string) {\n    this.status = string;\n};\nQuo.prototype.id = 1;\n```\nid为Quo构造器函数prototype对象的一个属性，然后再次进行测试：\n```javascript\nvar myQuo = new Quo(\"confused\");\nconsole.log(myQuo.id); //1\nconsole.log(myQuo.hasOwnProperty(\"get_status\")); //false\nconsole.log(myQuo.hasOwnProperty(\"id\")); //false\n```\n这里可以看到在创建新对象myQuo时没有id属性和get_status函数，而这里myQuo继承了Quo的id属性，就通过原型链找到了Quo.prototype.id的值。\n\n## Apply调用模式\n\n在JavaScript中，函数是对象。JavaScript函数有它的属性和方法，`call()`和`apply()`就是预定义的函数方法。这两个方法可用于调用函数。\n对于`apply`：\n- 在JavaScript严格模式(strict mode)下，在调用函数时第一个参数会成为this的值，即使该参数不是一个对象。\n- 在JavaScript非严格模式(non-strict mode)下，如果第一个参数的值是null或undefined，它将使用全局对象替代。\n\n```javascript\nfunction myFunction(a, b) {\n    return a * b;\n}\nmyFunction.call(myFunction, 10, 2); //返回20\n\nmyArray = [10,3];\nmyFunction.apply(null, myArray); //返回30\n```\n可见两者的区别在于第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。\n另外一个结合前面定义的Quo构造器调用模式使用的例子：\n```javascript\nvar statusObject = {\n    status: 'A-OK'\n};\nvar status = Quo.prototype.get_status.apply(statusObject);\nconsole.log(status); // A-OK\n```\n在这里即使用了apply并将statusObject作为get_status的this，结果即为A-OK。\n\n以上即为四种函数的调用方法。\n\n---\n\n参考文章：\n[Javascript的函数调用与this](https://juejin.im/post/5a17c21bf265da43346f997e)\n[JavaScript 函数调用](https://www.runoob.com/js/js-function-invocation.html)\n\n拓展阅读：\n闭包深入：[让你分分钟理解 JavaScript 闭包](https://www.cnblogs.com/onepixel/p/5062456.html)\n[一道 javascript 面试题求教 - V2EX](https://www.v2ex.com/t/572816)\n","tags":["JavaScript"],"categories":["Web开发"]},{"title":"入手信达小黑天文望远镜","url":"/2018-08/入手信达小黑天文望远镜/","content":"\n2018年的暑期，诸多天文奇观轮番上演：火星冲日、日偏食、英仙座流星雨，这对天文爱好者来说是绝佳的观测机会。在好基友的怂恿下，博主也正式踏入了天文摄影的巨坑。\n博主在小学时曾拥有一台700/60入门级伽利略式天文望远镜，但是其使用的经纬仪是纯手动的，调节精度较差；且望远镜本身存在明显的色差，成像效果不佳。为了满足行星摄影的要求，需要入手一台更为可靠的天文望远镜。目前市面上常见的天文望远镜，一般由三部分组成：三脚架（底座），赤道仪（经纬仪），以及望远镜镜筒。镜筒主体根据成像原理划分，有牛顿反射式、马克苏托夫-卡塞格林式和复消色差（APO）式等等。基于其他成像原理的望远镜也能在市面上买到，不过从销量和评价上来看，前文提到的这三种望远镜占主流。在查阅了大量资料，并参考了天文相关贴吧、论坛后，博主决定入手信达小黑天文望远镜。这是一款入门级牛顿反射式望远镜，其焦距750mm，口径150mm，等效光圈较大，适合摄影；赤道仪采用EQ3D，搭配双轴电跟，在通过北极星校准极轴后，即可进行长时间曝光。\n这是望远镜组装完成的状态：\n\n![](/images/2018-08/IMG_0272.jpg)\n\n安装EF卡口转接环，就可以连接单反相机了：\n\n![](/images/2018-08/IMG_0199.jpg)\n\n8月11日拍摄的日偏食：\n\n![](/images/2018-08/IMG_5639.jpg)\n\n由于望远镜自带的巴罗镜只适用于目镜，为了增加拍照的放大率，博主还购买了一个EF卡口的增倍镜。这是使用增倍镜后拍摄的月球：\n\n![](/images/2018-08/IMG_5767.jpg)\n\n由于视宁度不佳（以及可能的对焦问题），虽然也成功拍摄了土星，但是土星环的辨识度较差：\n\n![](/images/2018-08/IMG_5758.jpg)\n\n仙后座（以及划过天空的飞机航行灯）：\n\n![](/images/2018-08/IMG_5680.jpg)\n\n---\n\n本文更新于2018年9月28日：\n与学校的青年天文爱好者协会部分（矿里有家的）前辈交流后，发现EQ3D赤道仪和双轴电跟仍有许多不足，可能并不是天文摄影的入门首选。如果有足够多的预算，可以购买NEQ6搭配GOTO，该赤道仪的稳定性与鲁棒性都更胜一筹（当然价格也略高）。\n","tags":["天文","摄影"],"categories":["物理"]},{"title":"膜法大赛预赛","url":"/2018-08/膜法大赛预赛/","content":"\n{% pdf /files/膜法大赛预赛.pdf %}\n","categories":["其他"]},{"title":"自己打造一台恩尼格玛密码机","url":"/2018-08/自己打造一台恩尼格玛密码机/","content":"\n![](/images/2018-08/F5YSP9KHMF6R1PD.LARGE.jpg)\n\n在对称加密学当中，恩尼格玛机绝对是承前启后的存在。它将密码学研究从以前的语言文字学中心完全转移到了数学身上。在这里牵涉的密码并不是我们平时邮箱、银行帐号那种狭义概念，那种顶多叫做口令。这里说的密码就是通过某种映射方式，把一篇文章变得面目全非，以达到保密效果；只有特定的转换规律才能将其解密。这篇文章适于电脑控、军事控、历史控、数学控阅读，请做好烧脑准备。\n\nEDIT: This Instructable has won Second prize in the 2013 Radio Shack Microcontroller Contest. Thank You to all who voted!\n按：这个作品是2013年无线电单片机竞赛的亚军。感谢所有支持这个作品的你们！\nEDIT2: An Open Enigma with fake Standup Nixie Tubes like the ones pictured in this Instructable will soon be available as a Special Kickstarter edition.\n\nThis is our very first Instructable and this step by step guide will show you how to build a fully functional electronic replica of the world famous German Enigma machine. This Arduino based Open Source project is able to encrypt & decrypt any Enigma M4 encoded message.\n这是我们的初号机。以下教程将手把手教你如何完美复刻史上著名的德国恩尼格玛密码机。这个基于Arduino的开源程序能够加解密任何Enigma机M4型（海军型）的信息。\nThis first ever fully functional Open Source Enigma \"exact\" Replica was inspired by the Kid's Game to Arduino Enigma Machine by sketchsk3tch.\n这个第一台全功能开源完美Enigma机复制品是根据sketchsk3tch写的《Kid's Game to Arduino Enigma Machine（从儿童玩具到Arduino恩尼格玛机）》所作。\nUsing Multiplexing for the LEDs, this circuit with 115 light emitting diodes uses only 38 pins and the 36 push buttons use only 4 pins total thanks to properly placed resistors (and the P-Channel MOSFETs) in the keyboard loop. These 4 16-Segment displays & an LED for each keyboard button would add up quickly the total number of pins required and even the Arduino Mega would have ran out of pins without the 2 methods mentioned above....\n采用多路复用LED电路，仅用38个针脚的115个发光二极管和4个针脚的36个按键所连接的整个电路，全靠在键盘回路里准确放置的电阻以及P沟道场效应晶体管得以实现。要不然，4个16段显示器，以及每个按键上的LED将大幅增加所需针脚总量——即使用了Arduino Mega板，但如果没用上述两个方法，电路也不能如此简洁。\nIn response to the overwhelming demand, we designed the PCB and made it available through www.stgeotronics.com. Skip to Step 10 & beyond for more info. We also offer it as a complete electronics kit & an assembled & tested complete product.\n面对电路的超额需求，我们在 http://www.stgeotronics.com 设计了专用的PCB板。直接跳到第10步和以后的步骤可以找到更多信息。同时，我们也发布了测试过的完整电子组装套装。\n\n## Step 1: Proof of Concept on Breadboard\n\n第一步：面包板上的论证\n\n![](/images/2018-08/F3ULXLHHMEXSREA.LARGE.jpg)\n![](/images/2018-08/FQHGSW5HMF6R1XF.LARGE.jpg)\n\nBefore going all out on the development of this electronic Enigma replica, we wanted to make sure we could properly drive the 16 Segment LEDs. If we can do that, than we will be able to do everything as the rest is only Math...\n在开始制作电子Enigma机之前，我们先要确保能驱动16段LED显示。如果成功，我们就能做接下来的所有步骤——除了数学上的问题，一切都是浮云。\n\n<!-- more -->\n## Step 2: Gather the Raw Materials...\n\n第二步：万事具备\n\n![](/images/2018-08/FCU4XAXHMEXSQH3.LARGE.jpg)\n\nYou will need:\n- 1 Arduino Mega\n- 26 Alpha Buttons\n- 26 1/4\" Jacks Mono\n- 10 1/4\" Plugs Mono\n- 36 Pushbuttons\n- 1 On/Off/On Switch\n- 4 16Segment Orange\n- 4 Injection molded 2-Liter Soda Bottle preform (test tubes)\n- 1 Case Plywood\n- 1 Hinge & Hooks\n- 1 Half-Mortise Lock\n- 1 Perfboard\n- 38 Resistors 470 Ohms\n- 40 Resistors 1K Ohms\n- 7 IRF9Z24N P-Channel MOSFET\n- 1 Piece of Metal & Spray paint\n\n你所需要的是：\n- 1个Arduino Mega 2560板\n- 26个字母按键\n- 26个1/4英寸单通道母接口\n- 10个1/4英寸单通道公接口\n- 36个机械按钮\n- 1个单刀三掷开关\n- 4个16段橙色LED显示\n- 4个注塑2升汽水瓶罩子\n- 1个胶合板盒子\n- 一个铰链\n- 一个半榫接锁\n- 一个接线盘\n- 38个470欧电阻\n- 40个1千欧电阻\n- 7个IRF9Z24N P沟道场效应晶体管\n- 1块金属片以及喷漆。\n\nOptional:\n- Battery Case\n- Rechargeable Batteries\n- Battery Charger/Connectors\n\n可选项：\n- 电池盒\n- 充电电池\n- 充电器/充电接头\n\nIf we were to do it again, we wouldn't use 1/4\" Jacks & Plugs as these are pretty big and tend to overwhelm the whole Enigma. Banana plugs & jacks are smaller & closer to the original connectors used by the real German Enigmas.\n我们真要做的时候，是不会用1/4英寸接口的。它们太大的体积几乎要超过整个恩尼格玛机。香蕉插头体积较小，而且比原版德国Enigma机结合得更紧密些。\n\n## Step 3: Lay the Components Down\n\n第三步：布置零件\n\n![](/images/2018-08/FVPK1ITHMEXSQHU.LARGE.jpg)\n![](/images/2018-08/FG3UNNCHMEXWMFY.LARGE.jpg)\n![](/images/2018-08/F177H22HM8CXMUF.LARGE.jpg)\n![](/images/2018-08/F5QWPPFHMFQJEKZ.LARGE.jpg)\n![](/images/2018-08/FJ4B8MDHM8CVVF4.LARGE.jpg)\n![](/images/2018-08/FSSAE2EHM8CVVF3.LARGE.jpg)\n\nThe Radio Shack 6\" x 8\" Micro Perboard is the perfect size to host all components as it provides just the right amount of space to fit everything on & will fit perfectly inside the Enigma box.\n6\\*8寸无线电面包版是最适合放置所有元件的，既不多余也不拥挤，而且和Enigma机盒子内部完美吻合。\nWe started dividing the space on the Perfboard equally between the 3 regions, but realized soon that this would make the electonic Enigma longer than the real one, so we compressed everything down to the proper spacing.\n最初我们将面包板等分为三块区域，但很快意识到，如此一来，电子版Enigma机将比原版的机械Enigma机长。于是我们将所有零件缩放到正好够占用的空间。\nOnce satisfied with the positioning of each components, next step is soldering.\n每个元件位置就绪，下一步就是焊接。\n\n## Step 4: Soldering, Soldering & a Little More Soldering\n\n第四步：我焊，我焊，我焊焊焊……\n\n![](/images/2018-08/FL8IEWNHMFQJENI.LARGE.jpg)\n![](/images/2018-08/F1UE3SZHMFQJENK.LARGE.jpg)\n![](/images/2018-08/F5B1IDKHM8D0839.LARGE.jpg)\n![](/images/2018-08/FCJKFP3HMEXWMPC.LARGE.jpg)\n![](/images/2018-08/FB9KU3WHM8CXMUR.LARGE.jpg)\n![](/images/2018-08/F6ZOVZKHMF6R1YM.LARGE.jpg)\n\nOK, this proved to be the most solder I have used on a single project ever. With 18 pins per 16 Segment, times 4 plus 26 keyboard keys + 26 keyboard lamps + a few LEDs & 1 SPDT on/off/on switch, that was a lot of solder.\n好吧，在单一作品身上，我从没焊接如此多次。16段显示的18个针脚，还有26个字母键乘以每个4个脚，外加26个键盘灯，一些其他LED，一个三掷开关，真乃『成吉思焊』。\nOur decision to raise the 16 Segment displays up to make them look like old-time Nixie tubes certainly added a lot of solder points!\n当初我们的决定是使这些16段LED显示看起来像老式电子管的感觉，增加了不少焊点，『巨焊』！\nOur Arduino Mega Pin assignment:\nArduino Mega板上针脚的分配：\n\n17 Segments:\nSeg Pin Wire DuinoPin\na   2   blue  24\nb   1   white 22\nc   16  wh-bl 25\nd   13  green 31\ne   9   wh-br 38\nf   8   brown 36\ng   6   green 32\nh   5   wh-or 30\nk   4   orang 28\nm   3   wh-bl 26\nn   17  blue  23\np   15  orang 27\nr   12  wh-gr 33\ns   11  brown 35\nt   7   wh-gr 34\nu   14  wh-or 29\ndp  10  wh-br 37\nanode1 18 red 39\nanode2 18 red 41\nanode3 18 red 43\nanode4 18 red 45\n\nLEDs:\n1  40\n2  42\n3  44\n4  46\n5  48\n\nLamps:\nQAP 10\nWSY 9\nEDX 8\nRFC 7\nTGV 6\nZHB 5\nUJN 4\nIKM 3\nOL  2\nanode1 (First Row)  11\nanode2 (Second Row) 12\nanode3 (Third Row)  13\n\nFunction Keys:\nA0\n\nKeyboard:\nFirst Row A1\nSecond Row A2\nThird Row A3\n\n## Step 5: Make a Box and Cut & Drill the Top Plate.\n\n第五步：门面工夫——做个盒子钻出面板\n\n![](/images/2018-08/FDK4HNYHMF6R1Z8.LARGE.jpg)\n![](/images/2018-08/FDHCE6MHM8CXMUW.LARGE.jpg)\n![](/images/2018-08/FOTHEI2HM8D527O.LARGE.jpg)\n![](/images/2018-08/FNLRDOJHMEXWMW4.LARGE.jpg)\n\nAfter obtaining the exact dimensions of the original M4 wooden box, we purchased a sheet of plywood & cut it in pieces so we could assemble our case.\n在原版M4型木盒内得到确定位置数据后，我们买了一块胶合板，将它切块，然后砌盒子。\nWe decided to cut a steel plate from an obsolete rack mounted server as it had just the right thickness of metal for our needs. After making a transparency that showed where every button/lamp was located & cutting it out, we were able to superimpose it on the metal piece and draw each required hole with a sharpie.\n我们从旧服务器机架上卸了一块钢板，厚度正合需要。将模具（上面早已画好每个按键和灯位，并切好了洞洞）盖在钢板上，然后用记号笔画出需要切出的洞洞。\nWe then spray painted it textured black to look like the real Enigma.\n接着，我们用喷漆把它涂黑，就像真的Enigma机那样。\n\n## Step 6: Integration Tests\n\n第六步：组装测试\n\n![](/images/2018-08/F9FF43UHMEXWN47.LARGE.jpg)\n![](/images/2018-08/FIITQ0JHM8D083S.LARGE.jpg)\n![](/images/2018-08/F7CENKBHM8D8Z2S.LARGE.jpg)\n![](/images/2018-08/FB7E7EEHM8CVVHM.LARGE.jpg)\n![](/images/2018-08/FHT2F7HHM8D8Z2M.LARGE.jpg)\n![](/images/2018-08/FGQWASPHMFQJERA.LARGE.jpg)\n![](/images/2018-08/FIPCQX8HM8CVVHJ.LARGE.jpg)\n\nFirst is the permanent fitting of the metal plate on top of the perfboard making sure every button is working and every LED can shine.\n首先把金属板在面包版上永久固定，确保所有按键正常工作，所有LED都能发光。\nThen is the fitting of this solid assembly into the wooden case ensuring we didn't introduce a short anywhere.\n接着就是把这一大坨东东装入木盒，确保没有空隙位置。\n\n## Step 7: Software - Ohhhh.... Ouch!\n\n第七步：软件啊，日完软啊！\n\n![](/images/2018-08/FFJ9BVGHMEXSRM6.LARGE.jpg)\n![](/images/2018-08/FHM5VLKHM8D6Q8D.LARGE.jpg)\n\nDuring each hardware assembly phase, we had created small Arduino sketches that would test the specific individual section we were working on:\n在组装硬件过程中，我们也写了个小型Arduino程序框架，用以测试特定几个需要关注的部分：\nA code that tests that each keyboard button is read accurately.\nA second code that tests each of the 10 function buttons.\n用来测试每个按键信号能准确读取，还有测试10个功能按键的代码。\nAn Enigma_POST (Power On Self Test) sketch that tests that each keyboard lamp can be lit precisely and move each LED through each mode, with some modifications to the original breadboard code to ensure each segment of the 4 16-Segment LEDs is working perfectly.\nEnigma_POST（上电自检）确保在每种模式下所有键盘等都能准确亮起，在每种模式下每个LED信号都能传送。我们对原本面包板上的代码做了修正，确保4个16段LED显示的每个部件无懈可击。\nBut, even with all these sample codes on hand that tested every piece of hardware on the machine, the task of reproducing the encrypting/decrypting functionality of a real M4 Enigma was a Mathematics tour-de-force!\n但，即使所有手上的程序片段都说明机器状态完好，重现M4海军型Enigma机加解密功能，数学方面居功至伟。\nAll Arduino sketches will be available on our Github that we are currently setting up.\n所有的Arduino程序片段即将在我们刚刚建好的[Github组织](https://github.com/ST-Geotronics)中发布。\nHere is the Enigma_POST sketch:\n以下是Enigma_POST程序片段（上电自检）：\n```c\n/* Enigma Development Code to Test each of the 4 Nixies, the 5 LEDs,\n   then Turn On each Lamp in sequence.\n   Written by Marc Tessier & James Sanderson 9/8/13\n*/\n\n// Define the 16-Segments Pins\nint segment[17] = { 24,22,25,31,38,36,32,30,28,26,23,27,33,35,34,29,37 };\nint anode[4] = { 39,41,43,45 };\n\n// Define the 9 lamps Pins\nint lamp[9] = { 10,9,8,7,6,5,4,3,2 };\nint lanode[3] = { 11,12,13 };\n\n// LTP587P Segments: A,B,C,D,E,F,G,H,K,M,N,P,R,S,T,U,dp              \nboolean segmentvals[39][17] = {\n    { 0,0,0,0,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = A\n    { 0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1 }, // = B\n    { 0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = C\n    { 0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1 }, // = D\n    { 0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = E\n    { 0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = F\n    { 0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1 }, // = G\n    { 1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = H\n    { 0,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1 }, // = I\n    { 1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1 }, // = J\n    { 1,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,1 }, // = K\n    { 1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = L\n    { 1,1,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1 }, // = M\n    { 1,1,0,0,1,1,0,0,0,1,1,1,0,1,1,1,1 }, // = N\n    { 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = O\n    { 0,0,0,1,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = P\n    { 0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1 }, // = Q\n    { 0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,0,1 }, // = R\n    { 0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = S\n    { 0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1 }, // = T\n    { 1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = U\n    { 1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1 }, // = V\n    { 1,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1 }, // = W\n    { 1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1 }, // = X\n    { 1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1 }, // = Y\n    { 0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1 }, // = Z\n    { 0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1 }, // = 0\n    { 1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1 }, // = 1\n    { 0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1 }, // = 2\n    { 0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1 }, // = 3\n    { 1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1 }, // = 4\n    { 0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = 5\n    { 0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = 6\n    { 0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1 }, // = 7\n    { 0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = 8\n    { 0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = 9\n    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, // = Space\n    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, // = Full Lit\n    { 1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1 }  // = SS\n};\n// LTP587P Segments: A,B,C,D,E,F,G,H,K,M,N,P,R,S,T,U,dp\n\nboolean lampvals[9][9] = {\n    { 0,1,1,1,1,1,1,1,1 }, // = Q or A or P\n    { 1,0,1,1,1,1,1,1,1 }, // = W or S or Y\n    { 1,1,0,1,1,1,1,1,1 }, // = E or D or X\n    { 1,1,1,0,1,1,1,1,1 }, // = R or F or C\n    { 1,1,1,1,0,1,1,1,1 }, // = T or G or V\n    { 1,1,1,1,1,0,1,1,1 }, // = Z or H or B\n    { 1,1,1,1,1,1,0,1,1 }, // = U or J or N\n    { 1,1,1,1,1,1,1,0,1 }, // = I or K or M\n    { 1,1,1,1,1,1,1,1,0 }  // = O or L\n};\n\nint value_row1 = 0;\nint value_row2 = 0;\nint value_row3 = 0;\nchar key = 91;\n\nint led1 = 40;\nint led2 = 42;\nint led3 = 44;\nint led4 = 46;\nint led5 = 48;\nint wait = 100;\n\nvoid setup() {\n    for (int index = 0; index <= 3; index++) {\n        pinMode(anode[index], OUTPUT);\n        digitalWrite(anode[index], 1);\n    }\n    for (int index = 0; index <= 16; index++) {\n        pinMode(segment[index], OUTPUT);\n        digitalWrite(segment[index], 1);\n    } \n    // initialize the digital pins as an output.\n    pinMode(led1, OUTPUT);\n    pinMode(led2, OUTPUT);\n    pinMode(led3, OUTPUT);\n    pinMode(led4, OUTPUT);\n    pinMode(led5, OUTPUT);\n    for (int index = 0; index <= 2; index++) {\n        pinMode (lanode[index], OUTPUT);\n        digitalWrite (lanode[index], 1);\n    }\n    for (int index = 0; index <= 8; index++) {\n        pinMode(lamp[index], OUTPUT);\n        digitalWrite(lamp[index], 1);\n    }\n}\n\nvoid loop() {\n    sixteenSegWrite(0, 38);\n    sixteenSegWrite(1, 38);\n    sixteenSegWrite(2, 38);\n    sixteenSegWrite(3, 38);\n\n    digitalWrite(led1, HIGH); // turn the LED on (HIGH is the voltage level)\n    delay(200);               // wait for a second\n    digitalWrite(led1, LOW);  // turn the LED off by making the voltage LOW\n    delay(wait);              // wait for a second\n    digitalWrite(led2, HIGH); // turn the LED on (HIGH is the voltage level)\n    delay(200);               // wait for a second\n    digitalWrite(led2, LOW);  // turn the LED off by making the voltage LOW\n    delay(wait);              // wait for a second\n    digitalWrite(led3, HIGH); // turn the LED on (HIGH is the voltage level)\n    delay(200);               // wait for a second\n    digitalWrite(led3, LOW);  // turn the LED off by making the voltage LOW\n    delay(wait);              // wait for a second\n    digitalWrite(led4, HIGH); // turn the LED on (HIGH is the voltage level)\n    delay(200);               // wait for a second\n    digitalWrite(led4, LOW);  // turn the LED off by making the voltage LOW\n    delay(wait);              // wait for a second\n    digitalWrite(led5, HIGH); // turn the LED on (HIGH is the voltage level)\n    delay(200);               // wait for a second\n    digitalWrite(led5, LOW);  // turn the LED off by making the voltage LOW\n    delay(wait);              // wait for a second\n\n    for (int index = 0; index <= 2; index++) {\n        digitalWrite(lanode[index], 0);\n        for (int mychar = 0; mychar < 9; mychar++) {\n            for (int sindex = 0; sindex < 9; sindex++) {\n                digitalWrite(lamp[sindex], lampvals[mychar][sindex]);\n                delay(30);\n            }\n        }\n        digitalWrite(lanode[index], 1);\n    }\n}\n\nvoid sixteenSegWrite(int digit, int character) {\n    digitalWrite(anode[digit],0);\n    for (int index = 0; index < 17; index++) {\n        digitalWrite(segment[index], segmentvals[character][index]);\n    }\n}\n```\n\n## Step 8: More Software!\n\n第八步：再多一些软件！\n\n![](/images/2018-08/FE72PL9HMFQJEWD.LARGE.jpg)\n![](/images/2018-08/FV4474FHMF6R23U.LARGE.jpg)\n![](/images/2018-08/F0WOJNDHM8D085H.LARGE.jpg)\n![](/images/2018-08/FNWA7V2HMEXWNHT.LARGE.jpg)\n![](/images/2018-08/FXVDU5LHMEXSRP2.LARGE.jpg)\n![](/images/2018-08/FEM6HKTHMF6R23W.LARGE.jpg)\n![](/images/2018-08/F0LV9DXHMFQJEWH.LARGE.jpg)\n![](/images/2018-08/F3FLAQIHMF6R23V.LARGE.jpg)\n![](/images/2018-08/FS9DTJ4HMEXSROL.LARGE.jpg)\n\nSo we first created a function for each mode the Enigma operates in:\n首先，我们写了个函数，给每个Enigma机工作模式用。\nIn Mode 0, Default Mode, the Enigma is nothing but a simple typewriter with a Marquee that displays its Model Number.\n在模式0、默认模式，Enigma机仅仅是一台普通打字机，以跑马灯方式显示它的型号。\nMode 1 allows the user to select the 3 (out of 8) Rotors he will use along with which one (of the 2) Reflector he wants to use.\n模式1下，允许用户从八个转子中选取三个，两个反射器中选择一个进行使用。\nIn Mode 2, the user can select the Internal position of each Rotor.\n模式2下，允许用户排列转子次序。\nMode 3 is used to specify the starting (external) position of each Rotor.\n模式3用于自定义转子初始字母排列。\nIn Mode 4, a user can enter up to 10 Swapped pairs of letters.\n选择模式4，用户最多可以使用接线板上10对交换字母排列。\nMode 5 is Run mode and at that point, the Enigma will encrypt or decrypt any letter typed on the keyboard.\n模式5是运行模式，此时Enigma机能加解密任何从键盘录入的信息。\nHere is the Complete sketch that runs the whole Enigma:\n以下是整个Enigma机工作流程完整程序片段：\n```c\n/* S&T GeoTronics Enigma Code. This Arduino Mega custom shield is programmed to replicate\n   exactly the behavior of a true German M4 Enigma machine.\n   It uses 4 16-Segment units, 5 LEDs, 26 Lamps setup as keyboard, 26 keyboard buttons\n   & 10 Function keys. The 115 light emitting diodes are charlie-plexed to minimize the\n   amount of pins needed down to 38 and all 36 pushbuttons keys are sharing a total of 4 pins.\n   Designed, assembled & programmed by Marc Tessier & James Sanderson 9/20/13\n*/\n// Define the variables\nunsigned long time = millis();\nunsigned long otime = time;\nint inpin[4] = { A0, A1, A2, A3 };\nint inval[4] = { 0, 0, 0, 0 };\nint keyval = 100;\nboolean windex = 0;\nboolean windex1 = 0;\nboolean windex2 = 0;\nint lampval = 100;\nint procesval = 0;\nint procesvala = 0;\nint mode = 0;\nunsigned long mtime;\nint mdex = 0;\n\n// Define each Nixie character\nint dig1 = 37;\nint dig2 = 37;\nint dig3 = 37;\nint dig4 = 37;\n\nint data[36] = { 36,36,36,36,18,39,19,36,6,4,14,19,17,14,13,8,2,18,36,4,13,8,6,12,0,36,12,0,17,10,36,30,36,36,36,36 };\n\n// Define the 16-Segments Pins as 2 Arrays\nint segment[17] = { 24,22,25,31,38,36,32,30,28,26,23,27,33,35,34,29,37 }; //cathode array\nint anode[4] = { 39,41,43,45 }; //annode array commin annode\n\n// Define the 26 Lamps as a 2D Array\nint lamparray[26][2] = {\n    {12,10}, {13,5}, {13,7}, {12,8}, {11,8}, {12,7,}, {12,6}, {12,5}, {11,3},\n    {12,4}, {12,3}, {13,2}, {13,3}, {13,4}, {11,2}, {13,10}, {11,10}, {11,7},\n    {12,9}, {11,6}, {11,4}, {13,6}, {11,9}, {13,8}, {13,9}, {11,5}\n};\n\n//  Define the 12 Lamp Pins for initialization\nint lamppin[12] = { 2,3,4,5,6,7,8,9,10,11,12,13 }; //2 to 10 cathode, 11 to 13 common annode\n\n// Define each LTP587P Segments: A,B,C,D,E,F,G,H,K,M,N,P,R,S,T,U,dp              \nboolean segmentvals[40][17] = {\n    { 0,0,0,0,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = A 0\n    { 0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1 }, // = B 1\n    { 0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = C 2\n    { 0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1 }, // = D 3\n    { 0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = E 4\n    { 0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = F 5\n    { 0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1 }, // = G 6\n    { 1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = H 7\n    { 0,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1 }, // = I 8\n    { 1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1 }, // = J 9\n    { 1,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,1 }, // = K 10\n    { 1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = L 11\n    { 1,1,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1 }, // = M 12\n    { 1,1,0,0,1,1,0,0,0,1,1,1,0,1,1,1,1 }, // = N 13\n    { 0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = O 14\n    { 0,0,0,1,1,1,0,0,1,1,1,0,1,1,1,0,1 }, // = P 15\n    { 0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1 }, // = Q 16\n    { 0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,0,1 }, // = R 17\n    { 0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = S 18\n    { 0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1 }, // = T 19\n    { 1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1 }, // = U 20\n    { 1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1 }, // = V 21\n    { 1,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1 }, // = W 22\n    { 1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1 }, // = X 23\n    { 1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1 }, // = Y 24\n    { 0,0,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1 }, // = Z 25\n    { 0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1 }, // = 0 26\n    { 1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1 }, // = 1 27\n    { 0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1 }, // = 2 28\n    { 0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1 }, // = 3 29\n    { 1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1 }, // = 4 30\n    { 0,0,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = 5 31\n    { 0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = 6 32\n    { 0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1 }, // = 7 33\n    { 0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1 }, // = 8 34\n    { 0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,0,1 }, // = 9 35\n    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, // = Space 36\n    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, // = Full Lit 37\n    { 1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1 }, // = SS 38\n    { 0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1 }  // = & 39\n};\n// LTP587P Segments: A,B,C,D,E,F,G,H,K,M,N,P,R,S,T,U,dp\n\n// Define the 5 Mode LEDs\nint led1 = 40;\nint led2 = 42;\nint led3 = 44;\nint led4 = 46;\nint led5 = 48;\n\n//4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9\n//Define the rotor values A B C D E F G H I J K L M N O P Q\nstatic const int rotorvals[12][78] = {\n    { 4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,123,20,18,15,0,8,1,17,2,9,\n      4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,123,20,18,15,0,8,1,17,2,9,\n      4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,123,20,18,15,0,8,1,17,2,9 }, // wheel 1\n\n    { 0,9,3,10,118,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4,\n      0,9,3,10,118,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4,\n      0,9,3,10,118,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4 }, // wheel 2\n\n    { 1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,112,20,18,16,14,\n      1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,112,20,18,16,14,\n      1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,112,20,18,16,14 }, // wheel 3\n\n    { 4,18,14,21,15,25,9,0,24,116,20,8,17,7,23,11,13,5,19,6,10,3,2,12,22,1,\n      4,18,14,21,15,25,9,0,24,116,20,8,17,7,23,11,13,5,19,6,10,3,2,12,22,1,\n      4,18,14,21,15,25,9,0,24,116,20,8,17,7,23,11,13,5,19,6,10,3,2,12,22,1 }, // wheel 4\n\n    { 21,25,1,17,6,8,19,24,20,15,18,3,13,7,11,23,0,22,12,9,16,14,5,4,2,110,\n      21,25,1,17,6,8,19,24,20,15,18,3,13,7,11,23,0,22,12,9,16,14,5,4,2,110,\n      21,25,1,17,6,8,19,24,20,15,18,3,13,7,11,23,0,22,12,9,16,14,5,4,2,110 }, // wheel 5\n\n    { 9,15,6,21,14,20,12,5,24,16,1,4,113,7,25,17,3,10,0,18,23,11,8,2,19,122,\n      9,15,6,21,14,20,12,5,24,16,1,4,113,7,25,17,3,10,0,18,23,11,8,2,19,122,\n      9,15,6,21,14,20,12,5,24,16,1,4,113,7,25,17,3,10,0,18,23,11,8,2,19,122 }, // wheel 6\n\n    { 13,25,9,7,6,17,2,23,12,24,18,22,101,14,20,5,0,8,21,11,15,4,10,16,3,119,\n      13,25,9,7,6,17,2,23,12,24,18,22,101,14,20,5,0,8,21,11,15,4,10,16,3,119,\n      13,25,9,7,6,17,2,23,12,24,18,22,101,14,20,5,0,8,21,11,15,4,10,16,3,119 }, // wheel 7\n\n    { 5,10,16,7,19,11,23,14,2,1,9,18,115,3,25,17,0,12,4,22,13,8,20,24,6,121,\n      5,10,16,7,19,11,23,14,2,1,9,18,115,3,25,17,0,12,4,22,13,8,20,24,6,121,\n      5,10,16,7,19,11,23,14,2,1,9,18,115,3,25,17,0,12,4,22,13,8,20,24,6,121 }, // wheel 8\n\n    { 11,4,24,9,21,2,13,8,23,22,15,1,16,12,3,17,19,0,10,25,6,5,20,7,14,18,\n      11,4,24,9,21,2,13,8,23,22,15,1,16,12,3,17,19,0,10,25,6,5,20,7,14,18,\n      11,4,24,9,21,2,13,8,23,22,15,1,16,12,3,17,19,0,10,25,6,5,20,7,14,18 }, // Beta\n\n    { 5,18,14,10,0,13,20,4,17,7,12,1,19,8,24,2,22,11,16,15,25,23,21,6,9,3,\n      5,18,14,10,0,13,20,4,17,7,12,1,19,8,24,2,22,11,16,15,25,23,21,6,9,3,\n      5,18,14,10,0,13,20,4,17,7,12,1,19,8,24,2,22,11,16,15,25,23,21,6,9,3 }, // Gamma\n\n    { 4,13,10,16,0,20,24,22,9,8,2,14,15,1,11,12,3,23,25,21,5,19,7,17,6,18,\n      4,13,10,16,0,20,24,22,9,8,2,14,15,1,11,12,3,23,25,21,5,19,7,17,6,18,\n      4,13,10,16,0,20,24,22,9,8,2,14,15,1,11,12,3,23,25,21,5,19,7,17,6,18}, // = UKW-B\n\n    { 17,3,14,1,9,13,19,10,21,4,7,12,11,5,2,22,25,0,23,6,24,8,15,18,20,16,\n      17,3,14,1,9,13,19,10,21,4,7,12,11,5,2,22,25,0,23,6,24,8,15,18,20,16,\n      17,3,14,1,9,13,19,10,21,4,7,12,11,5,2,22,25,0,23,6,24,8,15,18,20,16 } // = UKW-C\n};\n\nstatic const int rotorvali[10][78] = {\n    { 20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9,\n      20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9,\n      20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9 }, //wheel 1 i\n\n    { 0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18,\n      0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18,\n      0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18 }, //wheel 2 i\n\n    { 19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12,\n      19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12,\n      19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12 }, //wheel 3 i\n\n    { 7,25,22,21,0,17,19,13,11,6,20,15,23,16,2,4,9,12,1,18,10,3,24,14,8,5,\n      7,25,22,21,0,17,19,13,11,6,20,15,23,16,2,4,9,12,1,18,10,3,24,14,8,5,\n      7,25,22,21,0,17,19,13,11,6,20,15,23,16,2,4,9,12,1,18,10,3,24,14,8,5 }, //wheel 4 i\n\n    { 16,2,24,11,23,22,4,13,5,19,25,14,18,12,21,9,20,3,10,6,8,0,17,15,7,1,\n      16,2,24,11,23,22,4,13,5,19,25,14,18,12,21,9,20,3,10,6,8,0,17,15,7,1,\n      16,2,24,11,23,22,4,13,5,19,25,14,18,12,21,9,20,3,10,6,8,0,17,15,7,1 }, //wheel 5 i\n\n    { 18,10,23,16,11,7,2,13,22,0,17,21,06,12,4,1,9,15,19,24,5,3,25,20,8,14,\n      18,10,23,16,11,7,2,13,22,0,17,21,06,12,4,1,9,15,19,24,5,3,25,20,8,14,\n      18,10,23,16,11,7,2,13,22,0,17,21,06,12,4,1,9,15,19,24,5,3,25,20,8,14 }, //wheel 6 i\n\n    { 16,12,6,24,21,15,4,3,17,2,22,19,8,0,13,20,23,5,10,25,14,18,11,7,9,1,\n      16,12,6,24,21,15,4,3,17,2,22,19,8,0,13,20,23,5,10,25,14,18,11,7,9,1,\n      16,12,6,24,21,15,4,3,17,2,22,19,8,0,13,20,23,5,10,25,14,18,11,7,9,1 }, //wheel 7 i\n\n    { 16,9,8,13,18,0,24,3,21,10,1,5,17,20,7,12,2,15,11,4,22,25,19,6,23,14,\n      16,9,8,13,18,0,24,3,21,10,1,5,17,20,7,12,2,15,11,4,22,25,19,6,23,14,\n      16,9,8,13,18,0,24,3,21,10,1,5,17,20,7,12,2,15,11,4,22,25,19,6,23,14 }, //wheel 8 i\n\n    { 17,11,5,14,1,21,20,23,7,3,18,0,13,6,24,10,12,15,25,16,22,4,9,8,2,19,\n      17,11,5,14,1,21,20,23,7,3,18,0,13,6,24,10,12,15,25,16,22,4,9,8,2,19,\n      17,11,5,14,1,21,20,23,7,3,18,0,13,6,24,10,12,15,25,16,22,4,9,8,2,19 }, //Beta i\n\n    { 4,11,15,25,7,0,23,9,13,24,3,17,10,5,2,19,18,8,1,12,6,22,16,21,14,20,\n      4,11,15,25,7,0,23,9,13,24,3,17,10,5,2,19,18,8,1,12,6,22,16,21,14,20,\n      4,11,15,25,7,0,23,9,13,24,3,17,10,5,2,19,18,8,1,12,6,22,16,21,14,20 } //Gamma i\n};\n\n// Define a 2D Array for keeping the wheel locations & positions\nint wheel[3][3] = {\n    {26,0,0}, {26,0,0}, {26,0,0}\n};\nint reflect[2] = {1, 0};\n\n// Define Array for plugbord values 25 x2 position 0 holds use position 1 holds value int plugu holds the total nomber of plugs used (10 max)\nint plugval[2][26] = {\n    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n    { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25 }\n};\nint pluguse = 0;\nint paindex = 0;\nint pbindex = 1;\n\nvoid setup() {\n// Initialize all 38 LED pins as Output \n    for (int index = 0; index <= 11; index++) {\n        pinMode(lamppin[index], OUTPUT);\n        digitalWrite(lamppin[index],1);\n    }\n    for (int index = 0; index <= 3; index++) {\n        pinMode(anode[index], OUTPUT);\n        digitalWrite(anode[index], 1);\n    }\n    for (int index = 0; index <= 16; index++) {\n        pinMode(segment[index], OUTPUT);\n        digitalWrite(segment[index], 1);\n    } \n    pinMode(led1, OUTPUT);\n    pinMode(led2, OUTPUT);\n    pinMode(led3, OUTPUT);\n    pinMode(led4, OUTPUT);\n    pinMode(led5, OUTPUT);\n\n// Serial.begin(9600);\n// Initialize all 4 pusbutton pins as Input   \n    for (int index = 0; index <= 3; index++) {\n        pinMode(inpin[index], INPUT);\n    }\n}\n\nvoid loop() {\n// Keyboard debounce & test for new key pressed \n    time = millis();\n    if (time > otime + 500) keyval = readkbde();\n    if ((keyval == 45) && (windex == 1)) modeselect();\n// The whole Enigma machine operation revolves around which Operating Mode is current \n    if (mode == 0) mode0();\n    else if (mode == 1) mode1();\n    else if (mode == 2) mode2();\n    else if (mode == 3) mode3();\n    else if (mode == 4) mode4();\n    else if (mode == 5) mode5();\n    else {}\n\n//Serial.println(keyval); // for debuging prints keybord value to serial monitor// for run or del\n}\n\n// This function takes care of figuring out which key has been pressed & returns a unique Integer\nint readkbde() {\n    int kval = 100;\n    for (int index = 0; index <= 3; index++) {\n        inval[index] = analogRead(inpin[index]);\n    } //Reads analog input values\n    if ((inval[0] > 925) && (inval[1] > 828) && (inval[2] > 730) && (inval[3] > 828)) kval = 100; // no key press\n    else if ((inval[0] < 924) && (inval[0] > 915)) kval = 49; //up arrow 4\n    else if ((inval[0] < 914) && (inval[0] > 903)) kval = 48; //up arrow 3\n    else if ((inval[0] < 902) && (inval[0] > 887)) kval = 47; //up arrow 2\n    else if ((inval[0] < 886) && (inval[0] > 865)) kval = 46; //up arrow 1\n    else if ((inval[0] < 864) && (inval[0] > 836)) kval = 45; //mode\n    else if ((inval[0] < 834) && (inval[0] > 793)) kval = 44; //enter\n    else if ((inval[0] < 792) && (inval[0] > 724)) kval = 43;\n    else if ((inval[0] < 723) && (inval[0] > 594)) kval = 42;\n    else if ((inval[0] < 593) && (inval[0] > 260)) kval = 41;\n    else if (inval[0] < 259) kval = 40;\n    else if ((inval[1] < 827) && (inval[1] > 807)) kval = 14;\n    else if ((inval[1] < 806) && (inval[1] > 781)) kval = 8;\n    else if ((inval[1] < 780) && (inval[1] > 749)) kval = 20;\n    else if ((inval[1] < 748) && (inval[1] > 706)) kval = 25;\n    else if ((inval[1] < 705) && (inval[1] > 647)) kval = 19;\n    else if ((inval[1] < 646) && (inval[1] > 555)) kval = 17;\n    else if ((inval[1] < 554) && (inval[1] > 418)) kval = 4;\n    else if ((inval[1] < 417) && (inval[1] > 169)) kval = 22;\n    else if (inval[1] < 168) kval = 16;\n    else if ((inval[2] < 729) && (inval[2] > 699)) kval = 10;\n    else if ((inval[2] < 698) && (inval[2] > 660)) kval = 9;\n    else if ((inval[2] < 659) && (inval[2] > 611)) kval = 7;\n    else if ((inval[2] < 610) && (inval[2] > 547)) kval = 6;\n    else if ((inval[2] < 546) && (inval[2] > 455)) kval = 5;\n    else if ((inval[2] < 454) && (inval[2] > 331)) kval = 3;\n    else if ((inval[2] < 330) && (inval[2] > 127)) kval = 18;\n    else if (inval[2] < 126) kval = 0;\n    else if ((inval[3] < 827) && (inval[3] > 807)) kval = 11;\n    else if ((inval[3] < 806) && (inval[3] > 781)) kval = 12;\n    else if ((inval[3] < 780) && (inval[3] > 749)) kval = 13;\n    else if ((inval[3] < 748) && (inval[3] > 706)) kval = 1;\n    else if ((inval[3] < 705) && (inval[3] > 647)) kval = 21;\n    else if ((inval[3] < 646) && (inval[3] > 555)) kval = 2;\n    else if ((inval[3] < 554) && (inval[3] > 418)) kval = 23;\n    else if ((inval[3] < 417) && (inval[3] > 169)) kval = 24;\n    else if (inval[3] < 169) kval = 15;\n    else kval = 100;\n    if (kval < 99) otime = millis(); // Starts key debounce timer\n    if ((kval >= 0) && (kval <= 99)) windex = 1;\n    // windex showing true (1) indicates the return of a fresh key stroke\n    return kval;\n}\n\n// Function to change operating Mode\nvoid modeselect() {\n    mode++;\n    if (mode >= 6) mode = 0;\n    windex = 0;\n}\n\n// Default Mode: Enigma is a Typewriter\nvoid mode0() {\n    if ((keyval >= 0) && (keyval <= 25)) lampval = keyval;\n    lampita();\n    marquee();\n    lampitb();\n}\n\n// Select the Rotors & the Reflector \nvoid mode1() {\n    int index;\n    digitalWrite(led1, HIGH);\n    if (windex == 1) {\n        if ((keyval == 43) || (keyval == 46)) {\n            reflect[0]++;\n            if (reflect[0] > 2) {\n                reflect[0] = 1;\n            }\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 47) {\n            for (index = wheel[2][0]; (index == wheel[1][0]) || (index == wheel[0][0]) || (index == wheel[2][0]); index++) {\n                if (index > 33) index = 26;\n            }\n            wheel[2][0] = index;\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 48) {\n            for (index = wheel[1][0]; (index == wheel[2][0]) || (index == wheel[0][0]) || (index == wheel[1][0]); index++) {\n                if (index > 33) index = 26;\n            }\n            wheel[1][0] = index;\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 49) {\n            for (index = wheel[0][0]; (index == wheel[2][0]) || (index == wheel[1][0]) || (index == wheel[0][0]); index++) {\n                if (index > 33) index = 26;\n            }\n            wheel[0][0] = index;\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 42) {\n            for (index = wheel[2][0]; (index == wheel[1][0]) || (index == wheel[0][0]) || (index == wheel[2][0]); index--) {\n                if (index < 28) index = 35;\n            }\n            wheel[2][0] = index;\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 41) {\n            for (index = wheel[1][0]; (index == wheel[2][0]) || (index == wheel[0][0]) || (index == wheel[1][0]); index--) {\n                if (index < 28) index = 35;\n            }\n            wheel[1][0] = index;\n            windex = 0;\n        }\n    }\n    if (windex == 1) {\n        if (keyval == 40) {\n            for (index = wheel[0][0]; (index == wheel[2][0]) || (index == wheel[1][0]) || (index == wheel[0][0]); index--) {\n                if (index < 28) index = 35;\n            }\n            wheel[0][0] = index;\n            windex = 0;\n        }\n    }\n    dig1 = reflect[0]; dig2 = wheel[2][0];  dig3 = wheel[1][0]; dig4 = wheel[0][0];\n    nixisend();\n    dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n    digitalWrite(led1, LOW);\n}\n\n// Position the Inner setting of each Rotor \nvoid mode2() {\n    digitalWrite(led2, HIGH);\n    if (windex == 1) {\n        if (keyval == 47) { wheel[2][1]++; if (wheel[2][1] > 25) wheel[2][1] = 0; }\n        if (keyval == 48) { wheel[1][1]++; if (wheel[1][1] > 25) wheel[1][1] = 0; }\n        if (keyval == 49) { wheel[0][1]++; if (wheel[0][1] > 25) wheel[0][1] = 0; }\n        if (keyval == 42) { wheel[2][1]--; if (wheel[2][1] < 0) wheel[2][1] = 25; }\n        if (keyval == 41) { wheel[1][1]--; if (wheel[1][1] < 0) wheel[1][1] = 25; }\n        if (keyval == 40) { wheel[0][1]--; if (wheel[0][1] < 0) wheel[0][1] = 25; }\n        windex = 0;\n    }\n    dig2 = wheel[2][1]; dig3 = wheel[1][1]; dig4 = wheel[0][1]; dig1 = 0;\n    nixisend();\n    dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n    digitalWrite(led2, LOW);\n  }\n\n// Position the Start character of each Wheel \nvoid mode3() {\n    digitalWrite(led3, HIGH);\n    if (windex == 1) {\n        if (keyval == 46) { reflect[1]++; if (reflect[1] > 25) reflect[1] = 0; }\n        if (keyval == 47) { wheel[2][2]++; if (wheel[2][2] > 25) wheel[2][2] = 0; }\n        if (keyval == 48) { wheel[1][2]++; if (wheel[1][2] > 25) wheel[1][2] = 0; }\n        if (keyval == 49) { wheel[0][2]++; if (wheel[0][2] > 25) wheel[0][2] = 0; }\n        if (keyval == 43) { reflect[1]--; if (reflect[1] < 0) reflect[1] = 25; }\n        if (keyval == 42) { wheel[2][2]--; if (wheel[2][2] < 0) wheel[2][2] = 25; }\n        if (keyval == 41) { wheel[1][2]--; if (wheel[1][2] < 0) wheel[1][2] = 25; }\n        if (keyval == 40) { wheel[0][2]--; if (wheel[0][2] < 0) wheel[0][2] = 25; }\n        windex = 0;\n    }\n    dig1 = reflect[1]; dig2 = wheel[2][2]; dig3 = wheel[1][2]; dig4 = wheel[0][2];\n    nixisend();\n    dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n    digitalWrite(led3, LOW);\n}\n\n// Define the Plugboard pairs \nvoid mode4() {\n    int index = 0;\n    digitalWrite(led4, HIGH);\n    if (pluguse <= 9) {\n        if (plugval[0][paindex] == 1) {\n            for (index = paindex;(index == paindex) || (index == pbindex) || (plugval[0][index] == 1); index++) {\n                if (index > 24) index = -1;\n            }\n            paindex = index;\n        }\n        if (plugval[0][pbindex] == 1) {\n            for (index = pbindex;(index == pbindex) || (index == paindex) || (plugval[0][index] == 1); index++) {\n                if (index > 24) index = -1;\n            }\n            pbindex = index;\n        }\n        if (windex == 1) {\n            if (keyval == 46) {\n                for (index = paindex;(index == paindex) || (index == pbindex) || (plugval[0][index] == 1); index++) {\n                    if (index > 24) index = -1;\n                }\n                paindex = index;\n                windex = 0;\n            }\n            if (keyval == 43) {\n                for (index = paindex;(index == paindex) || (index == pbindex) || (plugval[0][index] == 1); index--) {\n                    if (index < 1) index = 26;\n                }\n                paindex = index;\n                windex = 0;\n            }\n            if (keyval == 49) {\n                for (index = pbindex;(index == pbindex) || (index == paindex) || (plugval[0][index] == 1); index++) {\n                    if (index > 24) index = -1;\n                }\n                pbindex = index;\n                windex = 0;\n            }\n            if (keyval == 40) {\n                for (index = pbindex;(index == pbindex) || (index == paindex) || (plugval[0][index] == 1); index--) {\n                    if (index < 1) index = 26;\n                }\n                pbindex = index;\n                windex = 0;\n            }\n            if (keyval == 44) {\n                plugval[0][paindex] = 1;\n                plugval[1][paindex] = pbindex;\n                plugval[0][pbindex] = 1;\n                plugval[1][pbindex] = paindex;\n                windex = 0;\n                pluguse++;\n            }\n        }\n        dig1 = paindex; dig2 = 19; dig3 = 14; dig4 = pbindex;\n        nixisend();\n        dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n    }\n    else done();\n    digitalWrite(led4, LOW);\n}\n\n// This is Normal Operation Mode to Encrypt/Decrypt \nvoid mode5() {\n    int pv = 0;\n    digitalWrite(led5, HIGH);\n\n    if ((keyval >= 0) && (keyval <= 25) && (windex == 1)) {\n        procesvala = keyval;\n        indexwheels();\n    }\n    windex = 0;\n    procesval = procesvala;\n    procesval = plugval[1][procesval];\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[0][2] - wheel[0][1]);\n    if (pv < 0) pv += 26; \n    procesval = rotorvals[wheel[0][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[0][2] - wheel[0][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[1][2] - wheel[1][1]);\n    if (pv < 0) pv += pv + 26;\n    procesval = rotorvals[wheel[1][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[1][2] - wheel[1][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[2][2] - wheel[2][1]);\n    if (pv < 0) pv += 26;\n    procesval = rotorvals[wheel[2][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[2][2] - wheel[2][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval;\n    procesval = rotorvals[reflect[0] + 7][pv];\n    if (procesval >= 100) procesval -= 100;\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    procesval = rotorvals[reflect[0] + 9][procesval];\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + 26;\n    procesval = rotorvali[reflect[0] + 7][pv];\n    if (procesval >= 100) procesval -= 100;\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[2][2] - wheel[2][1]);\n    if (pv < 0) pv += 26;\n    procesval = rotorvali[wheel[2][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[2][2] - wheel[2][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[1][2] - wheel[1][1]);\n    if (pv < 0) pv += 26;\n    procesval = rotorvali[wheel[1][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[1][2] - wheel[1][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n    //Serial.print(procesval); Serial.print(\"   \");\n\n    pv = procesval + (wheel[0][2] - wheel[0][1]);\n    if (pv < 0) pv += 26;\n    procesval = rotorvali[wheel[0][0] - 27][pv];\n    if (procesval >= 100) procesval -= 100;\n    procesval = (procesval - (wheel[0][2] - wheel[0][1]));\n    if (procesval < 0) procesval += 26;\n    if (procesval > 25) procesval -= 26;\n\n    //Serial.print(procesval); Serial.print(\"   \");\n    procesval = plugval[1][procesval];\n\n    lampval = procesval;\n    //Serial.println(lampval);\n    dig1 = reflect[1]; dig2 = wheel[2][2]; dig3 = wheel[1][2]; dig4 = wheel[0][2];\n    lampita();\n    nixisend();\n    lampitb();\n    dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n    digitalWrite(led5, LOW);\n}\n\n// Helper Function to light the proper key\nvoid lampita() {\n    digitalWrite(lamparray[lampval][0], 0);\n    digitalWrite(lamparray[lampval][1], 0);\n}\nvoid lampitb(){\n    digitalWrite(lamparray[lampval][0], 1);\n    digitalWrite(lamparray[lampval][1], 1); \n}\n\n// Help Function to illuminate \"Nixies\"\nvoid nixisend() {\n    sixteenSegWrite(0, dig1);\n    sixteenSegWrite(1, dig2);\n    sixteenSegWrite(2, dig3);\n    sixteenSegWrite(3, dig4);\n}\n\nvoid marquee() {\n    time = millis();\n    if (mtime < time) {\n        mtime = time + 400;\n        mdex++;\n    }\n    dig1 = data[mdex];\n    dig2 = data[mdex + 1];\n    dig3 = data[mdex + 2];\n    dig4 = data[mdex + 3];\n    if (mdex >= 31) mdex = 0;\n    nixisend();\n}\n// Function that actually turns on each of 17 appropriate segments on each \"Nixie\"\nvoid sixteenSegWrite(int digit, int character) {\n    digitalWrite(anode[digit],0);\n    for (int index = 0; index < 17; index++) {\n        digitalWrite(segment[index], segmentvals[character][index]);\n    }\n    delay(7);\n    for (int index = 0; index <= 16; index++) {\n        digitalWrite(segment[index], 1);\n    }\n    digitalWrite(anode[digit], 1);\n}\n\nvoid done() {\n    dig1 = 3; dig2 = 14; dig3 = 13; dig4 = 4;\n    nixisend();\n    dig1 = 37; dig2 = 37; dig3 = 37; dig4 = 37;\n}\n\nvoid indexwheels() {\n    //Serial.print(rotorvals[wheel[0][0]-27][wheel[0][2]]);\n    //Serial.print(\"    \"); Serial.print(wheel[0][0]-27); Serial.print(\"    \"); Serial.println(wheel[0][2]);\n    if (rotorvals[wheel[0][0] - 27][wheel[0][2]] >= 100) windex1 = 1;\n    wheel[0][2]++;\n    if (wheel[0][2] > 25) wheel[0][2] = 0;\n    windex = 0;\n    if (windex1 == 1) {\n        if (rotorvals[wheel[1][0] - 27][wheel[1][2]] >= 100) windex2 = 1;\n        wheel[1][2]++;\n        if (wheel[1][2] > 25) wheel[1][2] = 0;\n    }\n    windex1 = 0;\n    if (windex2 == 1) {\n        wheel[2][2]++;\n        if (wheel[2][2] > 25) wheel[2][2] = 0;\n        windex2 = 0;\n    }\n}\n```\n\nIF there is enough interest, we plan on are creating a PCB that would will allow for a much easier assembly of this wonderful fully functional Enigma replica. Please visit http://www.stgeotronics.com to find out about availability, pricing & to place your order or pre-order now. The Circuit schematics are published, so the PCB has entered it's development stage. Soon to be tested.\n如果有足够的利润，我们将研发能够使全功能Enigma机复制品装载更为容易的印刷电路板。请登陆 http://www.stgeotronics.com 查询商品上架与否、价格、下单或预订吧。电路图已经发布了，印刷电路也已进入开发阶段，即将内测。\n\n## Step 9: Circuit Schematics\n\n第九步：电路图\n\n![](/images/2018-08/FEWJUCNHMMFCNPV.LARGE.jpg)\n![](/images/2018-08/FFCPWADHMMF8FRX.LARGE.jpg)\n\nIn response to the popular demand, here are the two Circuit Schematics.\n徇众要求，电路图两份在此。\nThe first one shows how our fake nixie tubes (the 4 elevated 16-Segment units) are wired in order to provide the response that the rotors provide on a real Enigma machine. They are also used in each setup mode to provide feedback on the setting up of the machine.\n第一个是仿电子管（4个16段显示单元）如何布线，用于显示转子在Enigma机上的输出信号。同时，它们也用于每种调试模式，反馈用户机器设定信息。\nThe second one shows how each of the 26 keyboard buttons and 10 function keys, the 26 key lamps & the 5 LEDS are all wired.\n第二幅电路图显示26个字母按键及10个功能键、26个键盘灯和5个LED是如何布线的。\nAll LED resistors are 470 Ohms and all Pushbutton resistors are 1KOhm.\n所有LED电阻都是470欧，而开关电阻则都是1千欧。\nStay tuned for the PCB design file...\n印刷电路设计档仍在修正中。\nWe hope you enjoyed our first Instructable!\n希望你享受我们第一份制作教程!\nThank You for your time.\n感谢你抽出宝贵时间阅读！\n\n## Step 10: Prototype Boards\n\n第十步：PCB样机版\n\n![](/images/2018-08/F7E23SFHOHYMQIY.LARGE.jpg)\n![](/images/2018-08/FRVNOESHOPQDW25.LARGE.jpg)\n\nDue to popular demand, we designed & ordered some Printed Circuit Boards. Well, our PCBs are finally in and at first glance, they look beautiful! We have been busy populating & testing one to make sure it performs as good as it looks and more importantly, as well as our proof-of-concept device.\n徇众要求，我们设计及定制了一些印刷电路板。它们终于面世了，如此清纯可爱！我们忙于组装，并测试其中一块样品，确保它在功能上与外观一样完美无暇。更重要的是，能实现和那台原型测试机一样的功能。\nThe boards we ordered are almost perfect: they each need a little jumper wire to fix a small design flaw. This small flaw does not affect behavior or functionality and is an easy fix.\n订购回来的底板几乎完美，只需一点引脚线去修补设计瑕疵。而这些瑕疵对功能没有影响，修理它们是小菜一碟。\nWith this jumper in place, you can now make your own Enigma Replica much easier & faster than running all wires this instructable shows. So, we are now happy to report that testing is completed & the new boards work just fine!\n有了这些引脚，你能更容易制作自己的Enigma复刻机，比起教程里的布线方便多了。我们在此很高兴宣布，测试完成，新型板一样给力！\nWe are now accepting orders at www.stgeotronics.com & have started shipping.\nPictures of the assembly have been added as Step 11.\n下单订购请登陆 http://www.stgeotronics.com ，已发货热卖中。组装图片请见第十一步。\nThank You for your overwhelming support & wonderful feedback!\n感谢大家的不懈支持和宝贵反馈意见！\n\n## Step 11: Assembled Kits\n\n第十一步：组装完成的作品\n\n![](/images/2018-08/FGKWVNEHP8PLOCX.LARGE.jpg)\n![](/images/2018-08/FVGEWVMHP989E1R.LARGE.jpg)\n![](/images/2018-08/FMICFEUHP989E1T.LARGE.jpg)\n\n更多图片可以前往[原文](https://www.instructables.com/id/Make-your-own-Enigma-Replica/#step11)查看。\nThis assembly took one evening & you can look at assembly pictures above for an overview of the process.\n花了一晚上组装完成，全过程的概览如上图所示。\nThank You for the support & feedback!\n感谢你的支持与反馈！\n\n## 更多\n\n博主在深入了解Enigma机后，制作了一个JavaScript版本的虚拟机，实现了几乎全部功能，可以点击下方链接前往。\n本站的JavaScript版本：[ZSQ.IM > 应用 > 原创游戏 > Enigma](https://zsq.im/tool/enigma/)\n这个版本暂未针对移动端进行优化，请使用桌面端打开。\n而原文中基于Arduino开发的实体机器，由于制作过于复杂，博主还在进行研究，看上去所有的代码都是功能正常的。\n\n---\n\n本文翻译自：[MAKE YOUR OWN ENIGMA REPLICA](https://www.instructables.com/id/Make-your-own-Enigma-Replica)\n\n参考文章：\n[恩尼格玛密码机](https://en.wikipedia.org/wiki/Enigma_machine)\n[自己打造一台恩尼格码密码机](https://web.archive.org/web/20150730050426/http://oszine.com/enigma)\n[Bletchley Park](https://www.bletchleypark.org.uk)\n","tags":["Arduino"],"categories":["技术"]},{"title":"武功山游记","url":"/2018-08/武功山游记/","content":"\n在7月下旬，博主和同学前往江西萍乡的武功山露营，计划观看火星冲日、月全食等天文现象。博主携带了Canon EOS 50D相机，搭配17-40mm f/4L镜头，用以记录登山过程中的美景；还向朋友借了一个70-200mm f/2.8的长焦镜头，以备不时之需。下面就来用照片分享这次旅途的经历。\n\n先上三组『[AN对比图](https://zh.moegirl.org/显卡对比图)』。\n\n优胜美地国家公园 vs 武功山金顶\n\n![](/images/2018-08/Yosemite.jpg)\n![](/images/2018-08/IMG_5604.jpg)\n\nMac Sky壁纸 vs 日出前的云海\n\n![](/images/2018-08/Sky.jpg)\n![](/images/2018-08/IMG_5485.jpg)\n\n<!-- more -->\nWin XP壁纸（北加州Sonoma） vs 武功山『空中草原』\n\n![](/images/2018-08/Mascaloona-Bliss.jpg)\n![](/images/2018-08/IMG_5341.jpg)\n\n虽然提前查看了天气预报，但天数有变，博主到达的那天下午，正看到乌云以肉眼可见的速度朝山上飘来。博主的心里凉了半截——毕竟，如果天公不作美，我们可能就要与天文奇观失之交臂了。在一场阵雨后，山上的空气湿度持续增加，入夜时营地被浓雾笼罩，颇有一种寂静岭的感觉。\n这是阵雨后的夕阳和晚霞：\n\n![](/images/2018-08/IMG_5376.jpg)\n\n![](/images/2018-08/IMG_5389.jpg)\n\n以及日落后的山庄：\n\n![](/images/2018-08/IMG_5443.jpg)\n\n后半夜，浓雾逐渐散去，终于可以夜观天象啦！\n\n![](/images/2018-08/IMG_5462.jpg)\n\n> 长焦打月亮\n\n**效果并不好，如果有条件，还是要使用天文望远镜。**\n\n![](/images/2018-08/IMG_5475.jpg)\n\n> 星空\n\n在长时间的曝光下，可以明显地看到星空中恒星的转动轨迹。这是由于地球自转带来的周日视运动。\n日出和朝霞也同样壮观：\n\n![](/images/2018-08/IMG_5532.jpg)\n\n这次行程的遗憾便是器材仍不够强大，200mm焦距对应的放大率难以看清月球表面的更多细节；不过，在旅途中也收获了很多精彩的镜头，而博主对于B门曝光的参数控制与设置也有了更多经验，未来将会作出更多的尝试。\n","tags":["摄影"],"categories":["其他"]},{"title":"Unicode字符与颜文字表情","url":"/2018-07/Unicode字符与颜文字表情/","content":"\n## 前言\n\n编码，是每个程序员绕不开的话题。对于前端工程师而言，字符更是会直观地展示在界面上。\n提起文字，大部分人的脑中，都会定式为规整排列的字符。但是林子大了什么鸟都有，世界上可是存在着6800+种文字，难免会飞出来一些诡异的鸟…\n而号称『万国码』的Unicode，在实现编码与展示的时候，也会不会遇到一些奇葩的事情呢？\n事实上，可能你早已见识过了：\n\n---\n\n\nx̙͈̝͍͕̙̄͛̽̆͌́̕͟g̘̣̠̝̟̤̥̼̼̽͑͋̈̑̒͟͞q̛̤̦̝̘͎͋̔̋͌͒̆̋̚͡f̵̢̙͇̮̠̋̀͌̅̉̃̔͜͜͠͡r̢̜̩͙̭̲͓͈̈̀͑̆͋̚͢͜m̷̛͙̝̣̲̭͍͉̊̓̾̈̋̿̚͢͟͠s̷̡̩͔̮͈̜̊̽͂̆̈́̃̓͋̏\n\n\n热҈的҈字҈都҈出҈汗҈了҈\n\n你的屏幕被蓝翔挖掘机给挖坏了不信你看;̷̸̨̀͒̏̃ͦ̈́̾̀́̎͢҉̵̶͚̼͉͖̺̥͔͇̰̹̮͙͉̻̼̭̻͕̮͇ͨͬͪ͗̇̑̽͋̀̋̊͌ͧͨͭ̓̅͐ͥ̂̔̊ͧ͊҉̶̵̷̞̩̦̳̺̳̬̬̩̣̫͇̯̥͖͍͕̠̦̼̗ͯ̽͌̔ͪͯ́́͋̍ͨ̿̿̎͒ͤ̓̅̀͂ͧ͋̏ͫͣ̔͘͜͠͏̶̵̸̧̧̥̺͓̘̺͎̜̥͕͈̝̫͎̺̮̱̤̠̠͖̳̻̥̣̪͍͕͇̮͙̹̪ͮͧͫ͂͒ͤͣ̌̽ͨͪ͒̄̄̉̒̊ͩ̅͆͘̚͘͘̚͟͟͝ͅ\n\n---\n\n今天我们就来探讨一下这些奇怪的字符。\n\n## 文字可以戴帽子和穿鞋子\n\n提起泰文，很多朋友都会立即想到：**萨瓦迪卡（你好）**。\n但这句话是怎么写的呢？\n其实这句你好，男生和女生之间还有差异，男生写法是：`สวัสดีครับ`，女生则是：`สวัสดีค่ะ`。\n不过这并不重要，重要的是，我们发现某些字的上面，还带了特殊的符号。就好像是戴上了帽子。\n事实上，泰文字符不仅会『戴帽子』，偶尔还会『穿鞋子』，比如这三个字符：`ผ ผู ผู้`。\n如果脑洞再大一点，有人就会想，那是不是还可以戴多顶帽子呢？\n的确如此…泰文允许你穿一双鞋子，并且戴两顶帽子。完整的形式是这样的：\n\n![](/images/2018-07/FqLq54KAJkoSVA-7_jdJpSRI3fcI.png)\n\n所以，平时看惯了中英文的我们，需要改变一下思路了。\n世界上的文字，并不全是规规整整横向排列的格子，也存在像泰文这种变形金刚**组合式**的文字。\n虽然标准的泰文里，『帽子』和『鞋子』的数量是有限制的，但由于国际码的迷之设计（先卖个关子），在计算机里显示的泰文字符，却可以拥有无数的帽子和鞋子。也就是说，它变成了一款可以在Y轴无限拓展的文字！\n并且，咱不光可以往上喷，还可以有一定角度…\n*（由于一些系统会崩溃，这里使用截图）*\n\n![](/images/2018-07/Fr8cS9UX21MEgBtmOU_CDhreGqlO.jpg)\n![](/images/2018-07/Fr-rlbbriydg4cUmoU_Zs6VQSbpU.jpg)\n\n还可以\n\n![](/images/2018-07/Fk0kXSTymPxute84rceAkzGd5PKA.jpg)\n\n简直是不讲道理。\n\n## 文字还能倒过来\n\n这里还介绍一个神奇的Unicode字符：`\\u202e`，它的作用是让它之后的字符从右到左显示。博主最早是在微信中发现这个小技巧的，如果昵称中包含这个字符，可以产生奇妙的效果。例如用户：\n`米米‮`\n看上去没有什么问题，但实际上是\n`米米\\u202e`\n发送一个表情，就会显示为\n`米米‮：[动画表情]`\n如果用在文件名中，还可以起到欺骗的效果，例如：\n`sample_\\u202ecod.exe`\n就会显示为\n`sample_‮cod.exe`\n\n<!-- more -->\n## 人与机器的矛盾\n\n然后我们会质问Unicode，你为何不讲道理？\n如此的设计，近乎是一个bug；但即使是bug，也应该早就修复了呀。\n事实上，这样的设计，是为了解决一个问题：人与机器的矛盾。\n首先是存储的矛盾。\n如果把每个组合好的泰文用一个编码来表示，那么至少需要**44×21×4=3696**个编码（实际上可能要比这还多）。用如此多的编码来处理基本元素只有**69**个的文字是非常浪费的，因此电脑采用一套称为复杂文字编排（CTL）的设计来解决矛盾。\n简单的说，泰文的每个基本字符对应一个编码，用户在输入法里依次输入多个基本字符进行拼合，最后敲一个特殊的**『结束字符』**；这时前面输入的基本字符，就拼合成了一个**单独**的泰文字符，在屏幕中显示。\n这样就解决了存储的空间浪费问题。\n但这样就带来了第二个矛盾，识别的问题。\n人可以轻松地识别一个泰文合字是否拼写正确、有意义；但机器在显示时却很难进行判断，即使可以也会带来相应的性能问题。\n如何解决呢？如今会在输入法上做一些文章，比如打一个声调符号后就不能再输入了。不过，由于泰文这种基于结束标志合成字符的本质，你还是没法避免艺术家们使用复制粘贴、手工撰改字符位置等方式去进行创造，只能起到一些限制作用。\n其次，在比较新版本的Webkit里，在显示上会阻止这种往上下冒的字符，这样至少不影响排版。所以有部分字符已经不会出现上下叠加的情形了，你可以在不同浏览器，观察一下这个字符的显示：ส็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็็\n\n## 萌即正义的颜文字 (ง •̀_•́)ง\n\n也许你觉得泰文奇葩，但它的声调就在文字里，看到就能准确地读出来。这样更容易传播，是不是也没了你读文言文要查字典的烦恼呢？所以文字的设计各有优劣。\n这样的设计不止泰文，它只是一个典型的例子。除此之外常见的还有老挝文、藏文。\n脑洞大开的艺术家们，又会想到另外一个好玩的事情：我能不能拿老挝文的『帽子』，组合藏文的『鞋子』，合成一个独立的字符呢？\n他们赢了。不久，颜文字开始流行。\n比如，这个表情：(;´༎ຶД༎ຶ\\`)\n里面有眼睛流泪的一个字符：`༎ຶ`\n它是什么语言呢？\n事实上，它并不属于世界上任何一种语言！眼睛部分是**老挝文**，泪水部分属于**藏文**。\n但是，你在复制它的时候，可以发现它却是一个**单独**的字符，这就非常的神奇。原因我们在第二部分已经讲过了。\n我是如何知道的呢？当然我并不是个语言学家，我们可以转码一下，发现`༎ຶ`对应的编码是`\\u0f0e\\u0eb6`，再到[unicode-table](https://unicode-table.com/cn/#tibetan)里去查看就清楚了。\n除此之外——\n- ▷ˋε´◁中ε是希腊字母\n- ʕ-'ᴥ'-ʔ中ʕᴥʔ是国际音标\n- \\*(·ཀ·」∠)\\*中ཀ是藏文\n- (ง •̀\\_•́ )ง中ง是泰文\n- 罒д罒中罒是中文（同网），д是俄语西里尔字母\n\n看来如果你会发颜文字，就是名副其实的会十八国语言了呢 (๑✦ˑ̫✦)✧\n这里有B站评论区自带的颜文字表情：\n```txt\n(=・ω・=)    (〜￣△￣)〜    o(￣ヘ￣o＃)    (○･｀Д´･ ○)\n(･∀･)    (°∀°)ﾉ    (￣3￣)    ╮(￣▽￣)╭    (´_ゝ｀)\n←_←    →_→    (<_<)    (>_>)    (￣ε(#￣)Σ    ヾ(o◕∀◕)ﾉ\n(⌒▽⌒)    (￣▽￣)    (ﾟДﾟ≡ﾟдﾟ)!?    Σ(ﾟдﾟ;)    (\"▔□▔)/\n(^・ω・^)    (｡･ω･｡)    (●￣(ｴ)￣●)    ε=ε=(ノ≧∇≦)ノ\n(-_-#)    (￣へ￣)    (ฅ´ω`ฅ)    ヽ(`Д´)ﾉ    (´･_･`)\n(#-_-)┯━┯    _(:3」∠)_    (╯°口°)╯(┴—┴    (´▽｀)ノ♪\nヘ(_ _ヘ)    (｀・ω・´)    Σ(￣□￣||)    (´；ω；`)\n⌇●﹏●⌇    ヾ(^▽^*)))    (/TДT)/    (ó﹏ò｡)    (;¬_¬)\n```\nUnicode的转码可以在这里完成：[ZSQ.IM > 应用 > 实用工具 > TexToolBox](https://zsq.im/tool/strtool.html)\n\n## 字体的错位\n\n前面我们一直在谈字符的本质，但字符在屏幕中的展示，还有一个关键的因素：字体。\n相同的字符，使用了不同的字体，它们的显示也会有差别。\n一行中文，你设置黑体或草书，它大体来看还是规整的；但如果你设置一行英文为草书，可能就会有问题。\n在浏览器里，如果对应编码在字体文件里为空，一般会展示成一个方格，起码不会影响其他正常字符的排版。但我们知道，Unicode的林子实在太大了…\n在某些字体里，就会对一些特殊的字符产生错误的排版。\n比如：热҈的҈字҈都҈出҈汗҈了҈\n把它转义一下，就得到编码是：\n`\\u70ed\\u0488\\u7684\\u0488\\u5b57\\u0488\\u90fd\\u0488\\u51fa\\u0488\\u6c57\\u0488\\u4e86\\u0488`\n其中`\\u0488`就是`҈`这个字符的编码，它是一个组合用的[西里尔文百千符号](https://unicode-table.com/cn/0488)。\n它在大部分常用字体里，都有错位问题；而其他一些字体，比如Courier New字体，则是分开的展示：\n\n![](/images/2018-07/Fk4jy-lOTJvqGmGul8nZfz8r9B7p.png)\n\n那么，这两种展示哪种才是正常的呢？其实都不正常。\n我们查看[西里尔文计数法的wiki](https://en.wikipedia.org/wiki/Cyrillic_numerals)，可以看到它只有配合西里尔数字时，才能展示正常：\n\n![](/images/2018-07/Fn9DaIzvbgkExdrsLhSdCvJjCqX1.png)\n\n至于你把它跟其他语言组合在一起时，我们要么看到错位，要么看到分离的展示。而且国际上并没有一个组织，去规定要怎么展示。事实上文字这么多，根本也管不过来，所以这也是混乱的原因。\n最后补充一点，另外一小撮别有心裁的艺术家，还习惯使用这个字符去突破敏感词过滤…\n\n## 混乱与创新？\n\nUnicode是不可阻挡的潮流，它也一直在更新。比如我们常用的[Emoji表情](https://unicode-table.com/cn/sets/emoji)，就已经是Unicode的标准字符集。和泰文的组合一样，Emoji表情也是可以叠加的，这一点在前面的一篇关于[JavaScript常用简写技术与扩展运算符](/2018-01/JavaScript常用简写技术与扩展运算符/)的文章中也提到过。👪和👨‍👩‍👧‍👧就是典型的例子，它们展开后的编码就是👨👩👦🧒。\n而本文中我们说到，大家在玩这些奇奇怪怪的字符时，都是基于类似bug的设定在搞事情。这就有很大的局限性。\n那艺术家们又会有些大胆的想法：我能不能主动创造一些新字符，就是为了错位和组合呢？\n我也不清楚这是创新，还是会带来更多的混乱。但事实是，iOS系统自带的字符，已经有这样的尝试了。并且搜狗输入法在iOS系统提供的诸多符号里，挑选了一些，可供用户去使用。这个功能的名字，叫做花漾字。\n\n![](/images/2018-07/IMG_0151.png)\n\n还是得感慨艺术家们的视角是多么独特。\n既然都这样了…最后，希望我们的国产表情包能有朝一日打入Unicode吧。\n\n---\n\n参考文章：[人人都是艺术家！谈谈那些奇怪的字符（上）](http://litten.me/2017/11/13/strange-characters1)\n\n拓展阅读：\n[Unicode字符百科](https://unicode-table.com/cn)\n[Full Unicode Input utility](http://jkorpela.fi/fui.html8)\n[More Unicode Patterns](https://css-tricks.com/more-unicode-patterns)\n[Emoji的编码以及常见问题处理](https://segmentfault.com/a/1190000007594620)\n[Emoji 的处理 - 使用正则表达式匹配所有 Emoji](https://moe.best/nodejs-memo/emoji.html)\n[别再用「六个点」当省略号了，这些标点都有更规范的输入方式](https://sspai.com/post/45516)\n","categories":["技术"]},{"title":"在网页中添加Live2D看板娘","url":"/2018-07/在网页中添加Live2D看板娘/","content":"\n![](/images/2018-07/photo.jpg)\n\n项目地址：[live2d-widget](https://github.com/stevenjoezhang/live2d-widget)\n\n克隆这个仓库到服务器上，并配置`autoload.js`，修改其中的链接为各文件的绝对地址，即可在网页中添加Live2D看板娘。\n相对于市面上广为流传的版本，博主对触发动作和语言进行了魔改（针对Hexo NexT主题），调整了图标样式、元素定位，并解决了CSS的前缀等问题。\n更多内容可以参考项目文档及下方链接。\n快来把萌萌哒的看板娘抱回家吧！\n\n---\n\n参考文章：\n[网页添加 Live2D 看板娘](https://www.fghrsh.net/post/123.html)\n[给博客添加能动的看板娘(Live2D)-将其添加到网页上吧](https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02)\n","tags":["JavaScript","GitHub","PHP"],"categories":["技术"]},{"title":"改变世界的17个公式","url":"/2018-07/改变世界的17个公式/","content":"\nIn 2012, Mathematician Ian Stewart came out with an excellent and deeply researched book titled \"In Pursuit of the Unknown: 17 Equations That Changed the World.\"\n在2012年，数学家斯图尔特（Ian Stewart）出版了一本精彩而深入研究的著作，名为《追寻未知：改变世界的17个公式》。\nHis book takes a look at the most pivotal equations of all time, and puts them in a human, rather than technical context.\n他的书着眼于有史以来最关键的方程式，并将它们置于普通人而非专业的背景中。\n\"Equations definitely can be dull, and they can seem complicated, but that's because they are often presented in a dull and complicated way,\" Stewart told Business Insider. \"I have an advantage over school math teachers: I'm not trying to show you how to do the sums yourself.\"\n『方程式肯定会显得沉闷，而且它们看起来很复杂，但那是因为它们经常以这样的方式呈现，』斯图尔特告诉Business Insider。 『我比学校的数学老师更有优势：我不会试图告诉你如何自己算出它们。』\nHe explained that anyone can \"appreciate the beauty and importance of equations without knowing how to solve them ... The intention is to locate them in their cultural and human context, and pull back the veil on their hidden effects on history.\"\n他解释说，任何人都可以『欣赏方程式的美丽和重要性，而不去知道如何解它们……目的是将它们置于文化和人文环境中，并揭开它们对历史隐藏效应的面纱。』\nStewart continued that \"equations are a vital part of our culture. The stories behind them — the people who discovered or invented them and the periods in which they lived — are fascinating.\"\n斯图尔特继续说道，『方程式是我们文化的重要组成部分。他们背后的故事——发现或发明它们的人以及他们生活的时期——都很吸引人。』\nHere are 17 equations that have changed the world:\n以下是改变世界的17个方程式：\nMax Nisen contributed to an earlier version of this post.\nMax Nisen为本文的早期版本做出了贡献。\n\n## The Pythagorean Theorem\n\n$$a^{2}+b^{2}=c^{2}$$\nPythagoras, 530 BC\nWhat does it mean? The square of the hypotenuse of a right triangle is equal to the sum of the squares of its legs.\n作用：直角三角形的斜边的平方等于其直角边的平方和。\nHistory: Though attributed to Pythagoras, it is not certain that he was the first person to prove it. The first clear proof came from Euclid, and it is possible the concept was known 1,000 years before Pythagoras by the Babylonians.\n历史：虽然认为毕达哥拉斯（Pythagoras）发现了这个公式，但不确定他是否是第一个证明它的人。第一个明确的证明来自欧几里得，而这个概念可能是在毕达哥拉斯之前1000年就被巴比伦人知道了。\nImportance: The equation is at the core of much of geometry, links it with algebra, and is the foundation of trigonometry. Without it, accurate surveying, mapmaking, and navigation would be impossible.\n重要性：勾股定理是几何的核心，它与代数联系起来，是三角学的基础。没有它，准确的测量、地图制作和导航将是不可能的。\nIn terms of pure math, the Pythagorean Theorem defines normal, Euclidean plane geometry. For example, a right triangle drawn on the surface of a sphere like the Earth doesn't necessarily satisfy the theorem.\n在纯数学方面，毕达哥拉斯定理定义了正常的欧几里德平面几何。例如，在像地球一样的球体表面上绘制的直角三角形不一定满足该定理。\nModern use: Triangulation is used to this day to pinpoint relative location for GPS navigation.\n现代用途：今天使用三角测量来确定GPS导航的相对位置。\n\n<!-- more -->\n## The logarithm and its identities\n\n$$\\log xy=\\log x+\\log y$$\nJohn Napier, 1610\nWhat does it mean? You can multiply numbers by adding related numbers.\n作用：你可以将两个数字的对数相加来计算乘积。\nHistory: The initial concept was discovered by the Scottish Laird John Napier of Merchiston in an effort to make the multiplication of large numbers, then incredibly tedious and time consuming, easier and faster. It was later refined by Henry Briggs to make reference tables easier to calculate and more useful.\n历史：最初的概念是由苏格兰爱丁堡附近的小镇梅奇斯顿的地主约翰·纳皮尔（John Napier）发现的，旨在使大数乘法——当时令人难以置信的繁琐和耗时，变得更容易和更快。后来Henry Briggs对其进行了改进，使参考表更容易计算，更有用。\nImportance: Logarithms were revolutionary, making calculation faster and more accurate for engineers and astronomers. That's less important with the advent of computers, but they're still an essential to scientists.\n重要性：对数是革命性的，使工程师和天文学家的计算更快，更准确。随着计算机的出现，这一点就不那么重要了，但它们对科学家来说仍然是必不可少的。\nModern use: Logarithms, and the related exponential functions, are used to model everything from compound interest to biological growth to radioactive decay.\n现代用途：对数和指数函数用于为从复利到生物生长到放射性衰变的所有事物建模。\n\n## Calculus\n\n$$\\frac{df}{dt}=\\lim_{h \\to 0}=\\frac{f(t+h)-f(t)}{h}$$\nIsaac Newton, 1668\nWhat does it mean? Allows the calculation of an instantaneous rate of change.\n作用：允许对瞬时变化率的计算。\nHistory: Calculus as we currently know it was described around the same time in the late 17th century by Isaac Newton and Gottfried Leibniz. There was a lengthy debate over plagiarism and priority which may never be resolved. We use the leaps of logic and parts of the notation of both men today.\n历史：我们现在所知道的微积分是在17世纪晚期由艾萨克·牛顿（Isaac Newton）和戈特弗里德·莱布尼兹（Gottfried Leibniz）几乎同时描述的。关于剽窃和谁先提出微积分的争论持续了很久，可能永远无法解决。我们今天使用的正是两人的逻辑推导和部分符号系统。\nImportance: According to Stewart, \"More than any other mathematical technique, it has created the modern world.\" Calculus is essential in our understanding of how to measure solids, curves, and areas. It is the foundation of many natural laws, and the source of differential equations.\n重要性：根据斯图尔特的说法，『它比任何其他数学技术都更能创造现代世界。』在我们理解如何测量固体，曲线和面积时，微积分是必不可少的。它是许多自然法则的基础，也是微分方程的来源。\nModern use: Any mathematical problem where an optimal solution is required. Essential to medicine, economics, physics, engineering, and computer science.\n现代用途：需要最佳解决方案的任何数学问题。对医学，经济学，物理学，工程学和计算机科学至关重要。\n\n## Newton's universal law of gravitation\n\n$$F=G\\frac{m_1 m_2}{r^2}$$\nIsaac Newton, 1687\nWhat does it mean? Calculates the force of gravity between two objects.\n作用：计算两个物体之间的引力大小。\nHistory: Isaac Newton derived his laws based on earlier astronomical and mathematical work by Johannes Kepler. He also used, and possibly plagiarized the work of Robert Hooke.\n历史：牛顿根据开普勒先前的天文学和数学工作得出了他的定律。他也使用了（也可能是抄袭）罗伯特·胡克的工作。\nImportance: Used techniques of calculus to describe how the world works. Even though it was later supplanted by Einstein's theory of relativity, it is still essential for a practical description of how objects in space, like stars, planets, and human-made spacecraft, interact with each other. We use it to this day to design orbits for satellites and probes.\n重要性：使用微积分技术来描述世界是如何运作的。尽管它后来被爱因斯坦的相对论所取代，但对于空间中的物体如恒星，行星和人造宇宙飞船如何相互作用仍然是必不可少的。我们今天用它来设计卫星和探测器的轨道。\nPhilosophically, Newton's law is important because it describes how gravity works everywhere, from a ball falling to the ground on Earth to the evolution of galaxies and the universe as a whole. While we take the idea of universal laws for granted today, in earlier eras the idea that the terrestrial and celestial worlds shared the same properties was revolutionary.\n从哲学上讲，牛顿定律很重要，因为它描述了引力如何在任何地方起作用——从地球上的物体掉在地上，到星系和整个宇宙的演化。虽然我们今天认为普适的物理定律是理所当然的，但在早期的时代，地球和天体拥有相同属性的想法是革命性的。\nModern use: Although, as mentioned above, for practical uses Newton's law has been augmented by Einstein's theories, the basic idea of Newtonian gravity is still a useful approximation for how things behave in space.\n现代用途：尽管如上所述，对于实际应用，牛顿定律已经被爱因斯坦的理论所增强，但牛顿引力的基本思想仍然是对事物在空间中表现的有用近似。\n\n## Complex numbers\n\n$$i^2=-1$$\nEuler, 1750\nWhat does it mean? Mathematicians can expand our idea of what numbers are by introducing the square roots of negative numbers.\n作用：数学家可以通过引入负数的平方根来扩展我们对数字的概念。\nHistory: Imaginary numbers were originally posited by famed gambler/mathematician Girolamo Cardano, then expanded by Rafael Bombelli and John Wallis. They still existed as a peculiar, but essential problem in math until William Hamilton described this definition.\n历史：虚数最初由著名的赌徒/数学家Girolamo Cardano提出，然后由Rafael Bombelli和John Wallis扩展。在威廉·汉密尔顿描述这个定义之前，它们仍然是数学中一个特殊的但必不可少的问题。\nThe imaginary and complex numbers are mathematically very elegant. Algebra works perfectly the way we want it to — any equation has a complex number solution, a situation that is not true for the real numbers: $x^2 + 4 = 0$ has no real number solution, but it does have a complex solution: the square root of -4, or 2i. Calculus can be extended to the complex numbers, and by doing so, we find some amazing symmetries and properties of these numbers.\n虚数和复数在数学上非常优雅。代数以我们想要的方式完美地工作——任何方程都有一个复数解，而却不一定有实数解：$x^2 + 4 = 0$没有实数解，但它确实有一个复杂的解决方案：-4的平方根或2i。微积分可以扩展到复数，通过这样做，我们发现了这些数字的一些惊人的对称性和属性。\nImportance: According to Stewart \".... most modern technology, from electric lighting to digital cameras could not have been invented without them.\" The extension of calculus to the complex numbers, a branch of math called \"complex analysis,\" is essential to understanding electrical systems and a variety of modern data processing algorithms.\n重要性：根据斯图尔特的说法『……最现代的技术，从电子照明到数码相机，如果没有它们，就无法发明。』微积分扩展到复数，这是一个称为『复分析』的数学分支，对于理解电气系统和各种现代数据处理算法至关重要。\nModern use: Used broadly in electrical engineering and mathematical theory.\n现代用途：广泛用于电气工程和数学理论。\n\n## Euler's formula for polyhedra\n\n$$V-E+F=2$$\nEuler, 1751\nWhat does it mean? Describes a numerical relationship that is true of all solid shapes of a particular type.\n作用：描述了对特定类型的所有简单多面体都适用的数字关系。\nHistory: This was developed by the great 18th century mathematician Leonhard Euler.Polyhedra are the three-dimensional versions of polygons, like the cube to the right. The corners of a polyhedron are called its vertices, the lines connecting the vertices are its edges, and the polygons covering it are its faces.\n历史：这是由伟大的18世纪数学家莱昂哈德·欧拉（Leonhard Euler）开发的。Polyhedra，即多面体，是多边形的三维版本，它的角被称为顶点，连接顶点的线是它的边，覆盖它的多边形是它的面。\nA cube has 8 vertices, 12 edges, and 6 faces. If I add the vertices and faces together, and subtract the edges, I get 8 + 6 - 12 = 2.\n立方体有8个顶点，12个边和6个面。如果我将顶点和面加在一起，并减去边，我得到8 + 6 - 12 = 2。\nEuler's formula states that, as long as your polyhedron is somewhat well behaved, if you add the vertices and faces together, and subtract the edges, you will always get 2. This will be true whether your polyhedron has 4, 8, 12, 20, or any number of faces.\nEuler的公式表明，只要你的多面体是常规的，如果你将顶点和面加在一起，并减去边，你将总是得到2。无论你的多面体是4、8、12、20还是任何数量的面数，都是如此。\nImportance: Fundamental to the development of topology, which extends geometry to any continuous surface.\n重要性：拓扑开发的基础，将几何扩展到任何连续的表面。\nModern use: Topology is used to understand the behavior and function of DNA, and it is an underlying part of the mathematical tool kit used to understand networks like social media and the internet.\n现代用途：拓扑用于理解DNA的行为和功能，它是用于理解社交媒体和互联网等网络的数学工具包的基础部分。\n\n## The normal distribution\n\n$$\\Phi(x)=\\frac{1}{\\sqrt{2\\pi\\rho}}e^{\\frac{(x-\\mu)^2}{2\\rho^{2}}}$$\nC.F.Gauss, 1810\nWhat does it mean? Defines the standard normal distribution, a bell shaped curve in which the probability of observing a point is greatest near the average, and declines rapidly as one moves away.\n作用：定义了标准正态分布，一种钟形曲线，其中概率在平均值附近最大，并在离开平均值处迅速下降。\nHistory: The initial work was by Blaise Pascal, but the distribution came into its own with Bernoulli. The bell curve as we currently comes from Belgian mathematician Adolphe Quetelet.\n历史：最初的工作是由帕斯卡（Blaise Pascal）完成的，但是伯努利发扬了它。我们目前使用的来自比利时数学家Adolphe Quetelet。\nImportance: The equation is the foundation of modern statistics. Science and social science would not exist in their current form without it. Statistical experiment design relies on the properties of the normal curve, and how those properties relate to errors that can occur when taking a random sample.\n重要性：这个式子是现代统计学的基础。没有它，科学和社会科学就不会以现在的形式存在。统计实验设计依赖于正态曲线的属性，以及这些属性如何与采用随机样本时可能发生的错误相关。\nModern use: Used to determine whether drugs are sufficiently effective in clinical trials.\n现代用途：用于确定药物在临床试验中是否足够有效。\n\n## The wave equation\n\n$$\\frac{\\partial^2 u}{\\partial t^2}=c^2\\frac{\\partial^2 u}{\\partial x^2}$$\nJ.d'Almbert, 1746\nWhat does it mean? A differential equation that describes the behavior of waves, like the behavior of a vibrating violin string.\n作用：描述波动行为的微分方程，如振动的小提琴弦的行为。\nHistory: The mathematicians Daniel Bournoulli and Jean D'Alembert were the first to describe this relationship in the 18th century, albeit in slightly different ways.\n历史：数学家伯努利（Daniel Bournoulli）和达朗贝尔（Jean D'Alembert）是最初在18世纪描述这种关系的人，尽管方式略有不同。\nImportance: The behavior of waves generalizes to the way sound works, how earthquakes happen, and the behavior of the ocean.\n重要性：波动的行为概括了声音的产生，地震的发生方式以及海洋的行为。\nThe techniques developed to solve the wave equation have been very useful in solving similar types of equations as well.\n为解决波动方程而开发的技术在解决相似类型的方程方面也非常有用。\nModern use: Oil companies set off explosives, then read data from the ensuing sound waves to predict geological formations.\n现代用途：石油公司引爆炸药，然后从随后的声波中读取数据以预测地质构造。\n\n## The Fourier transform\n\n$$f(\\omega)=\\int_{-\\infty}^{+\\infty}f(x)e^{-2\\pi ix\\omega}dx$$\nJ. Fourier, 1822\nWhat does it mean? Describes patterns in time as a function of frequency.\n作用：描述作为频率函数的时间模式。\nHistory: Joseph Fourier discovered the equation, which extended from his famous solution to a differential equation describing how heat flows, and the previously described wave equation.\n历史：约瑟夫·傅立叶（Joseph Fourier）发现了这个等式，这是从他著名的热传导方程，以及前面的波动方程的解决方案所扩展得到的。\nImportance: The equation allows for complex wave patterns, like music, speech, or images, to be broken up, cleaned up, and analyzed. This is essential in many types of signal analysis.\n重要性：该等式允许分解、清理和分析复杂的波形图案，如音乐，语音或图像。这在许多类型的信号分析中都是必不可少的。\nModern use: Used to compress information for the JPEG image format and discover the structure of molecules.\n现代用途：用于压缩JPEG图像格式的信息并发现分子的结构。\n\n## The Navier-Stokes equations\n\n$$\\rho(\\frac{\\partial \\vec{v}}{\\partial t}+\\vec{v}\\cdot \\nabla \\vec{v})=-\\nabla p+\\nabla \\cdot \\stackrel{\\rightarrow \\rightarrow}{\\mathbb{T}}+\\rho\\vec{f}$$\nC.Navier, G.Stokes, 1845\nWhat does it mean? The Navier-Stokes equations are the fundamental physical equation that describes how fluids work. The left side is the acceleration of a small amount of fluid, the right indicates the forces that act upon it.\n作用：纳维尔-斯托克斯（Navier-Stokes）方程是描述流体如何运动的基本物理方程。左侧是少量液体的加速度，右侧表示作用在其上的力。\nHistory: Leonhard Euler made the first attempt at modeling fluid movement. French engineer Claude-Louis Navier and Irish mathematician George Stokes made the leap to the model still used today.\n历史：莱昂哈德·欧拉首次尝试对流体运动进行建模。法国工程师纳维尔（Claude-Louis Navier）和爱尔兰数学家斯托克斯（George Stokes）创建了今天仍在使用的模型，实现了质的飞跃。\nImportance: Once computers became powerful enough to approximately solve this equation, it opened up a complex and very useful field of physics. It is particularly useful in making vehicles more aerodynamic.\n重要性：一旦计算机变得强大到足以大致解决这个等式，它就开辟了一个复杂且非常有用的物理领域。它特别适用于使车辆设计得更具空气动力学性能。\nWhile we can use modern computers to make practical approximate simulations of fluid dynamics that are useful in engineering, finding a mathematically exact solution (or even knowing whether or not an exact solution exists in all cases) is still an open question, one whose answer is attached to a million-dollar prize.\n虽然我们可以使用现代计算机对工程中有用的流体动力学进行实际的近似模拟，但找到一个数学上精确的解决方案（或者甚至知道在所有情况下是否存在精确解决方案）仍然是一个悬而未决的问题，它被悬赏了一百万美元的奖金。\nModern use: Among other things, allowed for the development of modern passenger jets.\n现代用途：现代客机的发展离不开它。\n\n## Maxwell's equations\n\n$$\\nabla\\cdot\\vec{E} = \\frac{\\rho}{\\epsilon_0}$$\n$$\\nabla\\cdot\\vec{B} = 0 $$\n$$\\nabla\\times\\vec{E} = -\\frac{\\partial B}{\\partial t} $$\n$$\\nabla\\times\\vec{B} = \\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t} \\right)$$\nJ.C.Maxwell, 1865\nWhat does it mean? Maps out the relationship between electric and magnetic fields.\n作用：描述了电场和磁场之间的关系。\nHistory: Michael Faraday did pioneering work on the connection between electricity and magnetism, and James Clerk Maxwell translated it into these equations. Maxwell's equations were for classical electromagnetism what Newton's laws of motion were for classical mechanics.\n历史：迈克尔·法拉第（Michael Faraday）在电力和磁力之间的联系方面做了开创性的工作，而詹姆斯·克拉克斯·麦克斯韦（James Clerk Maxwell）将它们写入了方程组。麦克斯韦方程组用于经典电磁学，而牛顿的运动定律是经典力学的。\nImportance: Helped understand electromagnetic waves, helping to create most modern electrical and electronic technology.\n重要性：帮助了解电磁波，帮助创造了最现代化的电气和电子技术。\nModern use: Radar, television, and modern communications.\n现代用途：雷达，电视和现代通讯。\n\n## Second law of thermodynamics\n\n$$dS\\ge0$$\nL.Boltzmann, 1874\nWhat does it mean? Energy and heat dissipate over time.\n作用：孤立系统的熵随着时间的推移而增加。\nHistory: Sadi Carnot first posited that nature does not have reversible processes. Mathematician Ludwig Boltzmann extended the law, and William Thomson formally stated it.\n历史：萨迪·卡诺（Sadi Carnot）首先假定大自然没有可逆的过程。数学家玻尔兹曼（Ludwig Boltzmann）扩展了这一定律，威廉·汤姆森（William Thomson）正式声明了这一点。\nImportance: Essential to our understanding of energy and the universe via the concept of entropy. Thermodynamic entropy is, roughly speaking, a measure of how disordered a system is. A system that starts out in an ordered, uneven state — say, a hot region next to a cold region — will always tend to even out, with heat flowing from the hot area to the cold area until evenly distributed.\n重要性：通过熵的概念对能量和宇宙的理解是必不可少的。粗略地说，热力学熵是衡量系统混乱程度的一种方法。一个以有序，不均匀状态开始的系统——比如一个寒冷地区旁边的炎热区域——将始终趋于均匀，热量从热区流向冷区直到均匀分布。\nModern use: Thermodynamics underlies much of our understanding of chemistry and is essential in building any kind of power plant or engine.\n现代用途：热力学是我们对化学的理解的基础，对于建造任何类型的发电厂或发动机至关重要。\n\n## Einstein's theory of relativity\n\n$$E=mc^2$$\nEinstein, 1905\nWhat does it mean? Energy and matter are two sides of the same coin.\n作用：能量和物质是同一枚硬币的两面。\nHistory: The genesis of Einstein's equation was an experiment by Albert Michelson and Edward Morley that proved light did not move in a Newtonian manner in comparison to changing frames of reference. Einstein followed up on this insight with his famous papers on special relativity (1905) and general relativity (1915).\n历史：爱因斯坦质能方程的起源是艾伯特·迈克尔逊和爱德华·莫雷的实验，他们证明光相对变化的参考系没有以牛顿预言的方式运动。爱因斯坦用他关于狭义相对论（1905）和广义相对论（1915）的着名论文跟进了这一见解。\nSpecial relativity brought in ideas like the speed of light being a universal speed limit and the passage of time being different for people moving at different speeds.\n狭义相对论带来了诸如光速是宇宙中速度上限的想法，以及时间的流逝对于以不同速度运动的人来说是不同的。\nGeneral relativity describes gravity as a curving and folding of space and time themselves, and was the first major change to our understanding of gravity since Newton's law. General relativity is essential to our understanding of the origins, structure, and ultimate fate of the universe.\n广义相对论将重力描述为空间和时间本身的弯曲和折叠，并且是自牛顿定律以来我们对引力理解的第一次重大改变。广义相对论对于我们理解宇宙的起源，结构和最终命运至关重要。\nImportance: Probably the most famous equation in history. Completely changed our view of matter and reality.\n重要性：可能是历史上最着名的等式。完全改变了我们对物质和现实的看法。\nModern use: Helped lead to nuclear weapons, and if GPS didn't account for it, your directions would be off thousands of yards.\n现代用途：质能方程是核武器制造的理论基础；而如果GPS没有考虑相对论，你的方向将偏离数千码。\n\n## The Schrödinger equation\n\n$$i\\hbar\\frac{\\partial}{\\partial t}\\Psi=H\\Psi$$\nE.Schrodinger, 1927\nWhat does it mean? This is the main equation in quantum physics. Models matter as a wave, rather than a particle.\n作用：这是量子物理学的主要方程。模型的特性像波而非粒子。\nHistory: Louis-Victor de Broglie pinpointed the dual nature of matter in 1924. The equation you see was derived by Erwin Schrödinger in 1927, building off of the work of physicists like Werner Heisenberg. It describes the way subatomic particles and atoms evolve over time.\n历史：德布罗意（Louis-Victor de Broglie）在1924年确定了物质波粒二象性。你看到的等式是由薛定谔（Erwin Schrödinger）在1927年得出的，它建立了像海森堡（Werner Heisenberg）这样的物理学家的工作。它描述了亚原子粒子和原子随时间演变的方式。\nImportance: Revolutionized the view of physics at small scales. The insight that particles at that level exist at a range of probable states was revolutionary.\n重要性：在微观范围内彻底改变了物理学的观点。对于『微观状态下的粒子存在于一系列可能状态』的洞察是革命性的。\nModern quantum mechanics and general relativity are the two most successful scientific theories in history — all of the experimental observations we have made to date are entirely consistent with their predictions.\n现代量子力学和广义相对论是历史上最成功的两个科学理论——我们迄今为止所做的所有实验观察都完全符合他们的预测。\nModern use: Quantum mechanics is necessary for most modern technology — nuclear power, semiconductor-based computers, and lasers are all built around quantum phenomena.\n现代用途：量子力学是大多数现代技术所必需的——核能，半导体计算机和激光都是围绕量子现象建立的。\n\n## Shannon's information theory\n\n$$H=-\\sum p(x)logp(x)$$\nC.Shannon, 1949\nWhat does it mean? Estimates the amount of data in a piece of code by the probabilities of its component symbols.\n作用：通过其组件符号的确定性来估计一段代码中的数据量。\nHistory: Developed by Bell Labs engineer Claude Shannon in the years after World War 2.\n历史：由贝尔实验室工程师香农（Claude Shannon）在第二次世界大战后的几年中开发。\nImportance: The equation given here is for Shannon information entropy. As with the thermodynamic entropy given above, this is a measure of disorder. In this case, it measures the information content of a message — a book, a JPEG picture sent on the internet, or anything that can be represented symbolically. The Shannon entropy of a message represents a lower bound on how much that message can be compressed without losing some of its content.\n重要性：这里给出的等式是香农信息熵。与上面给出的热力学熵一样，这是一种无序的量度。在这种情况下，它测量消息的信息内容——书籍，在互联网上发送的JPEG图片，或者可以象征性地表示的任何内容。消息的香农熵表示该消息可被压缩多少而不会丢失其某些内容的下限。\nModern use: Shannon's entropy measure launched the mathematical study of information, and his results are central to how we communicate over networks today.\n现代用途：信息熵的测量推出了信息的数学研究，他的结果对于我们今天如何通过网络进行通信至关重要。\n\n## The logistic model for population growth\n\n$$x_{t+1}=kx_t (1-x_t)$$\nRobert May, 1975\nWhat does it mean? Estimates the change in a population of creatures across generations with limited resources. Importantly, this equation can lead to chaotic behavior.\n作用：估计资源有限的几代人生物群体的变化。重要的是，这个等式可能导致混沌的行为。\nHistory: Robert May was the first to point out that this model of population growth could produce chaos in 1975. Important work by mathematicians Vladimir Arnold and Stephen Smale helped with the realization that chaos is a consequence of differential equations.\n\n历史：罗伯特·梅（Robert May）是第一个指出这种人口增长模式可能在1975年产生混沌的人。数学家弗拉基米尔·阿诺德和斯蒂芬·萨马​​尔的重要工作有助于认识到混沌是微分方程的结果。\nFor certain values of k, the map shows chaotic behavior: if we start at some particular initial value of x, the process will evolve one way, but if we start at another initial value, even one very very close to the first value, the process will evolve a completely different way.\n对于k的某些值，地图显示混沌行为：如果我们从x的某个特定初始值开始，则该过程将以单向进化，但如果我们从另一个初始值开始，即使非常接近第一个值，过程将以完全不同的方式发展。\nImportance: Helped in the development of chaos theory, which has completely changed our understanding of the way that natural systems work.\n重要性：帮助混沌理论的发展，这完全改变了我们对自然系统工作方式的理解。\nWe see chaotic behavior — behavior sensitive to initial conditions — like this in many areas. Weather is a classic example — a small change in atmospheric conditions on one day can lead to completely different weather systems a few days later, most commonly captured in the idea of a butterfly flapping its wings on one continent causing a hurricane on another continent.\n我们看到混乱行为——对初始条件敏感的行为——在许多领域都是如此。天气是一个典型的例子——一天大气条件的微小变化可能导致几天后完全不同的天气系统，最常见的是蝴蝶在一个大陆上扇动翅膀，就可能导致另一个大陆上的飓风。\nModern use: Used to model earthquakes and forecast the weather.\n现代用途：用于模拟地震和预报天气。\n\n## The Black–Scholes model\n\n$$\\frac{1}{2}\\sigma^2S^2\\frac{\\partial^2V}{\\partial S^2}+rS\\frac{\\partial V}{\\partial S}+\\frac{\\partial V}{\\partial t}-rV=0$$\nF.Black, M.Scholes, 1990\nWhat does it mean? Prices a derivative based on the assumption that it is riskless and that there is no arbitrage opportunity when it is priced correctly.\n作用：基于假设它是无风险的并且在正确定价时没有套利机会来定价衍生品。\nHistory: Developed by Fischer Black and Myron Scholes, then expanded by Robert Merton. The latter two won the 1997 Nobel Prize in Economics for the discovery.\n历史：由Fischer Black和Myron Scholes开发，然后由Robert Merton扩展。后两者因此获得了1997年诺贝尔经济学奖。\nImportance: Helped create the now multi-trillion dollar derivatives market. It is argued that improper use of the formula (and its descendants) contributed to the financial crisis. In particular, the equation maintains several assumptions that do not hold true in real financial markets.\n重要性：帮助创造了现在数万亿美元的衍生品市场。有人认为，不恰当地使用公式（及其推论）会导致金融危机。特别是，该等式保留了几个在实际金融市场中不成立的假设。\nModern use: Variants are still used to price most derivatives, even after the financial crisis.\n现代用途：即使在金融危机之后，它的变体仍然被用来为大多数衍生品定价。\n\n---\n\n本文翻译自：[17 Equations That Changed the World](https://www.businessinsider.com/equations-that-changed-the-world-2016-3)\n\n购书链接：[17 Equations That Changed the World](https://www.amazon.com/gp/product/0465029736)\n","categories":["物理"]},{"title":"详解CSRF与XSS攻击","url":"/2018-07/详解CSRF与XSS攻击/","content":"\n在[之前的一篇文章](/2018-07/WordPress中文验证码/)中，提到了WordPress的插件审核机制，其中对于代码安全性的要求，主要就是对CSRF与XSS攻击的防范。官方邮件中这样写道：\n\n> ## Not using Nonces and/or checking permissions\n> Please add a nonce to your POST calls to prevent unauthorized access.\n> Keep in mind, check_admin_referer alone is NOT bulletproof security. Do not rely on nonces for authorization purposes. Use current_user_can() in order to prevent users without the right permissions from accessing things.\n\n> ## Please sanitize, escape, and validate your POST calls \n> When you include POST/GET/REQUEST/FILE calls in your plugin, it's important to sanitize, validate, and escape them. The goal here is to prevent a user from accidentally sending trash data through the system, as well as protecting them from potential security issues.\n> SANITIZE: Data that is input (either by a user or automatically) must be sanitized. This lessens the possibility of XSS vulnerabilities and MITM attacks where posted data is subverted.\n> VALIDATE: All data should be validated as much as possible. Even when you sanitize, remember that you don't want someone putting in 'dog' when the only valid values are numbers.\n> ESCAPE: Data that is output must be escaped properly, so it can't hijack admin screens. There are many esc_*() functions you can use to make sure you don't show people the wrong data.\n> To help you with this, WordPress comes with a number of sanitization and escaping functions. You can read about those here: https://developer.wordpress.org/plugins/security/securing-input/\n> Remember: You must use the MOST appropriate functions for the context. If you're sanitizing email, use sanitize_email(), if you're outputting HTML, use esc_html(), and so on.\n> Clean everything, check everything, escape everything, and never trust the users to always have input sane data.\n\n下面通过维基百科的内容介绍CSRF与XSS攻击的具体形式。\n\n<!-- more -->\n## CSRF\n\n跨站请求伪造（英语：Cross-site request forgery），也被称为one-click attack或者session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。\n\n### 攻击的细节\n\n跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：**简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**。\n\n#### 例子\n\n假如一家银行用以执行转账操作的URL地址为`http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName`，那么，一个恶意攻击者可以在另一个网站上放置如下代码：\n```\n<img src=\"<http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman>\">\n```\n如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。\n这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着**如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险**。\n透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是**欺骗用户浏览器，让其以用户的名义执行操作**。\n\n### 防御措施\n\n#### 检查Referer字段\n\nHTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于`www.examplebank.com`之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于`www.examplebank.com`之下，这时候服务器就能识别出恶意的访问。\n这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。\n\n#### 添加校验token\n\n由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求。\n\n## XSS\n\n跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。\nXSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。\n\n### 背景和现状\n\n当网景（Netscape）最初推出JavaScript语言时，他们也察觉到准许网页服务器发送可执行的代码给一个浏览器的安全风险（即使仅是在一个浏览器的沙盒里）。它所造成的一个关键的问题在于用户同时打开多个浏览器视窗时，在某些例子里，网页里的片断代码被允许从另一个网页或对象取出数据，而因为恶意的网站可以用这个方法来尝试窃取机密信息，所以在某些情形，这应是完全被禁止的。为了解决这个问题，浏览器采用了同源决策——仅允许来自相同域名系统和使用相同协议的对象与网页之间的任何交互。这样一来，恶意的网站便无法借由JavaScript在另一个浏览器窃取机密数据。此后，为了保护用户免受恶意的危害，其他的浏览器与服务端指令语言采用了类似的访问控制决策。\nXSS漏洞可以追溯到1990年代。大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter，Facebook，MySpace，Orkut，新浪微博和百度贴吧。研究表明，最近几年XSS已经超过缓冲区溢出成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2010年统计数据，在Web安全威胁前10位中，XSS排名第2，仅次于代码注入（Injection）。\n\n### 攻击手段和目的\n\n攻击者使被攻击者在浏览器中执行脚本后，如果需要收集来自被攻击者的数据（如cookie或其他敏感信息），可以自行架设一个网站，让被攻击者通过JavaScript等方式把收集好的数据作为参数提交，随后以数据库等形式记录在攻击者自己的服务器上。\n常用的XSS攻击手段和目的有：\n- 盗用cookie，获取敏感信息。\n- 利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。\n- 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n- 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n- 在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。\n\n### 漏洞的防御和利用\n\n#### 过滤特殊字符\n\n避免XSS的方法之一主要是将用户所提供的内容进行过滤，许多语言都有提供对HTML的过滤：\n- PHP的`htmlentities()`或是`htmlspecialchars()`。\n- Python的`cgi.escape()`。\n- ASP的`Server.HTMLEncode()`。\n- ASP.NET的`Server.HtmlEncode()`或功能更强的Microsoft Anti-Cross Site Scripting Library。\n- Java的xssprotect(Open Source Library)。\n- Node.js的node-validator。\n\n#### 使用HTTP头指定类型\n\n很多时候可以使用HTTP头指定内容的类型，使得输出的内容避免被作为HTML解析。如在PHP语言中使用以下代码：\n```php\n<?php\n    header('Content-Type: text/javascript; charset=utf-8');\n?>\n```\n即可强行指定输出内容为文本/JavaScript脚本（顺便指定了内容编码），而非可以引发攻击的HTML。\n\n#### 用户方面\n\n包括Internet Explorer、Mozilla Firefox在内的大多数浏览器皆有关闭JavaScript的选项，但关闭功能并非是最好的方法，因为许多网站都需要使用JavaScript语言才能正常运作。通常来说，一个经常有安全更新推出的浏览器，在使用上会比很久都没有更新的浏览器更为安全。\n\n---\n\n参考文章：\n[跨站请求伪造 - 维基百科](https://en.wikipedia.org/wiki/Cross-site_request_forgery)\n[跨站脚本 - 维基百科](https://en.wikipedia.org/wiki/Cross-site_scripting)\n[WordPress Nonces](https://codex.wordpress.org/WordPress_Nonces)\n[Securing Input](https://developer.wordpress.org/plugins/security/securing-input)\n","tags":["HTML"],"categories":["技术"]},{"title":"Hexo内容压缩","url":"/2018-07/Hexo内容压缩/","content":"\nHexo生成的博客静态页面可能存在一个问题：由于主题模版的关系，生成的页面中会有大量空白行。虽然这对浏览器的渲染影响微乎其微，但是让强迫症极为难受。一种解决方法是使用Python对页面进行处理。可以在博客的根目录下（与`public`文件夹同级）新建以下Python脚本：\n```python\n#!/usr/bin/env python3\n\nimport os\n\ndef minify_html(srcPath):\n    for root, dirs, files in os.walk(srcPath, topdown = True):\n        for name in files:\n            if name.find(\".html\") == -1:\n                continue\n            filename = os.path.join(root, name)\n            with open(filename, \"r\") as p:\n                with open(filename + \".tmp\", \"w\") as t:\n                    while True:\n                        l = p.readline()\n                        if not l:\n                            break\n                        l = l.strip()\n                        if l:\n                            t.write(l + \"\\n\")\n            os.remove(filename)\n            os.rename(filename + \".tmp\", filename)\n            print(\"\\033[32mINFO\\033[0m  Minified: \\033[35m%s\\033[0m\" % filename)\n\nminify_html(\"public\")\n```\n这样，在每次执行`hexo d`之前，执行该脚本，就可以上传压缩后的页面了。\n\n<!-- more -->\n如果Hexo博客托管在GitHub Pages等第三方平台上，为了减少页面的加载时间，对图片等内容进行CDN加速是一个不错的方法。当然，还有一个更为直接的方法，那就是通过降低分辨率来减少图片大小。这是压缩图片的脚本：\n```python\n#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nfrom PIL import Image\nimport os\nimport shutil\n\ndef compress_image(srcPath, dstPath):\n    for filename in os.listdir(srcPath):\n        if not os.path.exists(dstPath):\n            os.makedirs(dstPath)\n\n        srcFile = os.path.join(srcPath, filename)\n        dstFile = os.path.join(dstPath, filename)\n        if os.path.isfile(srcFile):\n            if os.path.isfile(dstFile) or (not srcFile.endswith(\".jpg\") and not srcFile.endswith(\".png\")):\n                continue\n            if os.path.getsize(srcFile) <= 300000:\n                shutil.copyfile(srcFile, dstFile)\n                continue\n            sImg = Image.open(srcFile)\n            w, h = sImg.size\n            dImg = sImg.resize((w * 2 / 3, h * 2 / 3), Image.ANTIALIAS)\n            dImg.save(dstFile)\n            print(\"\\033[32mINFO\\033[0m  Minified: \\033[35m%s\\033[0m\" % dstFile)\n\n        elif os.path.isdir(srcFile):\n            compress_image(srcFile, dstFile)\n\ncompress_image(\"images\", \"source/images\")\n```\n在每次执行`hexo g`之前，在博客的主目录下执行该脚本，就可以将images目录下的高分辨率图片，压缩并存储到source/images目录下。如果要在Markdown文件中插入图片，使用`![](//images/2018-07/path/to/your/image)`即可。\n这里用了递归的写法，有兴趣的话，你也可以使用`os.walk()`方法改写以上脚本，这可能会更加简洁。\n\n---\n\n参考文章：\n[hexo next主题大量空白行问题](https://blog.jiangjiaolong.com/hexo-next-theme-minify.html)\n[python脚本编程：批量压缩图片大小](https://blog.csdn.net/u012234115/article/details/50248409)\n\n本文更新于2018年11月15日：\n也可以使用官方的插件：[hexo-html-minifier](https://github.com/hexojs/hexo-html-minifier)\n不过这个插件的去除注释功能不太智能，会把`<!-- more -->`也一并去除，导致Read More功能失效。\n\n本文更新于2018年11月20日：\n博主发现了一个不错的工具，涵盖了以上功能：[hexo-all-minifier](https://github.com/chenzhutian/hexo-all-minifier)\n","tags":["Python","Hexo"],"categories":["程序设计"]},{"title":"WordPress中文验证码","url":"/2018-07/WordPress中文验证码/","content":"\n反机器人和垃圾评论是个人博客老生常谈的话题。除了特征识别算法外，最普遍使用的屏蔽方法就是验证码了。在WordPress插件库中，有着各式各样的验证码插件。然而，很多验证码插件都依赖于Google的reCAPTCHA，这在国内无法访问；而一些基于Session或文件验证的验证码插件功能和质量参差不齐，性能和安全性难以得到保障。虽然博主已经抛弃了WordPress转投Hexo静态博客（正如你所看到的这样），但考虑到WordPress中少有适合我国国情的验证码插件，故决定将一些主流图形验证码的功能进行整合，制作出一个全新的通用性更强的验证码解决方案。Mimi Captcha就这样诞生了。\n这是一个同时支持数字、大小写字母、中文、算术的图形验证码插件。它是基于Vinoj Cardoza的[Captcha Code](https://wordpress.org/plugins/captcha-code-authentication)在GPL协议下二次开发的。原项目存在的问题是，验证码中的字符采用同一字体在同一高度下顺序排列，这样非常容易被识别。改动过程中，加入了『超时时间』设置，以及对用户更为友好的『不区分大小写』设置。而验证码图片的生成算法，则进行了重构，很大程度上采用了[流水孟春](http://www.iteye.com/topic/469170)的方案。同时，在IP白名单等功能上，参考了[Captcha](https://wordpress.org/plugins/captcha)的代码。中文验证码和算术验证码则是新加入的功能，在原插件上拓展而成。最终效果如图：\n\n![](/images/2018-07/screenshot-1.png)\n\n<!-- more -->\n![](/images/2018-07/screenshot-2.png)\n![](/images/2018-07/screenshot-3.png)\n\n如果你对这个插件有任何意见或建议，敬请在评论区留言！\n代码可以在GitHub上查看：[Mimi Captcha](https://github.com/stevenjoezhang/mimi-captcha)\n同时也发布在了WordPress插件库：[Mimi Captcha](https://wordpress.org/plugins/mimi-captcha)\n顺便吐槽一下WordPress官方团队粗暴无礼的插件审核机制，真的是非常严格呢。（不过要确保插件的可靠性，严格一点也是必要的）\n最后要说的是，没有绝对安全的系统。中文验证码只是提高了机器人发布垃圾评论和暴力破解密码的成本，而管理员保持良好的使用习惯、进行合理的维护才是确保WordPress正常运行的关键。\n\n---\n\n拓展阅读：\n[知识库：使用Tesseract识别弱验证码](https://doc.yonyoucloud.com/doc/ae/920457.html)\n[【翻译】wordpress在后台自定义菜单页面上实现TAB页](https://pewae.com/2018/10/wordpress-settings-api-implementing-tabs-on-custom-menu-page.html)\n","tags":["WordPress","PHP"],"categories":["程序设计"]},{"title":"贝利乌鸦嘴历史","url":"/2018-06/贝利乌鸦嘴历史/","content":"\n2018年俄罗斯世界杯激战正酣，对于谁将捧起大力神杯，大家是不是已经做出了自己的预测？贝利近日在接受采访时就表示，现阶段自己更看好德国和法国队，因为德国是卫冕冠军，而法国队也具有很强的球队实力，他认为这两支球队有更大的可能会捧起今年的大力神杯。\n\n众所周知，球王贝利不仅在绿茵场上令人害怕，更有一项技能让他在退役后依然使世界足坛胆寒——那就是贝利令人发指的足球预测。贝利被称为世界足坛第一乌鸦嘴，只要被球王的嘴开过光的球队，多半就会输球。以至于如今很多球迷都跪求球王别看好自己的主队。下面就来回顾一下贝利的乌鸦嘴历史：\n\n- 贝利1977年首次访问中国时曾表示：『中国队很快就能进入世界杯。』这句话之后，中国队苦苦挣扎了20年，才在2002年勉强挤入世界杯。接着，1991年女足世界杯上，贝利进一步表扬中国男足，认为中国男足十年内能迈入世界一流行列，结果，中国男足根本不入流。除了中国队之外，贝利自1990年世界杯开始每逢大赛前都会进行预测，但是他的预测着实不太靠谱。\n- 1990年世界杯贝利公开预测南斯拉夫队将成为当届世界杯最大的黑马，结果，在预选赛第一场比赛后，南斯拉夫1:4被德国击败。该场比赛，马特乌斯进了两球。最后，南斯拉夫小组第二侥幸出线，四分之一决赛的时候，南斯拉夫被阿根廷『点杀』。贝利在预测谁将是黑马之后，又预测巴西队是最伟大最强的队伍，肯定夺冠，结果，巴西被阿根廷不多不少就打了一球，饮恨8分之一决赛。\n从这个时候开始，巴西以及南斯拉夫球迷开始怀疑贝利的嘴巴有毒，但尚未成燎原之势。最为有趣的是，成全他『乌鸦嘴』名号的，居然正是死敌——阿根廷队。\n- 在1991年世少赛上，加纳小将兰普提力压德尔·皮耶罗当选最佳球员。贝利预测兰普提将会是他的接班人。结果：兰普提并没能发挥他的足球潜质，职业生涯辗转于埃因霍温、阿斯顿维拉、考文垂和威尼斯等球队，后来甚至效力过甲A山东鲁能。而他的生活也是悲剧不断，他的两个孩子先后去世。\n- 1992年欧洲杯『一意孤行』的贝利又开『新手上路』般的乌鸦嘴，预测南斯拉夫能取得不俗战绩。结果大家也都知道了，南斯拉夫被禁赛。\n- 1994年世界杯贝利乌鸦嘴天下扬名，然而，代价却是哥伦比亚球员被枪杀。该届世界杯，贝利认定哥伦比亚队会一鸣惊人。结果，哥队1胜2负，小组都没冲出去，积分仅为3分。极端的哥伦比亚球迷枪杀了打进乌龙球的后卫埃斯科巴。这次悲剧之后，贝利乌鸦嘴天下闻名，南美媒体首次公开撰文让『贝利闭上他的鸟嘴！』\n- 1996年欧洲杯贝利别出心裁地公开赞美第一次打进欧洲杯决赛圈的土耳其队，并看好意大利夺冠，小组赛后，两个球队无一例外卷铺盖回家了。只是当时人们都惊诧于捷克的表现，贝利的这两次预言并没有得到舆论过多重视。\n- 1998年世界杯贝利认为西班牙小组出线不成问题，结果，西班牙先被尼日利亚戏耍，然后又被巴拉圭逼平，小组都没出线。鉴于尼日利亚的好表现，贝利对其大加赞美，结果2天之后，尼日利亚被丹麦打成筛子，1:4屈辱地打道回府。自觉没有颜面的贝利在接受法国媒体采访时表示，巴西队将战胜法国队夺冠，结果，0:3，堂堂的巴西队就这样毙命。\n- 2002年世界杯小组赛前，吸取教训的贝利改道了，无论媒体怎么引诱，他就是不说巴西队夺冠之类的话语，而是很巧妙地说看好阿根廷和法国队这两个巴西队的仇人。这招果然恶毒，阿根廷、法国这两大热门都在小组赛中折戟沉沙，法国甚至连一个进球都没捞到，而阿根廷令人印象最深的则是巴蒂的眼泪。英格兰3:0战胜丹麦晋级4强，将对阵巴西，贝利一口咬定『英格兰夺冠』，结果可想而知，委屈的英格兰人即便欧文先洞穿巴西大门，随着里瓦、小罗的先后进球，不得不止步决赛的大墙外。最终，巴西夺冠，贝利『赢了』。\n- 2004年欧洲杯贝利在小组赛前看好意大利，托蒂吐向波尔森的口水被电视画面清晰地记录下来，结果停赛三场，意大利深受影响，2平1胜，必须得看别人脸色，结果，即便最后一场2:1战胜保加利亚，但瑞典2:2丹麦，意大利人不得不哭别赛场。接下来，贝利又开始表演，表示看好英格兰，称赞鲁尼前途无限。结果鲁尼在与葡萄牙的比赛里受伤下场，英格兰点球5:6落败。随后，他又看好法国队，预言葡萄牙与荷兰的胜者会夺冠，亚军是捷克……最终结果却是希腊人在雷哈戈尔的率领下，一鸣惊人。\n如今，地球人都晓得贝利乌鸦嘴的厉害了，只要他一开口，天下大惊。\n- 2006年世界杯期间，他也闲不住，『魔嘴』伸向了巴德英意4个球队，随后甚至细化到『巴西夺冠』。贝利不知怀着何种心态，声称『英格兰队没有鲁尼照样是争夺世界杯群雄中最强大的球队』，吓出英格兰球迷一身冷汗。又说『就我个人而言，希望世界杯决赛能够在沙特和巴西之间进行。』结果沙特小组未出线、巴西队败于法国，相继被淘汰；英格兰队同样出局；德国、意大利在4强相遇，又有一个要挂。（最终意大利夺冠，贝利的预测对了四分之一）\n这年亦是国际足联设立最佳新人奖的第一年，贝利认为：『如果阿根廷打入决赛，我认为梅西最有可能获此殊荣。另外C·罗纳尔多也是一个出色的球员。如果英格兰队主帅适当地给沃尔科特一些上场表现的机会，这也许会是一段传奇。我打进自己的首粒世界杯进球时，也只有17岁。』结果阿根廷，英格兰队被淘汰，C·罗纳尔多在对阵荷兰的比赛中又受伤下场。\n- 2008年，当时还效力于AC米兰的罗纳尔多遭遇严重伤病，贝利说外星人玩完了，他即将挂靴。结果：2009年3月罗纳尔多在科林蒂安复出，前14场比赛打进了10球！\n- 2010年南非世界杯，贝利再次做出了预测，称有一支非洲球队将和巴西进行决赛。令人瞠目结舌的是，贝利再次预言『准确』，代表非洲的六支球队仅加纳凭借一粒点球获胜，阿尔及利亚、尼日利亚和喀麦隆全部告负。第一轮小组赛战罢，最大滑铁卢就属非洲球队，6战仅取得1胜2平3负，还不及亚洲球队4战2胜2负。而所谓『巴西队非洲队会师决赛』的愿望，也在巴西队出局后成为了泡影。\n- 『尼基·巴姆比将成为比肩齐达内、罗纳尔多的超级巨星。』结果：巴姆比只是一个普通的球员，只有23次代表英格兰出场，甚至没有在世界杯出现过。09-10赛季效力的赫尔城也在英超惨遭降级。\n- 2014年巴西世界杯，深知自己功力深厚的贝利，没有预测巴西队的前景，甚至拒绝了为32强抽签。不过在巴西高歌猛杀进四强之后，贝利忍不住开口了，看好没有内马尔的巴西也能夺冠。他的『乌鸦嘴』也再度显灵，送给东道主一场1:7的耻辱惨败。\n- 不仅是足球，连排球比赛也能成为贝利的毒奶目标。对于2016年里约奥运会，贝利表示塞尔维亚女排将会夺冠：『这是一只成熟的队伍，拥有两位优秀的攻手，一位经验丰富的二传，一位出色的副攻以及一位老谋深算的教练。相信她们在决赛会给中国队带来足够的麻烦，她们将会3:0横扫中国队拿到金牌。』结果塞尔维亚1:3不敌中国女排。\n- 在贝利和史泰龙以及迈克尔·凯恩等著名影星联袂主演的经典影片《胜利大逃亡》中（1981年上映），上半场贝利被纳粹对手铲伤，他示意自己不能继续比赛了，并被担架抬下场。协约国联队以0比4落后。结果：贝利下半场还是回来了，并攻入一球帮助球队取得胜利。看，即使在电影中，贝利的预测还是错误的。\n- 贝利还曾接受采访说：2012世界末日根本是无稽之谈，我还要看巴西世界杯呢……（幸好这一次，他的预测没有出现问题）\n\n---\n\n参考文章：[贝利乌鸦嘴历史](https://zhidao。baidu。com/question/164350742。html)\n","categories":["幽默"]},{"title":"Python标签云拟合图片","url":"/2018-06/Python标签云拟合图片/","content":"\n![](/images/2018-06/tux_after.png)\n\n借助Python，可以轻松地用标签云拼出一副图片，就像上图这样。让我们一起看看具体的步骤吧。\n\n## 环境\n\n请确保Python3和pip3（即`python3 -m pip`）都可以正常使用。需要使用pip安装的模块有：\n- matplotlib\n- numpy\n- pillow\n- wordcloud\n\n其中wordcloud模块有些特殊，博主尝试执行`pip3 install wordcloud`，结果却遇到了错误信息。如果在你看到这篇文章时，该项目的维护者仍然没有解决该问题，请执行以下安装方式：\n```bash\ngit clone https://github.com/amueller/word_cloud.git\ncd word_cloud\npip3 install -r requirements.txt\npython3 setup.py install\n```\n这样就完成安装了。\n\n<!-- more -->\n## 代码\n\n```python\n#!/usr/bin/env python3\n\nimport numpy as np\nfrom PIL import Image\nfrom wordcloud import WordCloud, ImageColorGenerator\nimport matplotlib.pyplot as plt\n\npic = np.array(Image.open(\"path/to/your/image.png\"))\njsondict = {\n\t\"Unix\": 9,\n\t\"Linus Torvalds\": 8,\n\t\"Richard Stallman\": 8,\n\t\"open source\": 3,\n\t\"Gentoo\": 3,\n\t\"Archlinux\": 3,\n\t\"Void Linux\": 3,\n\t\"Guix\": 3,\n\t\"free software\": 8,\n\t\"RadHat\": 3,\n\t\"php\": 3,\n\t\"SUSE\": 3,\n\t\"Ruby\": 3,\n\t\"Python\": 3,\n\t\"Go\": 3,\n\t\"Mandriva\": 3,\n\t\"root\": 5,\n\t\"android\": 4,\n\t\"Lisp\": 6,\n\t\"C\": 3,\n\t\"Haskell\": 3,\n\t\"XMonad\": 3,\n\t\"javascript\": 6,\n\t\"clojure\": 3,\n\t\"bash\": 3,\n\t\"vim\": 4,\n\t\"emacs\": 4,\n\t\"vis\": 4,\n\t\"ls\": 3,\n\t\"cd\": 3,\n\t\"grep\": 3,\n\t\"sed\": 3,\n\t\"awk\": 3,\n\t\"pascal\": 3,\n\t\"GNU\": 9,\n\t\"irc\": 3,\n\t\"inkscape\": 3,\n\t\"github\": 5,\n\t\"gitlab\": 4,\n\t\"FOSDEM\": 5,\n\t\"GPL\": 4,\n\t\"Free as in Freedom\": 5,\n\t\"FOSS\": 4,\n\t\"Mozilla\": 3,\n\t\"Busybox\": 3,\n\t\"qemu\": 3,\n\t\"gnome\": 3,\n\t\"android\": 3,\n\t\"Fedora\": 3,\n\t\"R\": 3,\n\t\"xelatex\": 3,\n\t\"mupdf\": 3,\n\t\"chromium\": 3,\n\t\"riot\": 3,\n\t\"pidgin\": 3,\n\t\"vlc\": 3,\n\t\"deadbeef\": 3,\n\t\"xarchiver\": 3,\n\t\"calibre\": 3,\n\t\"s6\": 3,\n\t\"json\": 3,\n\t\"chez scheme\": 3,\n\t\"GIMP\": 3,\n\t\"gcc\": 3,\n\t\"debian\": 3,\n\t\"printf(\\\"Linux\\\")\": 3,\n\t\"echo Linux\": 3,\n\t\"(println \\\"Linux\\\")\": 3,\n\t\"console.log \\\"Linux\\\"\": 3,\n\t\"(format t \\\"Linux\\\")\": 3,\n\t\"writeln(\\\"Linux\\\")\": 3,\n\t\"PRINT \\\"Linux\\\"\": 3,\n\t\"(insert \\\"Linux\\\")\": 3,\n\t\"fmt.Println(\\\"Linux\\\")\": 3,\n\t\"main = putStrLn \\\"Linux\\\"\": 3,\n\t\"(display \\\"Linux\\\")\": 3,\n\t\"System.out.println(\\\"Linux\\\");\": 3,\n\t\"document.write(\\\"Linux\\\")\": 3,\n\t\"type [Linux]\": 3,\n\t\"disp('Linux')\": 3,\n\t\"<?php\\necho \\\"Linux\\\"\\n?>\": 3,\n\t\"Ubuntu\": 3\n}\nimage_colors = ImageColorGenerator(pic, [255, 255, 255])\nwc = WordCloud(background_color = \"white\", mask = pic)\nwc.generate_from_frequencies(jsondict)\n\nplt.imshow(wc.recolor(color_func = image_colors), interpolation = \"bilinear\")\nplt.axis(\"off\")\nplt.show()\n```\n将`path/to/your/image.png`换为你要制作的图片，例如下面这张：\n\n![](/images/2018-06/tux.png)\n\n当然也可以替换为自己的图片，支持多种格式，但为了保证效果，非主体部分应填充白色。\njsondict是标签云中文字的内容和权重（大小），自行修改即可。\n保存后使用python3执行以上代码，即可得到拟合出的图片。\n","tags":["Python"],"categories":["程序设计"]},{"title":"Linux下增加、删除Swap文件","url":"/2018-06/Linux下增加、删除Swap文件/","content":"\n在使用VPS时，如果出现内存不够用的情况，可能会产生各种奇怪的问题。这个时候，增加Swap空间，就可以起到救急的作用。下面就来看看具体步骤。\n\n## 创建Swap文件\n\n### 检查Swap空间\n\n先检查一下系统里有没有既存的Swap文件：\n```bash\nswapon -s\n```\n如果返回的信息概要是空的，则表示Swap文件不存在。\n\n### 计算参数\n\n创建Swap文件将用到`dd`命令，我们需要根据需求（即要分配的Swap文件的大小）来计算出参数。一种典型的做法是，每次读写1KiB，重复N次，这样可以兼顾内存消耗和读写次数。因此，如果以MiB为单位计算你要分配的Swap文件的大小，那么读写次数（拷贝的块数）就是将该值乘以1024得到结果。例如，块大小为1KiB时，64MiB的Swap文件拷贝的块数是65536，而1GiB的Swap文件则是1048576。\n\n### 使用`dd`命令来创建Swap\n\n根据前面的计算：\n```bash\ndd if=/dev/zero of=/swapfile bs=1024 count=1048576 #分配1G的Swap空间\n```\n\n参数说明：\n- `if=input file`：输入文件名，缺省为标准输入。即指定源文件。\n- `of=output file`：输出文件名，缺省为标准输出。即指定目的文件。\n- `bs=bytes`：同时设置读入/输出的块大小为bytes个字节，取为1024。\n- `count=blocks`：拷贝的块数，块大小等于bs指定的字节数。将前面算出的数字填入即可。\n\n这里的`if=/dev/zero`意味着向`/swapfile`填满空字符。你也可以尝试将它换成`/dev/random`，或许也可以正常初始化。\n\n<!-- more -->\n## 权限设置\n\n分配空间后，需要赋予Swap文件适当的权限：\n```bash\nchown root:root /swapfile\nchmod 0600 /swapfile\n```\n\n## 启用Swap\n\n创建好Swap文件，还需要格式化后才能使用。\n```bash\n#初始化并激活Swap\nmkswap /swapfile\nswapon /swapfile\n```\n如果要机器重启的时候自动挂载Swap，那么还需要修改`fstab`配置。\n用`vim`打开`/etc/fstab`文件，在其最后添加如下一行：\n```bash\n/swapfile none swap sw 0 0\n```\n当下一次系统启动时，新的Swap文件就打开了。\n添加新的Swap文件并开启后，检查`cat /proc/swaps`或者free命令的输出来查看swap是否已打开。\n\n## 删除Swap分区\n\n最后，是删除Swap分区的方法。\n```bash\nswapoff /swapfile #卸载swap文件\nrm -rf /swapfile #删除文件\n```\n","tags":["Linux"],"categories":["技术"]},{"title":"震惊！黄金卡包竟能出橙","url":"/2018-06/震惊！黄金卡包竟能出橙/","content":"\n![](/images/2018-06/al-akir.png)\n\n> 暴雪或将濒临破产。\n","tags":["炉石传说"],"categories":["电子游戏"]},{"title":"PS制作科幻电路板","url":"/2018-06/PS制作科幻电路板/","content":"\n科幻大片里的电路背景看上去是非常复杂的也是非常炫酷的，不过用滤镜来制作却不是很复杂。先把一些纹理处理成网格效果，然后用查找边缘等滤镜加强网络的边缘线条，后期细化一下线条，调整一下颜色即可。\n\n![](/images/2018-06/circuit.jpg)\n\n<!-- more -->\n## 创建图层\n\n创建大小为1920\\*1200像素的空白背景，分辨率为72dpi。快捷键<kbd>d</kbd>设置前景色与背景色分别为黑色与白色。完成后，再新建一个图层。\n\n![](/images/2018-06/circuit1.png)\n\n## 添加滤镜\n\n现在我们要利用滤镜来完成我们的背景咯，童鞋们按照步骤来，选择：滤镜 → 渲染 → 云彩。\n\n![](/images/2018-06/circuit2.png)\n\n滤镜 → 像素化 → 马赛克，参数就这样。\n\n![](/images/2018-06/circuit3.png)\n\n滤镜 → 模糊 → 径向模糊，参数设置如下。\n\n![](/images/2018-06/circuit4.png)\n![](/images/2018-06/circuit5.png)\n\n滤镜 → 风格化 → 浮雕效果，这样来设置参数。\n\n![](/images/2018-06/circuit6.png)\n![](/images/2018-06/circuit7.png)\n\n滤镜 → 滤镜库 → 画笔描边 → 强化的边缘，参数设置。\n\n![](/images/2018-06/circuit8.png)\n\n滤镜 → 风格化 → 查找边缘。\n\n![](/images/2018-06/circuit9.png)\n\n最后一个滤镜咯，选择：滤镜 → 滤镜库 → 风格化 → 照亮边缘，参数如图。\n\n![](/images/2018-06/circuit10.png)\n\n## 后续处理\n\n图像 → 调整 → 色相/饱和度，参数在这儿。\n\n![](/images/2018-06/circuit11.png)\n\n我们需要把它修改得锐利一点，滤镜 → 模糊 → 表面模糊，参数如下。\n\n![](/images/2018-06/circuit12.png)\n\n## 最终效果\n\n![](/images/2018-06/circuit13.png)\n\n---\n\n本文转载自：[PS十步制作科幻电路板](https://www.yiihuu.com/twjc/29791.html)\n","tags":["Photoshop"],"categories":["技术"]},{"title":"Python开发表情包网站","url":"/2018-06/Python开发表情包网站/","content":"\n『表情包』是一种利用图片来表示感情的方式。在各种社交软件的带动下，『表情包』已经形成了一种流行文化。互联网上，基本人人都会发表情；很多实时通讯软件中，『斗图』成为了一种活跃气氛的常见方式。不知你是否曾有过找不到表情包去应对别人的时候？\n今天博主分享用Python开发个人专属的表情包网站的方法，想用什么表情包搜一下就有了！\n**目标：获取海量表情包，存入数据库，然后搭建简单网站，通过输入关键字获取对应的的表情包。**\n\n---\n\n## 创建数据库\n\n首先，我们要从这个网站爬取表情包：[斗图啦](http://www.doutula.com/photo/list/?page=0)。\n我们先来分析一下这个网页的源代码：\n\n![](/images/2018-06/1.png)\n\n通过源码，我们可以发现需要获取的内容包括每个`<img>`标签的`data-original`和`alt`属性。通过爬虫获取网页，用正则表达式提取内容，然后存入数据库即可。\n这里用到的数据库是MySQL。如果还没有安装的话，不妨参考前面的文章[MySQL 8.0的安装和使用](/2018-03/MySQL%208.0的安装和使用/)。\n\n安装完成后，你可以用root，也可以创建一个新用户，来新建数据库和数据表，用来存放表情包：\n```sql\nCREATE DATABASE images;\n#建立数据库images\nUSE images;\nCREATE TABLE images (\n  id int(10) UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n  name varchar(1000),\n  imageUrl varchar(200)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n#然后在该数据库中新建一个表，并添加相应的name和imageUrl\nQUIT;\n```\n至此数据库方面的工作就完成了。\n\n<!-- more -->\n## 获取海量表情包\n\n创建Python文件，并用Python3执行（记得将密码换成你自己的）：\n```python\n#!/usr/bin/env python3\n\nimport requests\nimport re\nimport pymysql\n# 连接数据库\ndb = pymysql.connect(\n    host = \"127.0.0.1\", # 主机，一般没有服务器就填本机吧\n    port = 3306, # 端口，MySQL数据库的默认端口就是3306\n    db = \"images\", # 数据库名，与之前创建的相同\n    user = \"username\", # 用户名，如果是创建的用户需要在MySQL中授权\n    passwd = \"password\", # 密码，换成你的\n    charset = \"utf8\"\n)\n# 创建cursor\ncursor = db.cursor()\ncursor.execute(\"SET NAMES utf8mb4\")\n\n# 获取图片列表\ndef getImagesList(page):\n    # 获取斗图网源代码\n    html = requests.get(\"http://www.doutula.com/photo/list/?page={}\".format(page), headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0\" }).text\n    # 正则表达式 通配符 .*? 匹配所有 () 分组匹配\n    reg = r'data-original=\"(.*?)\".*?alt=\"(.*?)\"'\n    # 增加匹配效率的 S 多行匹配\n    reg = re.compile(reg, re.S)\n    imagesList = re.findall(reg, html) # 获取name和imageUrl\n    for i in imagesList:\n        image_url = i[0]\n        image_title = i[1]\n        # %s 字符串格式化 防止注入\n        cursor.execute(\"insert into images values(null,%s,%s)\", (image_title, image_url))\n        print(\"正在保存 {}\".format(image_title))\n        db.commit()\n# 截止目前，网站共有1600多页，如果未来有更新，可以手动改下面range的范围\nfor i in range(0, 1650):\n    print(\"第{}页\".format(i))\n    getImagesList(i)\n\ndb.close() # 不要忘记了关闭数据库连接\n```\n## 搭建网站前端\n\n然后就是网站方面了，写一个简单的网站，实现输入关键字得到对应的图片。上代码：\n```python\n#!/usr/bin/env python3\n\nfrom flask import Flask\nfrom flask import render_template\nfrom flask import request\nimport pymysql\n\napp = Flask(__name__)\n# 装饰器\n@app.route(\"/\")  # route 路由\ndef index():\n    # return \"hello world\"\n    return render_template(\"index.html\")\n@app.route(\"/search\")\ndef search():\n    # 接收用户关键字\n    keyword = request.args.get(\"kw\")\n    count = request.args.get(\"count\")\n    cursor.execute(\"select * from images where name like %s\", \"%\" + keyword + \"%\")\n    # 这里是一个模糊匹配，就是匹配和你输入的关键字类似的name，关键字是要用'%{}%'代替，用format传入\n    data = cursor.fetchmany(int(count))\n    # 这里fetchmany就是匹配count条数据库中的数据\n    return render_template(\"index.html\", images = data)\n    # render_template模板能返回一个网页，而网页得存在新创建的templates文件夹里面才可以\n# 程序的入口\nif __name__ == \"__main__\":\n    db = pymysql.connect(\n        host = \"127.0.0.1\",\n        port = 3306,\n        db = \"images\",\n        user = \"username\", # 将用户名换成你的\n        passwd = \"password\", # 将密码换成你的\n        charset = \"utf8\",\n        cursorclass = pymysql.cursors.DictCursor # 这里默认从数据库中查到的数据返回回来是列表形式，这里改为了dict形式\n    )\n    # 创建cursor\n    cursor = db.cursor()\n    # 调试模式\n    # port 端口号 默认5000\n    app.run(debug = True, port = 5000, host = \"0.0.0.0\")\n\n# index.html {{}}是放变量 {%%}是放方法\n```\n这里的`host = \"0.0.0.0\"`意味着程序将监听所有的流量，而不只是本机。\n将这个文件命名为`index.py`。在这个py文件的同一目录下，新建文件夹，命名为`templates`，在该文件夹内创建`index.html`：\n```xml\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>斗图网站</title>\n</head>\n<body>\n<form action=\"/search\">\n    关键字：<input type=\"text\" name=\"kw\"/>\n    <br/>\n    查询的数量：<input type=\"text\" name=\"count\" value=\"100\"/>\n    <br/>\n    <input type=\"submit\" value=\"查询\"/>\n</form>\n\n{% for i in images %}\n<img src=\"{{i.imageUrl}}\" alt=\"{{i.name}}\"/>\n{% endfor %}\n\n</body>\n</html>\n```\n完成后，回到上一目录，在命令行执行`python3 index.py`，然后访问`localhost:5000`即可开始斗图了！\n\n![](/images/2018-06/2.png)\n\n其他设备获取本机IP后，通过5000端口也可以正常浏览。\n\n---\n\n参考文章：\n[关于Python爬虫之获取海量表情包+存入数据库+搭建网站通过关键字查询表情包](https://blog.csdn.net/three_co/article/details/78575634)\n[Python开发个人专属表情包网站，表情在手，天下我有](https://mp.weixin.qq.com/s/dpJOMSdDzkONzV79z7RgYQ)\n","tags":["Python","MySQL"],"categories":["程序设计"]},{"title":"Crontab定时写法整理","url":"/2018-05/Crontab定时写法整理/","content":"\n在前面的文章[NGINX配置SSL](/2018-05/Nginx配置SSL/)中，提到了关于创建Crontab定时任务的内容。事实上，在使用Linux系统时（特别是在服务器上），经常会碰到需要在某个特定时间执行某些任务的情况。博主近期研究了Crontab的机制，并对常见的Crontab用法做了一个总结，收集了一些关于计划任务的实例，现把相关内容分享出来，同时也给自己一个备忘。\n\n## Crontab使用方式\n\n```bash\ncrontab [-u user] file\ncrontab [-u user] [ -e | -l | -r ]\n```\n各参数为：\n- `-u user`：用来设定某个用户的crontab服务。\n- `file`：file是命令文件的名字，表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab将接受从标准输入（如键盘）中键入的命令，并将它们载入crontab任务列表。\n- `-e`：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。\n- `-l`：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前用户的crontab文件内容。\n- `-r`：从`/var/spool/cron`目录中删除某个用户的crontab文件。如果不指定用户，则默认删除当前用户的crontab文件。\n- `-i`：在删除用户的crontab文件时给确认提示。\n\n## Crontab文件格式\n\n用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：\n```txt\nminute hour day month week command\n分　时　日　月　周　命令\n```\n具体来说，每一列的内容分别是：\n- 分钟，可以是从0到59之间的任何整数。\n- 小时，可以是从0到23之间的任何整数（0表示0点）。\n- 日期，可以是从1到31之间的任何整数。\n- 月份，可以是从1到12之间的任何整数。\n- 星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。\n- 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。\n\n![](/images/2018-05/crontab_thumb.png)\n\n在以上各个字段中，还可以使用以下特殊字符：\n- 星号（\\*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。\n- 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如`1,2,5,7,8,9`。\n- 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如`2-6`表示`2,3,4,5,6`。\n- 正斜线（/）：可以用正斜线指定时间的间隔频率，例如`0-23/2`表示每两小时执行一次。\n\n同时正斜线可以和星号一起使用，例如`*/10`，如果用在minute字段，表示每十分钟执行一次。又如，每分钟可以用`*`或者`*/1`表示。\n\n<!-- more -->\n## Crontab文件样例\n\n以重启apache服务器为例：\n```bash\n30 21 * * * /usr/local/etc/rc.d/lighttpd restart\n#每晚的21:30重启apache\n45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart\n#每月1、10、22日的4:45重启apache\n10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart\n#每周六、周日的1:10重启apache\n0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart\n#每天18:00至23:00之间每隔30分钟重启apache\n0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart\n#每星期六的23:00重启apache\n0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart\n#每月的4号与每周一到周三的11点重启apache\n0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart\n#一月一号的4点重启apache\n```\n当然，apache服务器并不总是需要重启。这里还有一些其它的示例：\n```bash\n* * * * * echo \"haha\"\n#每1分钟执行一次 echo \"haha\"\n0 7 * * * /bin/ls\n#每天早上7点执行一次 /bin/ls\n0 6-12/3 * 12 * /usr/bin/backup\n#在12月内，每天的早上6点到12点，每隔3个小时执行一次 /usr/bin/backup\n0 17 * * 1-5 mail -s \"hi\" alex@domain.name < /tmp/maildata\n#周一到周五每天下午5:00寄一封信给 alex@domain.name\n0 */1 * * * root run-parts /etc/cron.hourly\n#每小时执行/etc/cron.hourly目录内的脚本\n0 */3 * * * command\n#每三个小时执行command\n0 23-7/1 * * * command\n#晚上11点到早上7点之间，每隔一小时执行command\n0 23-7/2,8 * * * command\n#晚上11点到早上7点之间每两个小时，以及早上8点执行command\n20 0-23/2 * * * command\n#每天的0:20，2:20，4:20等执行command\n3,15 * * * * command\n#每小时的第3和第15分钟执行\n3,15 8-11 * * * command\n#在上午8点到11点的第3和第15分钟执行\n3,15 8-11 */2 * * command\n#每隔两天的上午8点到11点的第3和第15分钟执行\n3,15 8-11 * * 1 command\n#每个星期一的上午8点到11点的第3和第15分钟执行\n```\n**注意：当程序在你所指定的时间执行后，系统会寄一封邮件给你，显示该程序执行的内容，若你不希望收到这样的信，请在每一行空一格之后加上`> /dev/null 2>&1`，否则会产生不必要的浪费。**\n\n---\n\n参考文章：\n[crontab 定时写法整理](https://blog.csdn.net/bsf5521/article/details/76522222)\n[crontab命令](https://www.cnblogs.com/xingzc/p/5969777.html)\n[Linux系统的计划任务Crontab及实例](http://www.opsers.org/base/crontab-linux-system-tasks-and-examples-of-projects.html)\n","tags":["Mac","Linux"],"categories":["技术"]},{"title":"博客迁移至Hexo","url":"/2018-05/博客迁移至Hexo/","content":"\n由于之前使用的WordPress博客在更新后出现未知错误（最后证实是主机商的问题），同时考虑到WordPress存在的一些弊端，例如：\n- 较为臃肿的PHP后端\n- 除了官方主题外，难以找到适合博客写作的主题，大多只适合做展示站\n- 在不安装插件的情况下，只能用自带的编辑器手写HTML，而无法使用Markdown来编辑文章\n- 静态文件的管理也让人头痛，『媒体库』的设计初衷很好，但实际上严重影响效率\n\n可见，用WordPress写文章，特别是长文，是一件非常麻烦的事情——你很难专注于写作。虽然它也有不少优点：\n- 丰富的插件库，可以拓展大量的功能\n- 完善的评论系统，无需依赖第三方服务\n- 更新非常方便\n\n这些特点是静态博客所不具有的，但最终喜欢折腾的博主还是决定将所有内容导出，转而使用Hexo进行渲染，并部署到GitHub Pages上。借助于`hexo-migrator-wordpress`，这一工作进行的非常顺利。当然，除了Hexo，也有很多其他的解决方案可以考虑，常见的包括Typecho或Hugo等。\n迁移后的新站点使用了zhangshuqiao.org的域名，目前已可以通过https正常访问。旧的WordPress博客仍会保留，但不再更新，未来可能更多的用于进行插件的测试。\nZSQ.IM站点近期也实装了全新LOGO（使用Monodraw制作）：\n```txt\n      ___           ___           ___       ___           ___           ___      \n     /\\  \\         /\\  \\         /\\__\\     /\\  \\         |\\__\\         |\\__\\     \n    /::\\  \\       /::\\  \\       /:/  /    /::\\  \\        |:|  |        |:|  |    \n   /:/\\:\\  \\     /:/\\:\\  \\     /:/  /    /:/\\:\\  \\       |:|  |        |:|  |    \n  /:/  \\:\\  \\   /::\\~\\:\\  \\   /:/  /    /::\\~\\:\\  \\      |:|__|__      |:|__|__  \n /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/__/    /:/\\:\\ \\:\\__\\ ____/::::\\__\\     /::::\\__\\ \n \\:\\  /\\ \\/__/ \\/__\\:\\/:/  / \\:\\  \\    \\/__\\:\\/:/  / \\::::/~~/~       /:/~~/~    \n  \\:\\ \\:\\__\\        \\::/  /   \\:\\  \\        \\::/  /   ~~|:|~~|       /:/  /      \n   \\:\\/:/  /        /:/  /     \\:\\  \\       /:/  /      |:|  |       \\/__/       \n    \\::/  /        /:/  /       \\:\\__\\     /:/  /       |:|  |                   \n     \\/__/         \\/__/         \\/__/     \\/__/         \\|__|                   \n                    ___                       ___                                \n                   /\\__\\          ___        /\\__\\          ___                  \n                  /::|  |        /\\  \\      /::|  |        /\\  \\                 \n                 /:|:|  |        \\:\\  \\    /:|:|  |        \\:\\  \\                \n                /:/|:|__|__      /::\\__\\  /:/|:|__|__      /::\\__\\               \n               /:/ |::::\\__\\  __/:/\\/__/ /:/ |::::\\__\\  __/:/\\/__/               \n               \\/__/~~/:/  / /\\/:/  /    \\/__/~~/:/  / /\\/:/  /                  \n                     /:/  /  \\::/__/           /:/  /  \\::/__/                   \n                    /:/  /    \\:\\__\\          /:/  /    \\:\\__\\                   \n                   /:/  /      \\/__/         /:/  /      \\/__/                   \n                   \\/__/                     \\/__/                               \n```\n同时博主计划于下半年将原来ZSQ.IM站点的所有静态页面进行一次大型的改进，敬请期待。\n\n---\n\n本文更新于2018年7月8日：\n由于在国内GitHub Pages加载速度不稳定，且由于GitHub政策不利于SEO，博主已将所有托管在GitHub Pages上的页面迁移至另一台独立服务器。\n目前全站已支持HTTPS访问，并启用了HSTS，未来时机成熟时将开启HTTP/2访问。\n","tags":["系统日志"],"categories":["其他"]},{"title":"Nginx配置SSL","url":"/2018-05/Nginx配置SSL/","content":"\n## 安装CertBot\n\n首先，克隆Certbot在GitHub上的仓库到本地：\n```bash\ngit clone https://github.com/certbot/certbot.git\n```\n在certbot文件夹下，有一个shell脚本，名为certbot-auto。你可以将其软链接为certbot，方便进行接下来的步骤。具体操作是，在你的家目录`~`下的`.bashrc`或`.bash_profile`文件中追加以下内容：\n```bash\nalias certbot=/path/to/your/certbot/certbot-auto\n```\n然后执行`source ~/.bashrc`或`source ~/.bash_profile`，这样就可以直接使用certbot命令进行接下来的操作了。\n当然，你也可以使用包管理工具安装certbot。以yum为例：\n```bash\nyum -y install yum-utils\nyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\nyum install certbot\n```\n其它系统的安装方式可以在[Certbot官网](https://certbot.eff.org)上查询。\n不过经博主测试，这种安装方式可能会产生错误，因此不建议使用。\n安装完成后，可以使用\n```bash\nsudo certbot -h\n```\n查看安装是否成功。如果报错，也可以尝试使用`pip install certbot`。\n如果你使用了nginx服务器，还可以执行\n```bash\nyum install certbot-nginx\n```\n安装Certbot的Nginx拓展。\n\n## 配置CertBot\n\n执行\n```bash\nsudo certbot --nginx\n```\n即可自动完成配置。不过由于涉及到修改nginx.conf，建议手动进行配置：\n```bash\nsudo certbot certonly --webroot -w /path/to/your/webroot -d yourdomain.com,www.yourdomain.com\n```\n将`/path/to/your/webroot`替换为nginx的根目录，`yourdomain.com`替换为你的域名，多个域名用逗号隔开。\n如果要申请泛域名证书，将上面的命令改为：\n```bash\nsudo certbot certonly --server https://acme-v02.api.letsencrypt.org/directory --manual --preferred-challenges dns -d yourdomain.com,*.yourdomain.com\n```\n泛域名证书还需要验证TXT记录，比较麻烦。可以参考这篇文章：[Let's Encrypt现已正式支持泛域名证书](https://imjad.cn/archives/lab/letsencrypt-wildcard-certificate-support-is-live)。\n如果一切顺利，会输出以下内容：\n```bash\nIMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at\n   /etc/letsencrypt/live/yourdomain.com/fullchain.pem. Your cert\n   will expire on 20XX-XX-XX. To obtain a new or tweaked version of\n   this certificate in the future, simply run certbot again. To\n   non-interactively renew *all* of your certificates, run \"certbot\n   renew\"\n - If you like Certbot, please consider supporting our work by: \n   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le\n```\n\n生成的证书将会存放在`/etc/letsencrypt/live/`目录下。\n\n<!-- more -->  \n## 配置Nginx\n\n接下来配置nginx.conf：\n```bash\nserver {\n    listen 80;\n    listen [::]:80; #监听ipv6，如果没有必要可以删去\n    #如果硬性要求全部走https协议，注释上两行\n    listen 443 ssl;\n    listen [::]:443 ssl; #监听ipv6，如果没有必要可以删去\n    server_name yourdomain.com;\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n    ssl_trusted_certificate /etc/letsencrypt/live/yourdomain.com/chain.pem;\n    #其余内容省略，无需更改\n```\n\n同理，将`yourdomain.com`替换为你的域名。如果还要支持HTTP/2，请确保编译Nginx时设置了参数`--with-http_v2_module`，然后在这个配置文件中，将`listen 443 ssl;`改为`listen 443 ssl http2;`，ipv6同理。\n更改完成后，执行`nginx -s reload`重新加载配置，这时就可以使用https访问了。\n\n## 更新证书\n\n先在命令行模拟证书更新：\n```bash\nsudo certbot renew --dry-run\n```\n模拟更新成功的效果如下：\n```bash\n-------------------------------------------------------------------------------\nProcessing /etc/letsencrypt/renewal/yourdomain.com.conf\n-------------------------------------------------------------------------------\n** DRY RUN: simulating 'certbot renew' close to cert expiry\n**          (The test certificates below have not been saved.)\n\nCongratulations, all renewals succeeded. The following certs have been renewed:\n  /etc/letsencrypt/live/yourdomain.com/fullchain.pem (success)\n** DRY RUN: simulating 'certbot renew' close to cert expiry\n**          (The test certificates above have not been saved.)\n```\n如果模拟成功，就可以使用\n```bash\nsudo certbot renew >> /var/log/le-renew.log\n```\n手动进行更新（注：证书只有在有效期小于一个月的时候才会更新，否则CertBot会提示无需更新）。\n当然，你也可以通过Crontab来启用定时任务，自动更新证书。在命令行执行：\n```bash\nsudo crontab -e\n```\n在打开的文件中添加配置：\n```bash\n30 2 * * 1 /path/to/your/certbot renew >> /var/log/le-renew.log\n```\n这里建议使用certbot或certbot-auto的绝对地址，避免出现问题。这样，在每周一半夜2点30分就会执行renew任务，自动更新证书。\n如果一切OK，那么我们的配置到此结束！\n\n## 关于HSTS\n\n如果你能够确保在未来足够长的时间内保持证书的有效性，则可以配置HSTS。HSTS是HTTP Strict Transport Security的缩写，它可以阻止基于SSLStrip的中间人攻击，这将增加访问的安全性。在http头中做出如下设置即可开启HSTS：\n```txt\nStrict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]\n```\n其中`expireTime`是过期时间，一旦用户通过https访问你开启了HSTS的站点，那么在`expireTime`之内再次访问，浏览器将强制启用https——这样可以防止发送不安全的流量。但是，如果你的证书此时过期了，那么用户将无法访问你的网站，因为http访问会被浏览器禁止。\n更进一步，你可以把自己的网站提交到HSTS preload list中。这是Chrome浏览器中的HSTS预载入列表，在该列表中的网站，使用Chrome浏览器访问时，会自动转换成HTTPS。Firefox、Safari、Edge浏览器也在采用这个列表。\n加入HSTS preload list的条件为：\n- 有效的证书（如果使用SHA-1证书，必须是2016年前就会过期的）\n- 将所有HTTP流量重定向到HTTPS\n- 确保所有子域名启用HTTPS，特别是www子域名\n\n同时输出的HSTS响应头部需要满足以下条件：\n- max-age至少为一年，31536000秒\n- 必须指定includeSubdomains参数\n- 必须支持preload参数\n\n所以，一个典型满足HSTS preload list的响应头部为：\n```txt\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload;\n```\n通过配置Nginx，利用`add_header`加上这个响应头，然后就可以在HSTS preload list的[官方网站](https://hstspreload.org)上进行申请了。从申请到审核通过，时间在几天到几周不等。申请后，你可以随时查询最新的状态，也可以在Chrome浏览器的地址框中输入`chrome://net-internals/#hsts`查看。从审核通过到正式加入到Chrome的stable release版本中还需要一段时间，因为还要经过canary、dev、beta以及stable progression等步骤。\n\n---\n\n参考文章：\n[nginx+ssl配置http和https共存](https://blog.csdn.net/p793049488/article/details/53483381)\n[手把手教你在Nginx上使用CertBot](https://segmentfault.com/a/1190000005797776)\n\n本文更新于2018年7月28日：\n在较新版本中，`ssl on`不再被使用，否则会报错：[warn] the \"ssl\" directive is deprecated, use the \"listen ... ssl\" directive instead；将推荐的CertBot安装方式由包管理工具改为Git项目。\n","tags":["Nginx"],"categories":["Web开发"]},{"title":"有趣的Linux命令行工具","url":"/2018-05/有趣的Linux命令行工具/","content":"\nLinux is fun! Huhhh. OK so you don't believe me. Mind me at the end of this article you will have to believe that Linux is actually a fun box.\nLinux是非常有趣的，别不相信——看完这篇文章，你一定会发现Linux系统神奇的用法。\n请注意，下面部分命令给出了两种包管理软件的安装方式，如果是Debian系的系统，请使用`apt`，如果是Red Hat系的系统，请使用`yum`。如果你使用了其他Linux发行版，或使用了其他包管理工具（例如macOS上的brew），可能无法找到所有这些命令。\n**注：为了在代码块中区别输入输出，以`$`开头的行代表输入，其它行代表输出。**\n\n## curl\n\n命令：curl\ncurl用于互联网传输数据，支持多种协议。通过以下命令可以查看天气：\n```bash\n$ curl -4 http://wttr.in\n```\n\n## sl (Steam Locomotive)\n\n命令：sl（蒸汽机车的缩写）\nYou might be aware of command 'ls' the list command and use it frequently to view the contents of a folder but because of miss-typing sometimes you would result in 'sl', how about getting a little fun in terminal and not `command not found`.\n你一定知道ls是用来显示文件夹内容的常见命令，但如果不小心打成sl呢？通过包管理工具安装它，你就能看见一辆跑过屏幕的火车，而不是『找不到命令』：\n```bash\n$ apt install sl #In Debian like OS, or aptitude based system\n$ yum install sl #In Red Hat like OS, or yum based system\n$ sl\n```\nThis command works even when you type 'LS' and not 'ls'.\n\n{% video /files/ezgif-4-7bb965bfb6.mp4 %}\n\n## telnet\n\n命令：telnet\nNo! No!! it is not as much complex as it seems. You would be familiar with telnet. Telnet is a text-oriented bidirectional network protocol over network. Here is nothing to be installed. What you should have is a Linux box and a working Internet.\n不！它并不像看上去那样复杂。你会熟悉它的。Telnet是一个基于文本的双向网络协议。你无需安装它，只需要一台能够联网的linux机器就行。\n输入以下命令即可观看ASCII版星球大战：\n```bash\n$ telnet towel.blinkenlights.nl\n```\n而以下命令将会在你的命令行中生成一个ASCII世界地图：\n```bash\n$ telnet mapscii.me\n```\n是不是很有趣？\n\n## fortune\n\n命令：fortune What about getting your random fortune, sometimes funny in\nterminal.\n在终端获取随机的人生经验，听上去不错吧？\n```bash\n$ apt install fortune\n$ yum install fortune\n$ fortune\n\nYou're not my type.  For that matter, you're not even my species!!!\nFuture looks spotty.  You will spill soup in late evening.\nYou worry too much about your job.  Stop it.  You are not paid enough to worry.\nYour love life will be... interesting.\n```\n\n<!-- more -->\n## rev (Reverse)\n\n命令：rev（反转的缩写）\nIt reverse every string given to it, is not it funny.\n它会反转任何输入的字符串，然后输出。\n```bash\n$ rev\n\n123abc\ncba321\nxuniL eb ot nrob\nborn to be Linux\n```\n\n## factor\n\n命令：factor Time for some Mathematics, this command output all the possible factors of a given number.\n数学时间到：这个命令会输出一个数字的所有质因数。\n```bash\n$ factor 5\n\n5\n5: 5\n12\n12: 2 2 3\n1001\n1001: 7 11 13\n5442134\n5442134: 2 2721067\n```\n\n## script\n\nshell脚本\nOK fine this is not a command and a script but it is nice.\n它会输出乘法口诀表。\n```bash\n$ for i in {1..9}; do for j in $(seq 1 $i); do echo -ne $i*$j=$((i*j))\\\\t;done; echo;done\n\n1*1=1\n2*1=2   2*2=4\n3*1=3   3*2=6   3*3=9\n4*1=4   4*2=8   4*3=12  4*4=16\n5*1=5   5*2=10  5*3=15  5*4=20  5*5=25\n6*1=6   6*2=12  6*3=18  6*4=24  6*5=30  6*6=36\n7*1=7   7*2=14  7*3=21  7*4=28  7*5=35  7*6=42  7*7=49\n8*1=8   8*2=16  8*3=24  8*4=32  8*5=40  8*6=48  8*7=56  8*8=64\n9*1=9   9*2=18  9*3=27  9*4=36  9*5=45  9*6=54  9*7=63  9*8=72  9*9=81\n```\n\n## cowsay\n\n命令：cowsay\nAn ASCII cow in terminal that will say what ever you want.\n一个终端里由ASCII码组成的牛，你想让它说什么，它就会说什么。\n```bash\n$ apt install cowsay\n$ yum install cowsay\n$ cowsay I Love *nix\n\n _____________\n< I Love *nix >\n -------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\nHow about pipelineing 'fortune command', described above with cowsay?\n通过管道指令将fortune命令的输出作为cowsay的输入：\n```bash\n$ fortune | cowsay\n\n_________________________________________\n/ Q: How many Oregonians does it take to  \\\n| screw in a light bulb? A: Three. One to |\n| screw in the light bulb and two to fend |\n| off all those                           |\n|                                         |\n| Californians trying to share the        |\n\\ experience.                             /\n-----------------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\nNote: '\\|' is called pipeline instruction and it is used where the output of one command needs to be the input of another command. In the above example the output of 'fortune' command acts as an input of 'cowsay' command. This pipeline instruction is frequently used in scripting and programming.\n注意：'\\|'被称为管道指令，用于将一个命令的输出作为另一个命令的输入。在上面的例子中，fortune命令的输出作为cowsay命令的输入。管道指令经常用于脚本和编程。\nxcowsay is a graphical program which response similar to cowsay but in a graphical manner, hence it is X of cowsay.\nxcowsay是一个图形程序，其效果类似于cowsay，但是是以图形方式显示说话的牛。\n```bash\n$ apt install xcowsay\n$ xcowsay I Love nix\n```\ncowthink is another command, just run `cowthink Linux is sooo funny` and see the difference in output of cowsay and cowthink. cowthink是另一个命令，你可以执行`cowthink Linux is sooo funny`看看它和cowthink的输出差异。\n```bash\n$ apt install cowthink\n$ brew install cowthink\n$ cowthink ....Linux is sooo funny\n\n _________________________\n( ....Linux is sooo funny )\n -------------------------\n        o   ^__^\n         o  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n```\n注：你可以查看以上命令的帮助菜单，可以把牛换成其他会说话的动物。\n\n## yes\n\n命令：yes\nIt is funny but useful as well, specially in scripts and for System Administrators where an automated predefined response can be passed to terminal or generated.\n它很有趣，也很实用。使用yes，终端将会不断输出你所输入的字符串。\n```bash\n$ yes I Love Linux\n\nI Love Linux\nI Love Linux\nI Love Linux\nI Love Linux\nI Love Linux\nI Love Linux\n```\nNote: (Till you interrupt i.e <kbd>Ctrl</kbd>+<kbd>C</kbd>).\n直到你使用<kbd>Ctrl</kbd>+<kbd>C</kbd>结束它，否则会一直输出。\n\n## toilet\n\n命令：toilet\nWhat? Are u kidding, huhh no! Definitely not, but for sure this command name itself is too funny, and I don't know from where this command gets it's name.\n什么？你在开玩笑吗，不！绝对不是，但肯定这个命令名称本身太有趣了，我不知道这个命令从哪里得到它的名字。\n```bash\n$ apt install toilet\n$ brew install toilet\n$ toilet mimi\n\n          \"             \"\n mmmmm  mmm    mmmmm  mmm\n # # #    #    # # #    #\n # # #    #    # # #    #\n # # #  mm#mm  # # #  mm#mm\n```\nIt even offers some kind of color and fonts style.\n它甚至提供了颜色和字体样式。\n```bash\n$ toilet -f mono12 -F metal mimi.com\n```\nNote: Figlet is another command that more or less provide such kind of effect in terminal.\n注意：Figlet是另一个或多或少在终端提供这种效果的命令。\n\n## cmatrix\n\n命令：cmatrix\nYou might have seen Hollywood movie 'matrix' and would be fascinated with power, Neo was provided with, to see anything and everything in matrix or you might think of an animation that looks alike Hacker's desktop.\n你可能已经看过好莱坞电影《黑客帝国》，并且会被Neo获取的力量所吸引——在矩阵中看到一切；或许你也会想到一个看起来和Hacker的桌面一样的动画。\n```bash\n$ apt install cmatrix\n$ brew install cmatrix\n$ cmatrix\n```\nyum上似乎找不到，可以使用[源码](https://github.com/abishekvashok/cmatrix)编译安装。\n\n![](/images/2018-05/cmatrix.png)\n\n## oneko\n\n命令：oneko\nOK so you believe that mouse pointer of Linux is the same silly black/white pointer where no animation lies then I fear you could be wrong. `oneko` is a package that will attach a \"Jerry\" with you mouse pointer and moves along with you pointer.\n如果你觉得Linux的鼠标就是一个愚蠢的黑色/白色指针，而没有动画，我担心你可能是错的。使用`oneko`命令，就可以创造一只与你的鼠标指针玩耍的猫。\n```bash\n$ apt install oneko\n$ yum install oneko\n$ oneko\n```\nNote: Once you close the terminal from which oneko was run, jerry will disappear, nor will start at start-up. You can add the application to start up and continue enjoying.\n注意：一旦你关闭了运行oneko的终端，小猫就会消失。你可以把它添加到开机启动中，继续享受撸猫的乐趣。\n\n## while\n\n命令：while\nThe below `while` command is a script which provides you with colored date and file till you interrupt (<kbd>Ctrl</kbd>+<kbd>C</kbd>). Just copy and paste the below code in terminal.\n下面的`while`命令是一个脚本，它会为你提供彩色日期和文件，直到你用<kbd>Ctrl</kbd>+<kbd>C</kbd>中断。只需在终端中复制并粘贴以下代码即可。\n```bash\n$ while true; do echo \"$(date '+%D %T' | toilet -f term -F border --gay)\"; sleep 1; done\n```\nNote: The above script when modified with following command, will gives similar output but with a little difference, check it in your terminal.\n注意：上面的脚本在使用以下命令修改后，会给出类似的输出，但有一点区别，请在终端中检查它。\n```bash\n$ while true; do clear; echo \"$(date '+%D %T' | toilet -f term -F border --gay)\"; sleep 1; done\n```\n\n## espeak\n\n命令：espeak\nJust Turn the Knob of your multimedia speaker to full before pasting this command in your terminal and let us know how you felt listening the god's voice.\n在将此命令粘贴到终端之前，请将你的音箱音量开到最大，让我们知道你是如何聆听上帝的声音的。\n```bash\n$ apt install espeak\n$ yum install espeak\n$ espeak \"This is a very good website dedicated to Foss Community\"\n```\n\n## aafire\n\n命令：aafire\nHow about fire in your terminal. Just type `aafire` in the terminal, without quotes and see the magic. Press any key to interrupt the program.\n在你的终端放火，听上去如何？只需在终端输入`aafire`，就可以看到神奇的现象。按任意键中断程序。\n```bash\n$ apt install libaa-bin\n$ aafire\n```\n\n## bb\n\n命令：bb\nFirst install `apt insatll bb` and then, type `bb` in terminal and see what happens.\n首先用`apt`安装`bb`命令，然后在终端输入`bb`，看看会发生什么。\n```bash\n$ apt install bb\n$ bb\n```\n**注：需要图形界面。**\n\n## url\n\n命令：url\nWon't it be an awesome feeling for you if you can update you twitter status from command line in front of your friend and they seems impressed. OK just replace username, password and your status message with your's username, password and \"your status message\".\n如果你可以在你的朋友面前通过命令行更新你的Twitter状态，这绝对是超棒的感觉——而且他们也会印象深刻。好的，只需把下面的YourUsername，YourPassword和Your status message替换为你自己的用户名，密码和状态信息即可。\n```bash\n$ url -u YourUsername:YourPassword -d status=\"Your status message\" http://twitter.com/statuses/update.xml\n```\n\n## ASCIIquarium\n\n命令：ASCIIquarium\nHow it will be to get an aquarium in terminal.\n怎样才能在终端获得一个水族馆？\n```bash\n$ apt install libcurses-perl\n$ cd /tmp\n$ wget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gz\n$ tar -zxvf Term-Animation-2.4.tar.gz\n$ cd Term-Animation-2.4\n$ perl Makefile.PL && make && make test\n$ make install\n```\nNow Download and Install ASCIIquarium.\n现在下载并安装ASCIIquarium。\n```bash\n$ cd /tmp\n$ wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gz\n$ tar -zxvf asciiquarium.tar.gz\n$ cd asciiquarium_1.1\n$ cp asciiquarium /usr/local/bin\n$ chmod 0755 /usr/local/bin/asciiquarium\n```\nAnd finally run `asciiquarium` or `/usr/local/bin/asciiquarium` in terminal without quotes and be a part of magic that will be taking place in front of your eyes.\n最后在终端中运行asciiquarium，水族馆便展现在你面前。\n```bash\n$ asciiquarium\n```\n\n![](/images/2018-05/asciiquarium.png)\n\n## Fork Bomb\n\nFork炸弹\nThis is a very nasty piece of code. Run this at your own risk. This actually is a fork bomb which exponentially multiplies itself till all the system resource is utilized and the system hangs. (To check the power of above code you should try it once, but all at your own risk, close and save all other programs and file before running fork bomb).\n这是一段非常讨厌的代码。运行这个需要自担风险。这实际上是一个Fork炸弹，它以指数方式自我增殖，直到所有系统资源被利用并且系统挂起。（要体会上述代码的威力，你可以尝试一次，但所有风险自负：谨记，在运行Fork炸弹之前关闭并保存所有其他程序和文件）。\n```bash\n$ :(){ :|:& }:\n```\n\n## 更多\n\nHave fun, you can say me thanks later :) yup your comment is highly appreciated which encourages us write more. Tell us which command you liked the most. Stay tuned i will be back soon with another article worth reading.\n\n![](/images/2018-05/depressed-developer-51.png)\n\n---\n\n图片来源：[The Depressed Developer 51](http://turnoff.us/geek/the-depressed-developer-51/)\n\n本文翻译自：[20 Funny Commands of Linux or Linux is Fun in Terminal](https://www.tecmint.com/20-funny-commands-of-linux-or-linux-is-fun-in-terminal)\n\n拓展阅读：\n[计算机领域有哪些经典的典故或笑话？](https://www.zhihu.com/question/20034686/answer/52858899)\n[一行代码可以做什么？](https://www.zhihu.com/question/285586045/answer/475593167)\n[the-art-of-command-line](https://github.com/jlevy/the-art-of-command-line)\n","tags":["Linux"],"categories":["技术"]},{"title":"在GitHub热点图上绘画","url":"/2018-05/在GitHub热点图上绘画/","content":"\n借助这个项目，你可以在GitHub热点图（动态图）上绘制图案，并由此生成Shell脚本；在空项目中执行该脚本，便能创造过去的commit记录；而将该项目push到GitHub上，你的热点图就变得和绘制的图案完全相同。\n\n![](/images/2018-05/gitdraw.png)\n\n项目地址：[git-draw](https://github.com/stevenjoezhang/git-draw)\n原项目是一个Chrome插件，由于长期没有维护，且GitHub改变了页面结构，导致插件不可用。新项目重写了部分JavaScript代码，使得其能够正常运行。快来试试吧！\n","tags":["GitHub"],"categories":["程序设计"]},{"title":"CUPT地震仪的实现","url":"/2018-05/CUPT地震仪的实现/","content":"\n2018年CUPT的第一题：\n\n> **Invent Yourself**\n> Construct a simple seismograph that amplifies a local disturbance by mechanical, optical or electrical methods. Determine the typical response curve of your device and investigate the parameters of the damping constant. What is the maximum amplification that you can achieve?\n> **自主发明**\n> 建造一个可以通过力学、光学或电学方法放大局部扰动的简单地震仪。确定你装置的标准响应曲线并且研究阻尼常数的参量。你能达到的最大放大率是多少？\n\n此题的关键便是将地震仪的反应谱通过可观测量进行表示。实现的思路有很多，力学、光学或电学方法都是可行的。综合考虑了实现难度和测量精度后，决定采用以下方案：通过力学方法放大震动，然后利用霍尔片和磁铁将力学量转换为电学量，借助Arduino单片机的模数转换，通过串口将信号输入到电脑，电脑用Python监听串口，将获得的数据保存并实时分析、绘图。\n\n仪器的整体构造如图：\n\n![](/images/2018-05/1.jpg)\n\n<!-- more -->\n磁铁与霍尔片的细节：\n\n![](/images/2018-05/2.png)\n\nArduino的连接：\n\n![](/images/2018-05/3.png)\n\n仪器的工作状态：\n\n![](/images/2018-05/4.png)\n![](/images/2018-05/5.jpg)\n\n测得的『地震』波（由敲击桌子和将小物件扔到桌子上产生）：\n\n![](/images/2018-05/6.jpg)\n\n具体的代码包括Arduino读取模拟信号和串口输出部分（需要使用Arduino IDE编译上传至设备），以及Python监听串口、保存数据、绘图部分。\n所有代码已开源：[CUPT-Seismograph](https://github.com/stevenjoezhang/CUPT-Seismograph)\n\n---\n\n本文更新于2018年10月31日：\n其实电脑上还有一个更好的采样方式——声卡。通过Python直接读取声卡的模拟输入，也可以达到效果，并且采样率和精度可以做得更高。`pyaudio`库可以提供相关功能，有兴趣的话可以按这个思路实现。\n","tags":["Python","Arduino"],"categories":["物理"]},{"title":"文艺的代码","url":"/2018-04/文艺的代码/","content":"\n```c\ndouble world;\nunsigned letter;\nshort stay;\nlong memories;\nlong long ago;\nfloat cloud;\nprintf(\"I miss you.\\n\");\n```\n```javascript\nfor (everynight in mydreams) {\n    i.see(you);\n    i.feel(you);\n}\n```\n```sql\nselect * from world where someone like '%you%';\n```\nNothing is absolute.\n```xml\n<style>\n* { position: relative; }\n</style>\n```\n物是人非事事休，欲语泪先流。\n```java\n(item && !people) everything = false;\nif (tears.setFlowing()) try {\n    Speaker skr = new Speaker();\n}\ncatch {\n    IOException e;\n} ()\n```\n先天下之忧而忧，后天下之乐而乐。\n```javascript\nif (others.rejoice() == true) {\n    self.rejoice();\n}\nelse {\n    self.worry();\n}\n```\n\n<!-- more -->\n寻寻觅觅，冷冷清清，凄凄惨惨戚戚。\n```cpp\nSeeking++;\nLoneliness++;\n(Misery++) + (Sadness++);\n```\n野火烧不尽，春风吹又生。\n```cpp\nwhile(true) {\n    Grass *gr;\n    if (springBreeze.isComing()) {\n        gr = new Grass;\n    }\n    if (wildFire.isComing()) {\n        delete gr;\n    }\n}\n```\n假作真时真亦假，无为有处有还无。\n```cpp\nif (FALSE == true) TRUE = false;\nif (NULL == exist) exist = NULL;\n```\n欲穷千里目，更上一层楼。\n```javascript\nif (sight.getRange() <= 1000) building.level++;\n```\n明日复明日，明日何其多。我生待明日，万事成蹉跎。\n```javascript\nwhile (tomorrow.hasNext()) {\n    howMany(tomorrow);\n    tomorrow.next();\n}\nthis.wait(WHOLE_LIFE);\nreturn (null == everything) ? null : null;\n```\n路漫漫兮修远兮，吾将上下而求索。\n```cpp\nroadAheadEnding.isVisual = false;\nif (!spareEffort()) {\n    i.searchWith(willUnbending);\n}\n```\n但愿人长久，千里共婵娟。\n```objective-c\n- (BOOL)wish: (People *) longNine {\n    BOOL km = YES;\n    BOOL moon = YES;\n    return km && moon;\n}\n```\n东风不与周郎便，铜雀春深锁二乔。\n```cpp\nif (!eastWind.help(zhouyu)) {\n    season = spring;\n    bronzeBird.lock(bigQiao);\n    bronzeBird.lock(smallQiao);\n}\n```\n两岸猿声啼不住，轻舟已过万重山。\n```cpp\nwhile (true) {\n    listen(Ape1Cry && Ape2Cry);\n    Boat.pass(Mountain);\n    if (Mountain > 10000) break;\n}\n```\n桃花潭水深千尺，不及汪伦送我情。\n```cpp\npeachFlowerLake.deep = 1000;\nif (peachFlowerLake.deep < wl.friendship) return true;\n//运算结果：true\n```\n黑夜给了我黑色的眼睛，我却用它来寻找光明。\n```javascript\neye = dark.poll();\nif (eye.color == black) {\n    eye.seek_for(bright);\n}\n```\n鱼和熊掌不可兼得。\n```c\nhold ? fish : palm;\n```\n笑渐不闻声渐悄，多情却被无情恼。\n```javascript\nlaugh--;\nsound--;\nperson(feeling > 999).bothered_by(person(feeling == 0));\n```\n举头望明月，低头思故乡。\n```javascript\nif (this.Head.SetDirection(TheMoon.GetInstance().Position)) {\n    this.Head.SetDirection(GROUND_DIRECTION);\n    this.ThinkAbout(this.OriginalPlace);\n}\n```\n一直在做程序员，直到膝盖中了一箭。\n```csharp\nwhile (true) {\n    try {\n        ActAs(Programmer);\n    }\n    catch (KneeTilledException e) {\n        if (e.Weapon is Arror) break;\n    }\n}\n```\n抽刀断水水更流，举杯消愁愁更愁。\n```javascript\ncutWater(getKnife()) {\n    water++;\n}\nreduceWorry(toast) {\n    worry++;\n}\n```\n驿寄梅花，鱼传尺素，砌成此恨无重数。\n```javascript\nwhile (received(friend.plumBlossom) && received(friend.letter)) {\n    nostalgicThoughts++;\n}\n```\n总为浮云能蔽日，长安不见使人愁。\n```javascript\nwhile (cloudsHideSun == true) {\n    if (!seeChangan) {\n        self.worry();\n    }\n}\n```\n人生得意须尽欢，莫使金樽空对月。\n```javascript\nif (life.satisfied()) {\n    while (happy--) {\n        if (!goldenCup.empty() && moon.visible()) {\n            goldenCup.fulfill();\n        }\n    }\n}\n```\n苟利国家生死以，岂因祸福避趋之。\n```txt\ndog(pear -> fruit).home.deliver(death, 1);\nflag in [ disaster, fortune ] -> () { pen.go(arguments[0]) };\n```\n\n---\n\n以上内容大部分来源于微博：[猜一宋词名句 - 程序员幽默](https://weibo.com/1814392721/xDOh7ErYZ)\n\n更多可参考：[程序员如何用代码写一首诗？](https://www.zhihu.com/question/20982625)\n","categories":["幽默"]},{"title":"搭建MCPE服务器","url":"/2018-04/搭建MCPE服务器/","content":"\n目前搭建MCPE服务器的方法主要有两种：[PocketMine-MP](https://github.com/pmmp/PocketMine-MP)和[Nukkit](https://github.com/NukkitX/Nukkit)。前者基于PHP，而后者基于Java。\n无论选择哪一种方法，都要确保游戏客户端和服务器端均是最新版本。如果版本不匹配，可能造成无法连接等问题。\n\n## PocketMine-MP\n\n运行PocketMine-MP需要PHP7环境和大量的拓展库，例如`php-leveldb`和`yaml`等。即使你已经通过`brew`、`yum`等包管理工具安装了PHP，也可能无法正确启动服务器——它们一般是不会自带这些拓展库的。为了免去手动编译安装拓展的麻烦，比较简单的解决方法是使用[php-build-scripts](https://github.com/pmmp/php-build-scripts)。它会编译出带有所有必要的拓展库的PHP，供PocketMine-MP使用，并且不会与系统原有的PHP环境冲突。比如在Mac下，执行\n```bash\ngit clone https://github.com/pmmp/php-build-scripts.git\ncd php-build-scripts\nbash compile.sh -t mac64 -l -j4 -f\n```\n即可编译安装PHP（Linux将参数对应改为`-t linux64`即可）。\n完成后，再执行`bash installer.sh`，就会自动下载`PocketMine-MP.phar`等必要程序。最后，执行`bash start.sh`就可以运行了，接下来根据提示进行配置即可。这种方式非常方便，只要记得使用`screen`，然后等上几分钟就行。更多配置可以参考其官方文档。\n\n## Nukkit\n\nNukkit的原版似乎已经失去维护，其官方网站[Nukkit.io](https://nukkit.io)也无法打开。这里介绍的是一个fork出的分支。\nNukkit需要Java8环境，如果没有安装，可以前往[ORACLE官网](https://www.oracle.com/index.html)下载。运行方式也很简单，克隆这个仓库后，依次执行：\n```bash\ngit submodule update --init\nmvn clean package\njava -jar Nukkit.jar\n```\n当然，在其新维护者的官网上也有发布的版本，无需自行编译Jar文件，可以前往[NukkitX](https://nukkitx.com)查看。\nNukkit的主要问题是不支持`leveldb`，也就是无法打开较新的MCPE存档，只支持MC存档和上古的MCPE存档，因此建议使用第一种方法。\n\n## 客户端\n\nPocketMine-MP和Nukkit启动后默认都会监听19132端口，配置服务器时填写局域网或公网IP/域名即可。更多的设置项可以参考它们的文档。\n\n## 更多\n\n转换存档的格式可以用这个脚本：[LevelDb2Avnil](https://github.com/ljyloo/LevelDb2Avnil)，不过看上去兼容性仍存在问题，请谨慎使用。\n","tags":["我的世界"],"categories":["电子游戏"]},{"title":"Mac启动Apache服务器","url":"/2018-04/Mac启动Apache服务器/","content":"\nmacOS自带了Apache服务器和PHP环境，还包括大量动态拓展。只需要简单的配置，就可以让它运行起来。\n你可以通过`apachectl -version`查看Apache的版本；通过`php -v`可以查看PHP版本，`php -m`可以查看所有拓展。\n\n## 启动Apache\n\n在终端输入`sudo apachectl start`，即可启动Apache服务器。用浏览器打开`http://localhost`，若显示『It works!』，说明服务器启动成功。\n关闭和重启服务器的命令分别是`sudo apachectl stop`和`sudo apachectl restart`。\n如果需要开机启动服务器，可以编辑`/System/Library/LaunchDaemons/org.apache.httpd.plist`，将\n```xml\n<key>Disabled</key>\n<true/>\n```\n改为\n```xml\n<key>Disabled</key>\n<false/>\n```\n即可。\n\n## 配置服务器\n\nApache的配置文件为`/etc/apache2/httpd.conf`，为防止出现问题，请将其备份后进行编辑。如果更新了Mac系统，可能需要重新进行配置。\nApache默认的根目录在`/Library/WebServer/Documents/`下，你可以通过编辑配置文件中的`DocumentRoot`属性来修改它。\n你也可以配置启用PHP等模块。在httpd.conf中，找到\n```\nLoadModule php7_module libexec/apache2/libphp7.so\n```\n将其行首用于注释的`#`去掉，即可启用PHP。\n如果你使用brew或通过源码编译安装了其他版本的PHP，将`libphp7.so`的路径替换为对应的文件即可，例如`/usr/local/opt/php/lib/httpd/modules/libphp7.so`。具体的安装方法将在后文介绍。\n`httpd.conf`还可以设置很多其它的内容，可以自行寻找教程，此处不再赘述。\n还有一件事情是，要确保运行Apache的用户（默认为`_www`）对其根目录有读写权限，可以通过右键点击`Documents`文件夹，选择『显示简介』来修改权限，或通过`chmod`和`chown`命令递归的修改之。\n\n## 关于PHP\n\n系统自带的PHP版本较旧，可以自行安装新版本。如果使用brew安装，执行`brew install php`即可安装最新版本；如果要安装特定版本，先执行`brew search php`查看可用的版本，然后再选择一个自己需要的版本安装，例如`brew install php@7.1`。\n如果要通过源码编译PHP，可以[在此处下载](https://secure.php.net/downloads.php)源码。需要注意的是，编译PHP时要指定`make ZEND_EXTRA_LIBS='-liconv'`，否则可能会出现`undefined reference to 'libiconv'`的错误。\n安装完成后，仍然可以通过`php -v`和`php -m`检查环境是否正确。\n\n## PHP拓展\n\n很多PHP应用都需要拓展模块的支持，例如搭建Minecraft服务器的PocketMine-MP需要`leveldb`支持，而生成图片验证码需要`gd2`支持，一些应用可能还需要`redis`等。PHP支持动态拓展，编译安装后可以通过`php.ini`进行配置。以安装`phpredis`为例，具体步骤为：\n```bash\ncd /path/to/your/phpredis\nphpize\n./configure\nmake\nmake install\n```\n拓展编译完成后，在`php.ini`中加入`extension=redis.so`，重启服务后即可启用拓展模块。Mac系统自带的PHP配置文件为`/private/etc/php.ini`（把该目录下的`php.ini.default`复制一份），用brew安装的则是`/usr/local/etc/php/7.2/php.ini`。如果你的软件包安装较为混乱，找不到`php.ini`，那么可以通过`php -i | grep \"/php.ini\"`获得它所在的目录。更多方法可以参考：[PHP 查找php.ini](https://blog.flxxyz.com/technology/2018/find-php-ini.html)。\n\n## 报错信息\n\n如果使用`sudo apachectl start`命令启动Apache服务器，是不会显示错误信息的。因此，如果启动失败，还需要使用`sudo /usr/sbin/httpd -k start`查看报错信息。如果是httpd.conf配置出现问题，请对照报错的行数进行修改。如果是找不到目录等问题，检查相应的目录或权限即可。\n","tags":["Mac"],"categories":["Web开发"]},{"title":"Linux命令行常用快捷键","url":"/2018-04/Linux命令行常用快捷键/","content":"\n通过快捷键，可以方便地在Linux命令行下快速移动光标、编辑命令、编辑后执行历史命令、`Bang(!)`命令、控制命令等，有效提高工作效率。\n\n## 说明\n\n- <kbd>Ctrl</kbd>+<kbd>K</kbd>：先按住<kbd>CTRL</kbd>键，然后再按<kbd>K</kbd>键\n- <kbd>Ctrl</kbd>+<kbd>KL</kbd>：先按住<kbd>CTRL</kbd>键，然后再按<kbd>K</kbd>键，然后松开<kbd>K</kbd>键，再按<kbd>L</kbd>键\n- <kbd>Alt</kbd>+<kbd>K</kbd>：先按住<kbd>ALT</kbd>键，然后再按<kbd>K</kbd>键\n- <kbd>Meta</kbd>+<kbd>K</kbd>：先单击<kbd>Meta</kbd>（Esc）键，然后再按<kbd>K</kbd>键\n\n## 移动光标\n\n- <kbd>Ctrl</kbd>+`左右键`：在单词之间跳转\n- <kbd>Ctrl</kbd>+<kbd>A</kbd>：移到行首\n- <kbd>Ctrl</kbd>+<kbd>E</kbd>：移到行尾\n- <kbd>Ctrl</kbd>+<kbd>B</kbd>：往回（左）移动一个字符\n- <kbd>Ctrl</kbd>+<kbd>F</kbd>：往后（右）移动一个字符\n- <kbd>Ctrl</kbd>+<kbd>XX</kbd>：在命令行尾和光标之间移动\n- <kbd>Alt</kbd>+<kbd>B</kbd>：往回（左）移动一个单词\n- <kbd>Alt</kbd>+<kbd>F</kbd>：往后（右）移动一个单词\n- <kbd>Meta</kbd>+<kbd>B</kbd>：往回（左）移动一个单词\n- <kbd>Meta</kbd>+<kbd>F</kbd>：往后（右）移动一个单词\n\n## 编辑命令\n\n- <kbd>Ctrl</kbd>+<kbd>H</kbd>：删除光标左方位置的字符\n- <kbd>Ctrl</kbd>+<kbd>D</kbd>：删除光标右方位置的字符（注意：<kbd>Ctrl</kbd>+<kbd>D</kbd>也代表EOF，当前命令行没有任何字符时，会注销系统或结束终端）\n- <kbd>Ctrl</kbd>+<kbd>W</kbd>：由光标位置开始，往左删除单词（往行首删）\n- <kbd>Alt</kbd>+<kbd>D</kbd>：由光标位置开始，往右删除单词（往行尾删）\n- <kbd>Meta</kbd>+<kbd>D</kbd>：由光标位置开始，删除单词，直到该单词结束\n- <kbd>Ctrl</kbd>+<kbd>U</kbd>：由光标所在位置开始，删除左方所有的字符，直到该行开始\n- <kbd>Ctrl</kbd>+<kbd>K</kbd>：由光标所在位置开始，删除右方所有的字符，直到该行结束\n- <kbd>Ctrl</kbd>+<kbd>Y</kbd>：粘贴<kbd>Ctrl</kbd>+<kbd>U</kbd>或<kbd>Ctrl</kbd>+<kbd>K</kbd>剪切的内容到光标后\n- <kbd>Ctrl</kbd>+<kbd>T</kbd>：交换光标处和之前两个字符的位置\n- <kbd>Alt</kbd>+<kbd>.</kbd>：使用上一条命令的最后一个参数\n- <kbd>Ctrl</kbd>+<kbd>\\_</kbd>：回复之前的状态，撤销操作\n\n另外，<kbd>Ctrl</kbd>+<kbd>AK</kbd>或<kbd>Ctrl</kbd>+<kbd>EU</kbd>或<kbd>Ctrl</kbd>+<kbd>KU</kbd>组合可删除整行。\n\n<!-- more -->\n## `Bang(!)`命令\n\n- `!!`：执行上一条命令\n- `^foo^bar`：把上一条命令里的`foo`替换为`bar`，并执行\n- `!wget`：执行最近的以`wget`开头的命令\n- `!wget:p`：仅打印最近的以`wget`开头的命令，不执行\n- `!$`：上一条命令的最后一个参数，与<kbd>Alt</kbd>+<kbd>.</kbd>和`$_`相同\n- `!\\*`：上一条命令的所有参数\n- `!\\*:p`：打印上一条命令是所有参数，也即`!*`的内容\n- `^abc`：删除上一条命令中的`abc`\n- `^foo^bar`：将上一条命令中的`foo`替换为`bar`\n- `^foo^bar^`：将上一条命令中的`foo`替换为`bar`\n- `!-n`：执行前n条命令，例如`!-1`执行上一条命令，而`!-5`执行前5条命令\n\n## 查找历史命令\n\n- <kbd>Ctrl</kbd>+<kbd>P</kbd>：显示当前命令的上一条历史命令\n- <kbd>Ctrl</kbd>+<kbd>N</kbd>：显示当前命令的下一条历史命令\n- <kbd>Ctrl</kbd>+<kbd>R</kbd>：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，<kbd>Enter</kbd>键执行匹配命令；<kbd>Esc</kbd>键在命令行显示而不执行匹配命令\n- <kbd>Ctrl</kbd>+<kbd>G</kbd>：从历史搜索模式（即<kbd>Ctrl</kbd>+<kbd>R</kbd>）退出\n\n## 控制命令\n\n- <kbd>Ctrl</kbd>+<kbd>L</kbd>：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容\n- <kbd>Ctrl</kbd>+<kbd>O</kbd>：执行当前命令，并选择上一条命令\n- <kbd>Ctrl</kbd>+<kbd>S</kbd>：阻止屏幕输出\n- <kbd>Ctrl</kbd>+<kbd>Q</kbd>：允许屏幕输出\n- <kbd>Ctrl</kbd>+<kbd>C</kbd>：终止命令\n- <kbd>Ctrl</kbd>+<kbd>Z</kbd>：挂起命令\n\n## 重复执行操作动作\n\n- <kbd>Meta</kbd>+`操作次数`：指定操作次数，重复执行指定的操作\n\n---\n\n本文转载自：[Linux命令行常用光标移动快捷键](https://www.linuxidc.com/Linux/2016-10/136027.htm)\n","tags":["Mac","Linux"],"categories":["技术"]},{"title":"Shell中数学运算总结","url":"/2018-04/Shell中数学运算总结/","content":"\n如果手边没有方便的计算器，想在Shell中进行数学运算该怎么办呢？要知道，Shell中的赋值和操作默认都是字符串处理。在此，博主整理了Shell中进行数学运算的几个特殊方法。\n\n## 错误方法\n\n```bash\nvar=1+1\necho $var\n```\n输出的结果是`1+1`\n```bash\nvar=1\nvar=$var+1\necho $var\n```\n输出结果也是`1+1`\n\n## 正确方法\n\n### 使用`let`\n```bash\nvar=1\nlet \"var+=1\"\necho $var\n```\n输出结果为2\n注意：\n- 经测试，`let`几乎支持所有的运算符，包括自加、自减以及括号等，且不同运算的优先级都得到了很好的支持\n- 方幂运算应使用`**`，如`2**10`\n- 参数在表达式中直接访问，不必加$\n- 一般情况下算数表达式可以不加双引号，但是若表达式中有Bash中的关键字则需加上\n- `let`后的表达式只能进行整数运算\n\n### 使用`(())`\n```bash\nvar=1\n((var+=1))\necho $var\n```\n输出结果为2\n注意：\n(())的使用方法与`let`完全相同\n\n<!-- more -->\n### 使用`$[]`\n```bash\nvar=1\nvar=$[$var+1]\necho $var\n```\n输出结果为2\n注意：\n- `$[]`将中括号内的表达式作为数学运算先计算结果再输出\n- 对`$[]`中的变量进行访问时前面需要加$\n- `$[]`支持的运算符与let相同，也只支持整数运算\n\n### 使用`expr`\n```bash\nvar=1\nvar=`expr $var + 1`\necho $var\n```\n输出结果为2\n注意：\n- `expr`后的表达式个符号间需用空格隔开\n- `expr`支持的操作符有：|、&、<、<=、=、!=、>=、>、+、-、\\*、/、%\n- `expr`支持的操作符中所在使用时需用\\\\进行转义的有：|、&、<、<=、>=、>、\\*\n- `expr`同样只支持整数运算\n\n### 使用bc(支持浮点数计算)\n```bash\nvar=1\nvar=`echo \"$var+1\"|bc`\necho $var\n```\n输出结果为2\n介绍：\n`bc`是linux下的一个简单计算器，可以进行浮点数计算，在命令行下输入`bc`即进入计算器程序，而我们想在程序中直接进行浮点数计算时，利用一个简单的管道即可解决问题。\n注意：\n经测试，`bc`支持除位操作运算符之外的所有运算符。`bc`中要使用`scale`进行精度设置。\n浮点数计算实例：\n```bash\nvar=3.14\nvar=`echo \"scale=2;$var*3\"|bc`\necho $var\n```\n输出结果为9.42\n\n### 使用`awk`(支持浮点数计算)\n```bash\nvar=1\nvar=`echo \"$var 1\"|awk '{printf(\"%g\",$1+$2)}'`\necho $var\n```\n输出结果为2\n介绍：\n`awk`是一种文本处理工具，同时也是一种程序设计语言，作为一种程序设计语言，`awk`支持多种运算，而我们可以利用`awk`来进行浮点数计算，和上面`bc`一样，通过一个简单的管道，我们便可在程序中直接调用`awk`进行浮点数计算。\n注意：\n- `awk`支持除微操作运算符之外的所有运算符\n- `awk`内置有log、sqr、cos、sin等函数\n\n浮点数计算实例：\n```bash\nvar=3.14\nvar=`echo \"$var 2\"|awk '{printf(\"%g\",sin($1/$2))}'`\necho $var\n```\n输出结果为1\n\n---\n\n本文转载自：[shell 中数学计算总结](https://www.cnblogs.com/liujiahi/archive/2011/03/30/2196400.html)\n","tags":["Mac","Linux"],"categories":["程序设计"]},{"title":"你的使用说明书","url":"/2018-04/你的使用说明书/","content":"\n\\_\\_\\_\\_擅于发现美的事物，并从中吸收能量，变得越来越好看。\n\\_\\_\\_\\_笑起来像个孩子，把他带在身边，能带来青春永驻的效果。\n请多给予\\_\\_\\_\\_一点睡眠时间。\n\\_\\_\\_\\_偶尔也有像天使一样温柔的时候。\n\\_\\_\\_\\_喜欢自由，适合经常带出去放养。\n肚子饿了就会心情不好，带\\_\\_\\_\\_一起去吃美味的食物吧！\n\\_\\_\\_\\_常常给身边的人带来好运。\n\\_\\_\\_\\_因为太可爱了，会令人陷入沉迷，属于正常现象。\n\\_\\_\\_\\_遇到香喷喷的东西就会变圆。\n可能因为材质特殊，\\_\\_\\_\\_对外界的攻击有折射能力。\n\\_\\_\\_\\_虽然经过多次更新迭代，但依然有颗纯真的心。\n\\_\\_\\_\\_发光的时候，可能会使对象产生短时眩晕，使用时请注意。\n\\_\\_\\_\\_拥有迷之运气，中乐透的实力异于常人。\n只要缘分到了，\\_\\_\\_\\_自己就会瘦下来。\n\\_\\_\\_\\_拥有高性能大脑，可快速运转，但过度工作（学习）容易发热。\n\\_\\_\\_\\_买买买时会释放出强大气场，胆子也会变大。\n\\_\\_\\_\\_常常因为无法体验人类的乐趣而神伤。\n\\_\\_\\_\\_是能带来元气和灵感的谜之吉祥物。\n\\_\\_\\_\\_心心念念的梦，会在某个不经意的时候实现。\n\\_\\_\\_\\_的光芒太耀眼，但也不至于会刺瞎别人。\n\\_\\_\\_\\_历经严苛质检品控，是市面上难得一遇的珍品。\n只要对\\_\\_\\_\\_倾注感情，他就能成为最可靠的伙伴，遇到危机可无限次召唤。\n\\_\\_\\_\\_的出厂设定就是温暖的守护者，也是周围人快乐和活力的源泉。\n\\_\\_\\_\\_有极为罕见的感官知觉，对他说谎可不是明智之举。\n\\_\\_\\_\\_装备了精准的探测仪，能发觉并把握住人生中真正的机会。\n\\_\\_\\_\\_能通过每次挑战完成升级，获得更高的智慧和运气。\n\\_\\_\\_\\_具备安全与稳定性，是居家、旅行必备的小能手。\n\\_\\_\\_\\_能快速拆卸烦恼，重新制作出充满乐趣和创造力的产物。\n变态（萌）是\\_\\_\\_\\_的常态。\n保温杯和泡脚桶，可延长\\_\\_\\_\\_的使用寿命。\n\\_\\_\\_\\_偶尔会孤单，但也能享受孤单，是一款自由的产品。\n\\_\\_\\_\\_对时间的感知力弱，所以不知不觉又加班了。\n\n<!-- more -->\n\\_\\_\\_\\_拥有读气氛的技巧和超高感知力，自己却毫无察觉。\n\\_\\_\\_\\_是怪人，但接触后会很有趣，一款来自外星的产品。\n\\_\\_\\_\\_听到喜爱的音乐，就能触发运气开挂的效果。\n\\_\\_\\_\\_还在努力融入人类世界，拥有地球人不具备的思维方式。\n\\_\\_\\_\\_肯花费大量时间和精力，超出预期的完成任务。\n要定期给予\\_\\_\\_\\_喂食，他相当单纯。\n请用纤细的语调对\\_\\_\\_\\_说话吧。\n如果做事开始慢腾腾，及时给\\_\\_\\_\\_一点吃的。\n\\_\\_\\_\\_如果发生故障，就给他一个拥抱吧。\n\\_\\_\\_\\_喜欢被夸奖，所以一天表扬他一次吧。\n\\_\\_\\_\\_一困就会情绪低落，请给予他适当的睡眠时间。\n\\_\\_\\_\\_即使心情低落，也会保持精神，这时候给他送些点心吧。\n\\_\\_\\_\\_心情不好的时候，给他吃一点甜甜的东西吧！\n\\_\\_\\_\\_最大的兴趣就是睡觉。\n\\_\\_\\_\\_能带给你更神奇的经历...当你带他出去玩的时候。\n\\_\\_\\_\\_看着对方眼睛说话就会脸红。\n\\_\\_\\_\\_对气温变化的感知力很弱，可能因为内心一直是暖的。\n\\_\\_\\_\\_脑子里塞满天真的幻想，能拍成一部高分动画片。\n\\_\\_\\_\\_遇到寒冷的温度就会变圆。\n\\_\\_\\_\\_吃越少，越会变胖\n吃饭也是\\_\\_\\_\\_缓解压力的一种办法\n\\_\\_\\_\\_易燃，需要时刻为他准备好灭火器。\n\\_\\_\\_\\_拥有巨大内存，收到的关心（和红包）他都会记得。\n如果丢开\\_\\_\\_\\_不管，要小心他自己溜走了！\n未来的道路上，\\_\\_\\_\\_会因为无敌而略感寂寞。\n\\_\\_\\_\\_不擅长向别人求助。如果有人察觉到的话请主动帮他一下。\n\\_\\_\\_\\_的脑部为S级原装货，其他身体部分都是普通零件。\n如果你觉得\\_\\_\\_\\_发量开始减少，那一定是出现了幻觉。\n\\_\\_\\_\\_只要一出门就会变漂亮。\n\\_\\_\\_\\_遇到刮痕损伤不会自己修理。\n\\_\\_\\_\\_对地球充满好奇，喜欢人类（不工作时）的生活方式。\n\\_\\_\\_\\_只要开启降噪模式，就能获得坚定追随内心和直觉的勇气。\n\\_\\_\\_\\_早上起床时容易发生爆炸。\n\\_\\_\\_\\_按时睡觉的程序被设计的太复杂，很难执行。\n\n可以在这里查看JavaScript版本：[ZSQ.IM > 更多 > 你的使用说明书](https://zsq.im/tool/163.html)\n","categories":["幽默"]},{"title":"Bilibili弹幕文件的解析","url":"/2018-03/Bilibili弹幕文件的解析/","content":"\nB站的每个视频都有`aid`和`cid`两个参数，在已知视频`aid`（即AV号）的情况下，可以通过链接`https://www.bilibili.com/widget/getPageList?aid=10492`获取`cid`（将10492替换为你要查询的视频的aid）。\n视频的更多信息则可以通过`https://api.bilibili.com/view?type=jsonp&appkey=8e9fc618fbd41e28&id=10492`获取。\n视频的弹幕文件采用xml格式存储，地址与其`cid`有关，为`https://comment.bilibili.com/$cid.xml`（将`$cid`替换为视频的`cid`）。\n对于有许多分P的视频，它们的aid（AV号）相同，每个分P则对应一个不同的`cid`。而在同一个页面下的番剧、影视等内容，每一分集的`cid`也是唯一的。\n弹幕内容的存储方式为：\n```xml\n<d p=\"0,1,25,16777215,1312863760,0,eff85771,42759017\">前排占位置</d>\n```\n这个元素中的各个参数由逗号分割，其意义分别为：\n- 弹幕出现的时间，以秒为单位\n- 弹幕的模式：1～3滚动弹幕 4底端弹幕 5顶端弹幕 6逆向弹幕 7精准定位 8高级弹幕\n- 字号：12非常小 16特小 18小 25中 36大 45很大 64特别大\n- 字体的颜色：将HTML六位十六进制颜色转为十进制表示，例如#FFFFFF会被存储为16777215，因为$(FFFFFF)\\_{16}=(16777215)\\_{10}$\n- Unix时间戳，以毫秒为单位，基准时间为1970-1-1 08:00:00\n- 弹幕池：0普通池 1字幕池 2特殊池（注：目前特殊池为高级弹幕专用）\n- 发送者的ID，用于『屏蔽此弹幕的发送者』功能\n- 弹幕在弹幕数据库中rowID，用于『历史弹幕』功能\n\n---\n\n将Bilibili弹幕的xml文件转为ass字幕，可以使用以下脚本：\n[bilibili ASS 弹幕在线转换](http://tiansh.github.io/us-danmaku/bilibili)\n[us-danmaku](https://github.com/tiansh/us-danmaku)\n\n关于ass字幕格式可以参考以下文章：[ASS字幕格式规范](https://www.douban.com/note/658520175)\n\n拓展阅读：\n[Bilibili视频播放页面接口整理（不定期更新） - 知乎](https://zhuanlan.zhihu.com/p/24599052)\n[Bilibili爬取视频信息进行数据分析](https://www.jianshu.com/p/f628679883e3)\n","categories":["技术"]},{"title":"Quine——输出自身的程序","url":"/2018-03/Quine——输出自身的程序/","content":"\n能够输出自身的代码被称为Quine，以哲学家Willard van Orman Quine（1908-2000）而命名。\nQuine在图灵完备的语言中都是可行的。在可计算性理论（computability theory）中，图灵等价指的是：对于两个计算机A和B，如果A可以模拟B，B可以模拟A，就称他们是图灵等价的。根据『丘奇-图灵』理论，图灵机是表达能力最强大的计算系统，对现实世界中的任何计算机，都可以用图灵机来模拟它。\n套用上面的定义，如果一个编程语言可以完全模拟图灵机，那么它就是图灵完备的。大部分编程语言都是图灵完备的，因为他们需要解决各种问题的通用能力，而这正是图灵机所具备的。不过也存在一些语言不是图灵完备的，他们通常是被设计用来解决某些特殊的问题，比如SQL以及正则表达式。\n\n---\n\nShell\n```bash\nz=\\' a='z=\\\\$z a=$z$a$z\\; eval echo \\$a'; eval echo $a\n```\n\nPHP\n```php\necho file_get_content(__FILE__);\n```\n\nJavaScript\n```javascript\n!function $(){console.log('!'+$+'()')}()\n```\n```javascript\nvar s = 'var%20s%20%3D%20%27__%27%3B%20console.log%28unescape%28s%29.replace%28%27__%27%2C%20s%29%29'; console.log(unescape(s).replace('__', s))\n```\n\nPython\n```python\nr='r=%r;print r%%r';print r%r\n```\n```python\nx='y=\"x=\"+`x`+\"\\\\n\"\\nprint y+x'\ny=\"x=\"+`x`+\"\\n\"\nprint y+x\n```\n\n<!-- more -->\nPerl\n```perl\n$_=q{print\"\\$_=q{$_};eval\"};eval\n```\n\nPascal\n```pascal\nCONST T=';BEGIN WRITE(#67#79#78#83#84#32#84#61#39,T,#39,T)END.';BEGIN WRITE(#67#79#78#83#84#32#84#61#39,T,#39,T)END.\n```\n\nC\n```c\nchar*s=\"char*s=%c%s%c;main(){printf(s,34,s,34);}\";main(){printf(s,34,s,34);}\n```\n```c\nmain(){char s[]=\"main(){char s[]=%c%s%c;printf(s,34,s,34);return 0;}\";printf(s,34,s,34);return 0;}\n```\n```c\n#include\nchar buff[80];\nint main() {\n\tFILE *fp;\n\tfp = fopen(__FILE__, \"r\");\n\twhile(!feof(fp)) {\n\t\tprintf(\"%s\",fgets(buff,79,fp));\n\t}\n\tfclose(fp);\n}\n```\n\nBrainfuck\n```brainfuck\n>+>+++>>+>++>+>+++>>+>++>>>+>+>+>++>+>>>>+++>+>>++>+>+++>>++>++>>+>>+>++>++>+>>>>+++>+>>>>++>++>>>>+>>++>+>+++>>>++>>++++++>>+>>++>+>>>>+++>>+++++>>+>+++>>>++>>++>>+>>++>+>+++>>>++>>+++++++++++++>>+>>++>+>+++>+>+++>>>++>>++++>>+>>++>+>>>>+++>>+++++>>>>++>>>>+>+>++>>+++>+>>>>+++>+>>>>+++>+>>>>+++>>++>++>+>+++>+>++>++>>>>>>++>+>+++>>>>>+++>>>++>+>+++>+>+>++>>>>>>++>>>+>>>++>+>>>>+++>+>>>+>>++>+>++++++++++++++++++>>>>+>+>>>+>>++>+>+++>>>++>>++++++++>>+>>++>+>>>>+++>>++++++>>>+>++>>+++>+>+>++>+>+++>>>>>+++>>>+>+>>++>+>+++>>>++>>++++++++>>+>>++>+>>>>+++>>++++>>+>+++>>>>>>++>+>+++>>+>++>>>>+>+>++>+>>>>+++>>+++>>>+[[->>+<<]<+]+++++[->+++++++++<]>.[+]>>[<<+++++++[->+++++++++<]>-.------------------->-[-<.<+>>]<[+]<+>>>]<<<[-[-[-[>>+<++++++[->+++++<]]>++++++++++++++<]>+++<]++++++[->+++++++<]>+<<<-[->>>++<<<]>[->>.<<]<<]\n```\n\nLisp（mit-scheme）\n```lisp\n((lambda (x) (list x (list (quote quote) x))) (quote (lambda (x) (list x (list (quote quote) x)))))\n```\n\n---\n\n参考文章：\n[最小的图灵完备语言——BrainFuck](https://www.cnblogs.com/boring09/p/4865640.html)\n[能不能写出一个代码，使代码的运行结果是输出这段代码本身？ - 知乎](https://www.zhihu.com/question/63454918)\n\n拓展阅读：\n[The Quine Page](https://www.nyx.net/~gthompso/quine.htm)\n[是否无法写一段代码将这段代码自己打印出来？ - 知乎](https://www.zhihu.com/question/22006572/answer/47959891)\n[编程领域都有哪些牛逼闪闪的『禁术』？ - 知乎](https://www.zhihu.com/question/28277116/answer/311814137)\n\n更多神奇的Quine代码：\n[quine-relay](https://github.com/mame/quine-relay)\n[quine-central](https://github.com/dpiponi/quine-central)\n","categories":["程序设计"]},{"title":"Mac反编译apk程序","url":"/2018-03/Mac反编译apk程序/","content":"\nAPK，即Android应用程序包（Android application package），是Android操作系统使用的一种应用程序包文件格式，用于分发和安装移动应用及中间件。一个Android应用程序的代码想要在Android设备上运行，必须先进行编译，然后被打包成为一个被Android系统所能识别的文件才可以被运行，而这种能被Android系统识别并运行的文件格式便是APK。一个APK文件内包含被编译的代码文件(`.dex`文件)，文件资源（resources）， assets，证书（certificates），和清单文件（manifest file）。\n\nAPK文件基于ZIP文件格式，它与JAR文件的构造方式相似。因而，直接解压APK文件可以得到一部分信息，如`classes.dex`等。如果要进行更详尽的分析，就需要用到反编译的工具了。\n\n## 准备工作\n\n### 下载最新的JDK\n\n前往[ORACLE官网](https://www.oracle.com/index.html)，在底部找到[Download Java for Developers](https://www.oracle.com/technetwork/java/javase/downloads/index.html)，点击该链接，在打开的页面中找到JDK，选择Download，然后下载对应的版本即可。\n\n![](/images/2018-03/jdk.png)\n\n### 配置JDK\n\n下载完成后，打开dmg镜像进行安装。JDK会被安装到`/Library/Java/JavaVirtualMachines`目录下。为了能在终端正确运行最新的JDK，需要配置环境变量。在`~/.bash_profile`中增加以下内容：\n```bash\nJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home\nPATH=$JAVA_HOME/bin:$PATH:.\nCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.\nexport JAVA_HOME\nexport PATH\nexport CLASSPATH\n```\n其中，将`jdk1.8.0_40.jdk`换成你所安装的JDK对应的版本和目录。修改完成后，重开终端或使用\n```bash\nsource ~/.bash_profile\n```\n使环境变量生效。\n\n### 下载apk反编译组件\n\n需要下载的程序包括：\n- [Apktool](https://ibotpeaches.github.io/Apktool/install)\n- [dex2jar](https://github.com/pxb1988/dex2jar/releases)\n- [JD-GUI](http://java-decompiler.github.io)\n\n一些论坛里会把它们称为『APK反编译三件套』。\n\n<!-- more -->\n## 进行反编译\n\n### 运行Apktool\n\n按照官网上的教程，将下载Apktool后得到的Shell脚本和`apktool.jar`移动到`/usr/local/bin`，然后在终端执行`apktool -h`，如果能正确显示帮助信息，则安装正常。\nApktool的使用方法也很简单，准备好需要反编译的apk文件（例如`example.apk`），执行\n```bash\napktool d path/to/example.apk\n```\n即可进行反编译，这时会生成一个名为example的目录，用于存储反编译出的文件。如果要回编译，执行\n```bash\napktool b path/to/example\n```\n当然，仅通过回编译得到的apk是没有签名的。如果要在安卓手机上安装，还需要进行签名。步骤如下：\n```bash\nkeytool -genkey -alias tmp.keystore -keyalg RSA -validity 20000 -keystore tmp.keystore\njarsigner -verbose -keystore tmp.keystore -signedjar path/to/example.apk path/to/example_signed.apk tmp.keystore\n```\n这会生成一个签名文件`tmp.keystore`和可供安装的`example_signed.apk`。\n\n### 用dex2jar将apk转成jar文件\n\n下载dex2jar的releases版本后，解压进入文件夹，然后运行：\n```bash\n./d2j-dex2jar.sh path/to/example.apk\n```\n在dex2jar目录下将得到example-dex2jar.jar文件\n\n### 查看源代码\n\n打开`JD-GUI.app`，将`example-dex2jar.jar`拖进去就能看到源码了。\n需要注意的是，如果你使用了Java9，打开JD-GUI时可能会出现问题，解决方法是修改`JD-GUI.app/Contents/Info.plist`，找到\n```xml\n<key>VMOptions</key>\n<string>-Xms512m</string>\n```\n改为\n```xml\n<key>VMOptions</key>\n<string>-Xms512m --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens jdk.zipfs/jdk.nio.zipfs=ALL-UNNAMED</string>\n```\n即可正常启动。\n通过看Java源码对比smali文件，修改后回编译就ok了！\n\n---\n\n本教程以macOS 10.13为例。其它的版本的Mac可能在操作上略有差别。\n\n参考文章：\n[MAC安装JDK及环境变量配置](https://blog.csdn.net/vvv_110/article/details/72897142)\n[MAC上反编译android apk---apktool, dex2jar, jd-jui安装使用(含手动签名)](https://blog.csdn.net/yanzi1225627/article/details/48215549)\n[apk反编译获取完整源码 及 apk反编译后的处理](https://blog.csdn.net/wh_19910525/article/details/7915738)\n[Java 9 Compatibility](https://github.com/java-decompiler/jd-gui/issues/187)\n","tags":["Mac"],"categories":["技术"]},{"title":"数学笑话","url":"/2018-03/数学笑话/","content":"\nA point walks into A bar. $\\bar{A}$ says, \"We're closed.\"\n$e^{x}$ is walking down the street when it sees $\\pi$ running towards him. \"Help!\", $\\pi$ shouts, There's a differential operator coming my way, and if it catches me, I'll be reduced to nothing! $e^{x}$ confidently says \"Stand beside me, $\\pi$! Together, we'll be safe from any differential operators we come across!\" Suddenly, the differential operator appears and asks \"Who are you?\" They respond \"We are $\\pi e^{x}$. Who are you?\" It smiles and says \"$\\frac{\\partial}{\\partial{y}}$\".\n\n![](/images/2018-03/calczilla.png)\n\n<!-- more -->\nQ: What Thanksgiving treat can you make by dividing the circumference of a pumpkin by its diameter?\nA: Pumpkin Pi!\nQ: What does the \"B\" in Benoit B. Mandelbrot stand for?\nA: Benoit B. Mandelbrot\nQ: What is an anagram of \"Banach-Tarski\"?\nA: Banach-Tarski Banach-Tarski\n\nPaul Erdos once said that mathematicians are machines that turn coffee into theorems. By duality, we have that comathematicians are comachines that turn cotheorems into ffee.\n\nA mathematician calls over a clerk in the produce aisle. \"Pardon me sir, but I think this mislabeled. A coconut is just a nut.\"\n\nIf Wedderburn says it’s obvious, everybody in the room has seen it ten minutes ago. If Bohnenblust says it’s obvious, it’s obvious. If Bochner says it’s obvious, you can figure it out in half an hour. If von Neumann says it’s obvious, you can prove it in three months if you are a genius. If Lefschetz says it’s obvious, it’s wrong.\n\nOur computer science professor was joking that our student cafeteria serves Fibonacci soup. The soup of today is the mix of yesterday's soup and the day before.\n\nComputational results are believed by no one, except for the person who wrote the code. Experimental results are believed by everyone, except for the person who ran the experiment.\n\nTheory is when you know everything but nothing works. Practice is when everything works but no one knows why. In our lab, theory and practice are combined: nothing works and nobody knows why.\n\n西江月·证明\n即得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。\n反之亦然同理，推论自然成立。略去过程Q.E.D.，由上可知证毕。\n\n---\n\n参考文章：\n[Abstruse Goose - Calc-zilla](https://abstrusegoose.com/26)\n[数学领域有哪些经典的笑话？ - 知乎](https://www.zhihu.com/question/22212241)\n","tags":["数学"],"categories":["幽默"]},{"title":"MySQL 8.0的安装和使用","url":"/2018-03/MySQL 8.0的安装和使用/","content":"\n## MySQL的安装\n\n在MySQL官网的[下载页](https://dev.mysql.com/downloads)上，提供了各种系统和环境的安装方法。你可以选择通过包管理工具的软件源安装，也可以通过源码编译安装。不过编译是非常吃内存的（至少需要4GiB内存），并且还很耗时（毕竟是C++写的），因此不推荐。具体来说，你可以：\n\n### 使用包管理工具\n\n以`yum`为例，首先增加并启用MySQL软件源，在[这个页面](https://dev.mysql.com/downloads/repo/yum)找到适合你的版本，然后下载并启用之：\n```bash\nwget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm #换成适合你的版本\nrpm -ivh mysql80-community-release-el7-1.noarch.rpm\nyum-config-manager --enable mysql80-community\n```\n这样，就可以直接通过yum安装MySQL服务器了。\n```bash\nyum install mysql-community-server\n```\n安装完成后，会在`/usr/sbin/`和`/usr/bin/`目录下出现MySQL的可执行文件，而`mysqld.service`会自动加载好。MySQL的配置文件则是`/etc/my.cnf`。\n\n如果你在使用macOS，并配置好了Homebrew：\n```bash\nbrew install mysql\n```\n其它系统也可以使用相应的包管理工具安装。\n\n### 使用源码编译安装\n\n再次提醒：源码编译安装方式非常麻烦，如果可以的话请使用包管理工具安装。\n```bash\nwget wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.13.tar.gz\ntar -xzvf mysql-boost-8.0.13.tar.gz\ncd mysql-boost-8.0.13\ncmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DDOWNLOAD_BOOST=1 -DWITH_BOOST=boost -DSYSCONFDIR=/etc -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DWITH_FEDERATED_STORAGE_ENGINE=1 -DWITH_BLACKHOLE_STORAGE_ENGINE=1 -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_EMBEDDED_SERVER=1 -DENABLE_DTRACE=0 -DENABLED_LOCAL_INFILE=1 -DDEFAULT_CHARSET=utf8mb4 -DEXTRA_CHARSETS=all\nmake && make install\n```\n这里的`-DCMAKE_INSTALL_PREFIX`和`-DMYSQL_DATADIR`参数指定了MySQL的安装目录和数据文件存储目录。\n\n<!-- more -->\n## MySQL的配置\n\n为了正确地让PHP链接MySQL数据库，在`/etc/my.cnf`中，配置以下内容：\n```bash\n[mysqld]\ndatadir=/data/mysql\nsocket=/tmp/mysql.sock\n\nlog-error=/var/log/mysqld.log\npid-file=/var/run/mysqld/mysqld.pid\n\n[client]\nsocket=/tmp/mysql.sock\n```\n这里的datadir是数据文件存储目录，请确保用户mysql对其拥有访问权限。如果是覆盖升级安装，需要确保它与之前版本MySQL使用的目录相同。\n而socket是UNIX套接字，使用它的地方要保持一致。具体来说，你需要保证：\n- `/etc/my.cnf`中，`[mysqld]`下的`socket`值\n- `/etc/my.cnf`中，`[client]`下的`socket`值\n- `php.ini`中，`[Pdo_mysql]`下的`pdo_mysql.default_socket`值\n- `php.ini`中，`[MySQLi]`下的`mysqli.default_socket`值\n\n这四个值是一致的。而之所以选择`/tmp/mysql.sock`，是因为PHP默认的MySQL套接字在这个位置，配置好`my.cnf`就行，而不用修改PHP的配置（即php.ini中的对应项留空即可，会采用默认值）；如果用了其他的目录，就需要修改`php.ini`。\n`php.ini`根据你的安装方式，可能出现在`/etc`或`/usr/local/php`下的某个位置，可以自行处理。\n为了优化MySQL，还可以在`/etc/my.cnf`中增加如下设置：\n```bash\n[mysql]\nno-auto-rehash\nconnect_timeout=2\nprompt=\"MySQL [\\\\d]> \"\n\n[mysqldump]\nquick\nmax_allowed_packet = 500M\n```\n其中，`[mysql]`下的`prompt`允许个性化设置提示符，在操作数据库时更加方便快捷。可用的参数有：\n\nOption | Description\n- | -\n\\c | A counter that increments for each statement you issue\n\\D | The full current date\n\\d | The default database\n\\h | The server host\n\\l | The current delimiter (new in 5.0.25)\n\\m | Minutes of the current time\n\\n | A newline character\n\\O | The current month in three-letter format (Jan, Feb, …)\n\\o | The current month in numeric format\n\\P | am/pm\n\\p | The current TCP/IP port or socket file\n\\R | The current time, in 24-hour military time (0–23)\n\\r | The current time, standard 12-hour time (1–12)\n\\S | Semicolon\n\\s | Seconds of the current time\n\\t | A tab character\n\\U | Your full user_name@host_name account name\n\\u | Your user name\n\\v | The server version\n\\w | The current day of the week in three-letter format (Mon, Tue, …)\n\\Y | The current year, four digits\n\\y | The current year, two digits\n\\\\_ | A space\n\\  | A space (a space follows the backslash)\n\\' | Single quote\n\\\" | Double quote\n\\\\\\\\ | A literal \"\\\" backslash character\n\\x | x, for any \"x\" not listed above\n\n这里的配置将会显示当前的数据库名。\n\n## 启动\n\n完成设置后，重新启动mysqld即可：\n```bash\nsystemctl restart mysqld\n```\n如果是macOS上使用Homebrew安装的，需要使用`mysql.server start`命令手动开启MySQL服务。可以通过运行`lsof -i:3306`查看MySQL是否正确工作在3306端口。\n如果你是初次登陆，通过以下方式查看临时root密码：\n```bash\ngrep 'temporary password' /var/log/mysqld.log\n```\n然后执行\n```bash\nmysql -u root -p\n```\n按回车后输入密码，即可登录。如果你登录后设置了新的root密码，一定要记住。\n除此之外，如果要直接登录某个数据库，执行：`mysql -h host -u user -p dbname`。\n而如果是升级安装的，需要先执行`mysql_upgrade -u root -p`来升级数据库。\n\n## MySQL命令\n\n以下所有命令均需要以`;`结尾，大小写取决于系统设置。\n- 显示版本：`SHOW VARIABLES LIKE \"%version%\";`\n- 查看所有的库：`SHOW DATABASES;`\n- 创建数据库：`CREATE DATABASE dbname;`\n- 删库：`DROP DATABASE dbname;`\n- 跑路：略\n- 使用某个库：`USE dbname;`\n- 查看库有哪些表：`SHOW TABLES;`\n- 查看表的列：`DESCRIBE tablename;`\n- 创建表需要用`CREATE TABLE`并指定数据结构\n- 删除某个表：`DROP TABLE tablename`\n- 添加用户：`CREATE USER 'username'@'host' IDENTIFIED BY 'password';`\n- 删除用户：`DROP USER 'username'@'host';`\n- 显示用户信息：`SELECT User, Host FROM mysql.user;`\n- 授权：`GRANT SELECT, UPDATE ON dbname.* TO 'username'@'host' WITH GRANT OPTION;`\n- 所有权限：`GRANT ALL ON dbname.* TO 'username'@'host' WITH GRANT OPTION;`\n- 刷新权限：`FLUSH PRIVILEGES;`\n- 退出：`QUIT;`\n\nMySQL 8.0的用户授权和之前有所区别，老版本的常用授权语句在8.0中会报错。\n在执行命令时，如果数据库名、表名等包含特殊字符，例如`-`等，要避免出现语法错误。例如：\n```sql\nDROP DATABASE hello-world;\n```\n直接这样输入会造成问题，正确做法是：\n```sql\nDROP DATABASE `hello-world`;\n```\n如果对这些命令不熟悉，也可以安装phpMyAdmin之类的辅助软件。\n\n## 后记\n\nMySQL8.0是MySQL5.7的后继版本，这次更新带来了许多新特性，比如更好的字符集支持、降序排列的优化等。官方宣传性能提高了2倍。\n不过版本号从5.7之间跨越到了8.0确实是一次大飞跃，PHP 6、Windows 9和iPhone 9点了个赞，Sketch和Java笑而不语。\n当然，这样还有一个好处是，避免[版本6.4被GFW屏蔽](https://groups.google.com/forum/#!topic/nodejs/iAPl--KJhK8)。嗯，仿佛没有什么问题。\n","tags":["MySQL"],"categories":["技术"]},{"title":"一行代码为网站添加访客地图","url":"/2018-02/一行代码为网站添加访客地图/","content":"\nRevolver Maps是一个交互式的网站访客地图。每一个浏览者的位置都会实时在由Canvas渲染的地球上标记出来。在它的[官方网站](https://www.revolvermaps.com/?target=gallery)上，你可以轻松地选择地图样式，并生成用于插入HTML页面的script标签。\n\n![](/images/2018-02/data-1491837049070-rJZtl7Y6x.jpg)\n\n其中，RevolverMaps Standard GL样式是响应式的，会自适应父元素大小，非常适合作为访客地图使用。点击『Get this Widget!』按钮，在新的页面中调整参数，可以自定义颜色、缩放、旋转等等。完成后，将生成的script标签复制下来，并放在你想要生成地图的地方即可。例如：\n```xml\n<script type=\"text/javascript\" src=\"//ra.revolvermaps.com/0/0/8.js?i=0pdvpgzth5r&amp;m=7&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;v0=20&amp;z=11\" async=\"async\"></script>\n```\n这时，效果看上去会是这样：\n\n![](/images/2018-02/revolvermaps-1.png)\n\n类似地，你也可以把它放到WordPress博客的侧边小工具栏中，像下图这样：\n\n![](/images/2018-02/revolvermaps-2.png)\n\n访问站点时，访客地图就会自动显示了。\n","categories":["Web开发"]},{"title":"米米弹幕系统正式上线","url":"/2018-02/米米弹幕系统正式上线/","content":"\n在学院的新年晚会上，主办方使用了一个基于微信小程序的弹幕系统，让全场观众通过大屏幕发送弹幕互动。比较坑的是，该弹幕系统存在『高级弹幕』选项，以此向用户收费。考虑到这一系统的逻辑实际上并不复杂，博主决定自己实现一个。它被命名为『米米弹幕系统』（Mimi Danmaku），其初代版本基于Ajax轮询实现。这是客户端的样子：\n\n![](/images/2018-02/danmaku.png)\n\n当然，由于博主是第一次接触实时通讯，程序上还存在不少缺陷。在进行调研后，博主决定使用WebSocket代替原先效率极低的轮询，并重构一部分逻辑。经过数天的调试，现在全新的米米弹幕系统已经可以正常使用了。这个重制后的版本，成功实现了消息即时收发、自定义弹幕颜色、大小等功能。下一步博主将把弹幕系统整合到直播中。附上链接：\n[米米弹幕](https://mimichat.herokuapp.com/danmaku/) \n同时还开放了一个随机生成用户名（来自魔兽世界）的API：\n[随机用户名](https://api.pkupi.com/name/)\n\n---\n\n本文更新于2018年5月18日：\ngalaxymimi.com和zsq.im即日起全站支持https访问，ws连接也升级为了wss。\n\n本文更新于2019年3月27日：\n博主决定使用Heroku部署弹幕服务，又重写了不少代码。可以在此处查看：\n[mimi-chat](https://github.com/stevenjoezhang/mimi-chat)\n[mimi-danmaku](https://github.com/stevenjoezhang/mimi-danmaku)\n","tags":["系统日志"],"categories":["其他"]},{"title":"CentOS 7启动BBR教程","url":"/2018-02/CentOS 7启动BBR教程/","content":"\nBBR的全称是Bottleneck Bandwidth and RTT congestion control。该技术的目的是通过优化和控制TCP的拥塞，充分利用带宽并降低延迟，起到神奇般的加速效果——通俗来讲就是对Linux内核TCP协议的优化从而达到提速的目的。自Google于2016年9月宣布[将BBR开源](https://github.com/google/bbr)起，世界各国的极客们就开始研究了。一些受制于特殊网络环境的网民，近年来一直在寻找各种提速的方法。不论是之前流行的锐速（后开始收费），还是FinalSpeed等都曾备受大家的爱戴。BBR则提供了一个全新的加速方式，在内核较新的Linux系统，例如Ubuntu 18.04上，它可以方便的开启；而一些较旧的系统，则需要先升级内核才能启用。\n这篇文章将介绍在CentOS 7上，启动BBR的方法。文中使用的是`yum`包管理工具。如果你的主机是Debian系，需使用`apt`，请自行替换命令即可。\n\n---\n\n## yum系统更新\n\n将CentOS系统版本更新到7.3或更高：\n```bash\nyum update\nyum upgrade\n```\n查看系统版本\n```bash\ncat /etc/redhat-release\n```\n输出如下，则表示已升级到7.3\n```bash\nCentOS Linux release 7.3.1611 (Core)\n```\n\n## 安装elrepo并升级内核\n\n执行`uname -r`查看内核版本，例如：\n```bash\n4.9.0-1.el7.elrepo.x86_64\n```\n**如果内核版本低于4.9，需要升级内核；否则可以跳过这一步，直接到『开启BBR』部分。**\n```bash\nrpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm\n```\n这时，执行`yum repolist all`可以看到所有安装的源，可以启用`elrepo-kernal`：\n```bash\nyum-config-manager --enable elrepo-kernel\nyum install kernel-ml -y\n```\n如果只是执行一次，也可以使用：\n```bash\nyum --enablerepo=elrepo-kernel install kernel-ml -y\n```\n正常情况下将输出如下：\n```bash\nTransaction Summary\n================================================================================\nInstall  1 Package\n\nTotal download size: 39 M\nInstalled size: 169 M\nDownloading packages:\nkernel-ml-4.9.0-1.el7.elrepo.x86_64.rpm                    |  39 MB   00:00\nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\nWarning: RPMDB altered outside of yum.\n  Installing : kernel-ml-4.9.0-1.el7.elrepo.x86_64                          1/1\n  Verifying  : kernel-ml-4.9.0-1.el7.elrepo.x86_64                          1/1\n\nInstalled:\n  kernel-ml.x86_64 0:4.9.0-1.el7.elrepo\n\nComplete!\n```\n随后更新grub文件并重启。执行：\n```bash\negrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\'\n```\n或者\n```bash\nawk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /etc/grub2.cfg\n```\n这时，所有可用的内核会被输出。记下新内核所在的行数，第一行为0，第二行为1，以此类推。\n执行以下命令来启用最新内核，需要把0替换成上一步得到的新内核所在的行数：\n```bash\ngrub2-set-default 0\nreboot\n```\n重启后，ssh会断开，稍等一会儿重新连接。可以再次查看内核版本，检查更新是否成功。如果一切顺利，下一步就是启动bbr了。\n\n<!-- more -->\n## 开启BBR\n\n执行\n```bash\nvim /etc/sysctl.conf\n```\n追加如下内容：\n```bash\nnet.core.default_qdisc=fq\nnet.ipv4.tcp_congestion_control=bbr\n```\n加载系统参数（正常情况下会输出我们之前加入的内容）：\n```bash\nsysctl -p\n```\n**注：如果提示未找到命令，请确保SELinux已关闭，方法是编辑`/etc/selinux/config`。**\n除此之外，一些VPS主机由于虚拟化技术的限制，可能会在执行这一步时提示文件找不到：\n```bash\nsysctl: cannot stat /proc/sys/net/core/default_qdisc: No such file or directory\n```\n这不是大问题，参考：[How to get fully options at /proc/sys/net in docker's ubuntu](https://askubuntu.com/questions/673313/how-to-get-fully-options-at-proc-sys-net-in-dockers-ubuntu)。\n\n## 确定BBR已经开启\n\n### 通过sysctl\n\n若执行\n```bash\nsysctl net.ipv4.tcp_available_congestion_control\n```\n输出\n```bash\nnet.ipv4.tcp_available_congestion_control = reno cubic bbr\n```\n则表明成功。\n\n### 通过lsmod\n\n若执行\n```bash\nlsmod | grep bbr\n```\n返回形如\n```bash\ntcp_bbr                16384  1\n```\n则表明成功。\n\n---\n\n参考文章：[#为VPS加速度# CentOS 7安装bbr教程](https://www.vmvps.com/speed-up-your-vps-with-installing-bbr-to-centos-7.html)\n\n拓展阅读：[KcpRun 服务端一键安装脚本](https://blog.kuoruan.com/110.html)\n\n本文更新于2018年6月：\nBBR的效果是非常显著的，只要带宽足够，流畅播放YouTube上4320p的视频毫无压力。可以通过[Timestorm Films](https://www.youtube.com/channel/UCqOecsBLULnuUtls0tISTCw)发布的超高分辨率视频测试效果～\n","tags":["Linux"],"categories":["技术"]},{"title":"制造MD5碰撞","url":"/2018-02/制造MD5碰撞/","content":"\n下面这两张图片拥有相同的MD5值`253dd04e87492e4fc3471de5e776bc3d`：\n\n![](/images/2018-02/plane.jpg)\n![](/images/2018-02/ship.jpg)\n\n<!-- more -->\n使用Python计算文件MD5值的脚本：\n```python\n#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport hashlib\nimport os\nimport datetime\n\ndef md5sum(filename):\n    if not os.path.isfile(filename):\n        return\n    myhash = hashlib.md5()\n    f = file(filename, \"rb\")\n    while True:\n        b = f.read(8192)\n        if not b:\n            break\n        myhash.update(b)\n    f.close()\n    return myhash.hexdigest()\n\nfilepath = raw_input(\"请输入文件路径：\")\nprint(md5sum(filepath))\n```\n\n还有Python3的版本：\n```python\n#!/usr/bin/env python3\n\nimport hashlib\nfrom functools import partial\n\ndef md5sum(filename):\n    with open(filename, mode = \"rb\") as f:\n        myhash = hashlib.md5()\n        for buf in iter(partial(f.read, 128), b\"\"):\n            myhash.update(buf)\n    return myhash.hexdigest()\n\nprint(md5sum(input(\"请输入文件路径：\")))\n```\n\n拓展阅读：\n[至今有没有发现哪几个字符串的MD5相同? - 知乎](https://www.zhihu.com/question/265534528/answer/300135154)\n[Create your own MD5 collisions](https://natmchugh.blogspot.de/2015/02/create-your-own-md5-collisions.html)\n","tags":["Python"],"categories":["技术"]},{"title":"基于Nginx搭建视频直播服务器","url":"/2018-01/基于Nginx搭建视频直播服务器/","content":"\n最近几年，网络视频直播处于蓬勃的发展期，各大直播平台的竞争也趋于白热化。在游戏直播领域，就有许多电子竞技的前职业选手，退役后转行游戏主播，收入不菲。当然，网络直播的用处不仅仅是娱乐行业，诸如实时视频监控等应用方向，同样潜力无限。如果没有太高的并发播放需求，完全可以自行搭建直播服务器。借助于Nginx和一些拓展模块，你就可以轻松地运行一个小型的直播平台。\n博主在参看了大量教程后，成功地在VPS上搭建了这样的视频直播服务器，而且在昨晚经过测试，能够正常地使用OBS Studio推流，在浏览器上实现HTML5播放。下面附上具体步骤，请将所有`yourdomain.com`替换为你的域名或者服务器IP。\n\n---\n\n## Nginx环境搭建\n\n首先，需要下载可编译的Nginx源代码，以及必要的拓展库。\n\n如果你对在Linux上安装配置Nginx有所了解，可以直接使用源码安装，不必通过lnmp等工具进行安装。Nginx源码[在此处下载](https://nginx.org/en/download.html)，configure的参数后文会讲到，可以参考。\n\n如果你是萌新，请按照👇教程安装搭建lnmp环境！\n[lnmp环境一键安装脚本](https://lnmp.org/install.html)\n\n```bash\n#下载并安装lnmp环境，将1.4替换为最新版本\nwget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz\ntar -xzvf lnmp1.4.tar.gz\ncd lnmp1.4\n./install.sh lnmp\n```\n请按照脚本的提示选择你要安装的各个组件版本，若不确定，选择默认选项即可。安装完成后，命令行输出：\n\n![](/images/2018-01/1774338-dc544ac657937d0d.png)\n\n此时访问服务器地址会出现如下界面：\n\n![](/images/2018-01/1774338-b0eb1df8603e632d.png)\n\n**注意：安装时生成的解压文件夹lnmp1.4先别删除！**\n\n<!-- more -->\n## 安装Nginx的扩展模块\n\n### 下载nginx-http-flv-module\n\nGitHub项目地址：[nginx-http-flv-module](https://github.com/winshining/nginx-http-flv-module)，克隆到本地即可：\n```bash\n#为nginx创建扩展模块目录\nmkdir /usr/local/nginx/extend_module\ncd /usr/local/nginx/extend_module\n#下载扩展包到nginx扩展模块目录下\ngit clone https://github.com/winshining/nginx-http-flv-module.git\n```\n\n### 关闭nginx、php-fpm服务\n```bash\n#关闭nginx\nsystemctl stop nginx\n#关闭php-fpm\nsystemctl stop php-fpm\n```\n注意：在部分系统下需要使用`service`代替`systemctl`命令。\n\n### 查看nginx配置参数\n\n执行`nginx -V`会输出配置参数，类似于这样：\n\n![](/images/2018-01/2018-07-16.png)\n\n复制`configure arguments`后的所有参数，例如：\n```bash\n--prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_v2_module --with-http_ssl_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module\n```\n这会在后面用到。\n\n### 重新编译nginx\n\n进入安装时生成的文件夹，并执行：\n```bash\ncd lnmp1.4/src\n#解压nginx源码包，将1.14.0替换为你的版本，下同\ntar -xzvf nginx-1.14.0.tar.gz\n#进入nginx源码目录\ncd nginx-1.14.0\n#安装rtmp扩展模块，参数形式是：\n#./configure 加上 刚才复制的nginx configure参数 加上 --add-module=nginx-http-flv-module扩展包的目录\n#例如：\n./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module --add-module=/usr/local/nginx/extend_module/nginx-http-flv-module\n#如果lnmp编译的nginx包含--add-module=openssl等，也需要一并解压，否则会报错找不到文件\n#编译\nmake\n#安装\nmake install\n#重启nginx\nsystemctl start nginx\nsystemctl start php-fpm\n```\n重新启动nginx后，再次执行`nginx -V`查看安装状态，如果`configure arguments`后出现`nginx-http-flv-module`说明安装成功！\n\n## 服务器开放1935端口\n\n**注：若服务器防火墙已关闭，请跳过此步。**\n```bash\n#开放1935端口\n/sbin/iptables -I INPUT -p tcp --dport 1935 -j ACCEPT\n#保存配置\n/etc/rc.d/init.d/iptables save\n#或 service iptables save\n#重启服务\n/etc/rc.d/init.d/iptables restart\n#查看端口开放状态\n/etc/init.d/iptables status\n```\n执行`iptables -L`查看防火墙设置是否生效。\n\n## 配置HLS或http-flv\n\n对`nginx.conf`进行修改：\n```bash\n#编辑配置\ncd /usr/local/nginx/conf/nginx.conf\n```\n需要修改的是`http`下`server`的配置，其内容可参照：\n```bash\nserver\n{\n    listen 80 default_server;\n    #listen [::]:80 default_server ipv6only=on;\n    server_name yourdomain.com;\n    index index.html index.htm index.php;\n    root  /home/www/; #服务器的根目录\n    #error_page 404 /404.html;\n    include enable-php.conf;\n     \n    #加入hls支持\n    location /hls {\n        types {\n            application/vnd.apple.mpegurl m3u8; \n            #或 application/x-mpegURL\n            video/mp2t ts;\n        }\n        alias /home/hls/; #视频流文件目录(自己创建，与下方hls_path相同)\n        expires -1;\n        add_header Cache-Control no-cache;\n    }\n    #加入http-flv支持\n    location /flv {\n        flv_live on;\n        chunked_transfer_encoding on;\n    }\n    #server下的其余配置无需改变，此处省略\n}\n#在文档末尾加入rtmp配置\nrtmp {\n    server {\n        listen 1935; #监听的端口\n        chunk_size 4000;\n        application live { #rtmp推流请求路径\n            live on;\n            record off;\n            #publish_notify on; #推流验证，和下一行需一起使用\n            #on_publish http://localhost/auth.php; #推流验证，具体可参照后文\n\n            hls on;\n            hls_path /home/hls/test; #视频流hls切片文件目录(自己创建)\n            hls_fragment 3s; #hls单个切片时长，会影响延迟\n            hls_playlist_length 32s; #hls总缓存时间，会影响延迟\n\n            meta on; #如果http-flv播放时首帧出现问题，可改为off\n            gop_cache on; #可以减少首帧延迟\n        }\n    }\n}\n```\n\n参数说明：\n- `rtmp` 协议名称\n- `server` 说明内部中是服务器相关配置\n- `listen` 监听的端口号，rtmp协议的默认端口号是1935\n- `application` 访问的应用路径是，这里设置为了live\n- `live on` 开启直播\n- `record off` 不记录数据\n\n**修改完后执行`nginx -s reload`重载nginx配置**\n\n## 创建目录及文件\n\n根据前面配置文件中的`hls_path`创建子目录hls，例如`/home/hls`，确保nginx服务器对其具有读写权限。\n在服务器的根目录，例如`/home/www`下创建test.html文件，进行hls播放：\n```xml\n<!--test.html-->\n<html>\n<body>\n    <video autoplay webkit-playsinline controls>\n        <source src=\"http://yourdomain.com/hls/test.m3u8\" type=\"application/vnd.apple.mpegurl\" />\n        <p class=\"warning\">Your browser does not support HTML5 video.</p>\n    </video>\n    <video controls>\n        <source src=\"http://yourdomain.com/hls/test.m3u8\" type=\"application/x-mpegURL\">\n    </video>\n</body>\n</html>\n```\n\n## 开始推流\n\n如果要使用OBS Studio等软件推流，地址设置为`rtmp://yourdomain.com:1935/live/test`。\nffmpeg也可以进行推流，用法是：\n```bash\nffmpeg -re -stream_loop -1 -i /path/to/your/video.mp4 -vcodec libx264 -acodec aac -f flv rtmp://yourdomain.com:1935/live/test\n```\n版本较老的ffmpeg无法设置`-stream_loop -1`，可以前往[官方网站](http://ffmpeg.org/download.html)下载最新版本。\n\n### hls播放\n\n用http访问之前创建的test.html，即可观看直播。\n如直播没有声音，请参考[ffmpeg没有声音](https://www.jianshu.com/p/55325f29ae5a)\n**附录：浏览器对hls的支持**\n\n![](/images/2018-01/1774338-c2443fa915f45ef1.png)\n\n如果浏览器并不原生支持hls，可使用第三方插件，例如[hls.js](https://github.com/video-dev/hls.js)；或者使用[video.js](https://github.com/videojs/video.js)配合[videojs-contrib-hls](https://github.com/videojs/videojs-contrib-hls)，这也是不错的解决方案。\n\n### http-flv播放\n\n对于http-flv播放，可以使用VLC等软件测试拉流，拉流地址为`http://yourdomain.com/flv?app=live&stream=test`。\n如果要实现HTML5播放，可以使用B站开源的[flv.js](https://github.com/Bilibili/flv.js)，更多内容可以参照其文档，此处不做更多说明。\n\n### 推流验证\n\n如果配置文件中开启了`publish_notify`，那么`on_publish`项设置的页面将会被用作推流验证。如果验证失败，使这个页面返回404头即可。\n比如你设置了`on_publish http://localhost/auth.php`，那么在`auth.php`中加入一下内容即可实现：\n```php\n<?php\n@$name = $_POST['name'];\n@$pass = $_POST['pass'];\n//在某些情况下，$_POST需要改为$_GET或$_REQUEST，请自行测试\nif (empty($name) || empty($pass)) {\n    header(\"HTTP/1.0 404 Not Found\");\n    echo \"串码流不正确!\";\n}\nelse {\n    if ($pass == \"password\") {\n        echo \"串码流正确!\";\n    }\n    else {\n        header(\"HTTP/1.0 404 Not Found\");\n        echo \"串码流不正确!\";\n    }\n}\n?>\n```\n这时的推流地址也要对应改为`rtmp://yourdomain.com:1935/live/test?pass=password`。\n\n---\n\n参考文章：\n[Mac上搭建直播服务器Nginx+rtmp](https://www.cnblogs.com/jys509/p/5649066.html)\n[H5视频直播扫盲](https://www.alloyteam.com/2016/05/h5-camera-literacy)\n[基于Nginx搭建RTMP/HLS视频直播服务器](https://www.jianshu.com/p/0296a7be7928)\n更多内容可以参考文中提到的模块在GitHub上的文档。\n\n原文使用的是[nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module)，其功能被本文介绍的模块完全涵盖，故不再赘述。\n\n本文更新于2018年5月30日：\n由于nginx-http-flv-module一直在更新中，其配置文件的参数设置可能略有调整，请以文档为准，本文仅供参考。\n\n本文更新于2018年11月：\n在很多文章中都提到了一个RTMP源：`rtmp://live.hkstv.hk.lxdns.com/live/hks`，不过最近它已经失效了，不能用于拉流。你可以使用前面提到的OBS Studio和ffmpeg进行测试。\n","tags":["Linux","Nginx"],"categories":["技术"]},{"title":"JavaScript常用简写技术与扩展运算符","url":"/2018-01/JavaScript常用简写技术与扩展运算符/","content":"\n## 三元操作符\n\n当想写`if...else`语句时，使用三元操作符来代替。\n```javascript\nconst x = 20;\nlet answer;\nif (x > 10) {\n    answer = \"is greater\";\n} else {\n    answer = \"is lesser\";\n}\n```\n简写：\n```javascript\nconst answer = x > 10 ? \"is greater\" : \"is lesser\";\n\n也可以嵌套if语句：\n```javascript\nconst big = x > 10 ? \" greater 10\" : x\n```\n\n## 短路求值简写方式\n\n当给一个变量分配另一个值时，想确定源始值不是`null`，`undefined`或空值。可以写撰写一个多重条件的`if`语句：\n```javascript\nif (variable1 !== null || variable1 !== undefined || variable1 !== \"\") {\n    let variable2 = variable1;\n}\n```\n或者可以使用短路求值方法：\n```javascript\nconst variable2 = variable1  || \"new\";\n```\n另一个例子：\n```javascript\nlet dbHost;\nif (process.env.DB_HOST) {\n    dbHost = process.env.DB_HOST;\n} else {\n    dbHost = \"localhost\";\n}\n```\n简写：\n```javascript\nconst dbHost = process.env.DB_HOST || \"localhost\";\n```\n\n## 声明变量简写方法\n\n```javascript\nlet x;\nlet y;\nlet z = 3;\n```\n简写方法：\n```javascript\nlet x, y, z = 3;\n```\n\n<!-- more -->\n## `if`存在条件简写方法\n\n```javascript\nif (likeJavaScript === true)\n```\n简写：\n```javascript\nif (likeJavaScript)\n```\n只有`likeJavaScript`是真值时，二者语句才相等。\n如果判断值不是真值，则可以这样：\n```javascript\nlet a;\nif (a !== true) {\n    // do something...\n}\n```\n简写：\n```javascript\nlet a;\nif (!a) {\n    // do something...\n}\n```\n\n## 循环简写方法\n\n```javascript\nfor (let i = 0; i < allImgs.length; i++)\n```\n简写：\n```javascript\nfor (let index in allImgs)\n```\n也可以使用`Array.forEach`：\n```javascript\nfunction logArrayElements(element, index, array) {\n    console.log(\"a[\" + index + \"] = \" + element);\n}\n[2, 5, 9].forEach(logArrayElements);\n// logs:\n// a[0] = 2\n// a[1] = 5\n// a[2] = 9\n```\n\n## 十进制指数\n\n当需要写数字带有很多零时（如10000000），可以采用指数（1e7）来代替这个数字：\n```javascript\nfor (let i = 0; i < 10000; i++) {}\n```\n简写：\n```javascript\nfor (let i = 0; i < 1e7; i++) {}\n// 下面都是返回true\n1e0 === 1;\n1e1 === 10;\n1e2 === 100;\n1e3 === 1000;\n1e4 === 10000;\n1e5 === 100000;\n```\n\n## 对象属性简写\n\n如果属性名与key名相同，则可以采用ES6的方法：\n```javascript\nconst obj = { x: x, y: y };\n```\n简写：\n```javascript\nconst obj = { x, y };\n```\n\n## 箭头函数简写\n\n传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存。\n```javascript\nfunction sayHello(name) {\n    console.log(\"Hello\", name);\n}\nsetTimeout(function() {\n    console.log(\"Loaded\")\n}, 2000);\nlist.forEach(function(item) {\n    console.log(item);\n});\n```\n简写：\n```javascript\nsayHello = name => console.log(\"Hello\", name);\nsetTimeout(() => console.log(\"Loaded\"), 2000);\nlist.forEach(item => console.log(item));\n```\n\n## 隐式返回值简写\n\n经常使用`return`语句来返回函数最终结果，一个单独语句的箭头函数能隐式返回其值（函数必须省略`{}`为了省略`return`关键字） 为返回多行语句（例如对象字面表达式），则需要使用`()`包围函数体。\n```javascript\nfunction calcCircumference(diameter) {\n    return Math.PI * diameter\n}\nvar func = function func() {\n    return { foo: 1 };\n};\n```\n简写：\n```javascript\ncalcCircumference = diameter => (\n    Math.PI * diameter;\n)\nvar func = () => ({ foo: 1 });\n```\n\n## 默认参数值\n\n为了给函数中参数传递默认值，通常使用if语句来编写，但是使用ES6定义默认值，则会很简洁：\n```javascript\nfunction volume(l, w, h) {\n    if (w === undefined)\n        w = 3;\n    if (h === undefined)\n        h = 4;\n    return l * w * h;\n}\n```\n简写：\n```javascript\nvolume = (l, w = 3, h = 4) => (l * w * h);\nvolume(2) //output: 24\n```\n\n## 模板字符串\n\n传统的JavaScript语言，输出模板通常是这样写的。\n```javascript\nconst welcome = \"You have logged in as \" + first + \" \" + last + \".\"\nconst db = \"http://\" + host + \":\" + port + \"/\" + database;\n```\nES6可以使用反引号和`${}`简写：\n```javascript\nconst welcome = `You have logged in as ${first} ${last}`; \nconst db = `http://${host}:${port}/${database}`;\n```\n\n## 解构赋值简写方法\n\n在web框架中，经常需要从组件和API之间来回传递数组或对象字面形式的数据，然后需要解构它\n```javascript\nconst observable = require(\"mobx/observable\");\nconst action = require(\"mobx/action\");\nconst runInAction = require(\"mobx/runInAction\");\nconst store = this.props.store;\nconst form = this.props.form;\nconst loading = this.props.loading;\nconst errors = this.props.errors;\nconst entity = this.props.entity;\n```\n简写：\n```javascript\nimport { observable, action, runInAction } from \"mobx\";\nconst { store, form, loading, errors, entity } = this.props;\n```\n也可以分配变量名：\n```javascript\nconst { store, form, loading, errors, entity:contact } = this.props;\n//最后一个变量名为contact\n```\n\n## 多行字符串简写\n\n需要输出多行字符串，需要使用`+`来拼接：\n```javascript\nconst lorem = \"Lorem ipsum dolor sit amet, consectetur\\n\"\n    + \"adipisicing elit, sed do eiusmod tempor incididunt\\n\"\n    + \"ut labore et dolore magna aliqua. Ut enim ad minim\\n\"\n    + \"veniam, quis nostrud exercitation ullamco laboris\\n\"\n    + \"nisi ut aliquip ex ea commodo consequat. Duis aute\\n\"\n    + \"irure dolor in reprehenderit in voluptate velit esse.\\n\"\n```\n使用反引号，则可以达到简写作用：\n```javascript\nconst lorem = `Lorem ipsum dolor sit amet, consectetur\n    adipisicing elit, sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua. Ut enim ad minim\n    veniam, quis nostrud exercitation ullamco laboris\n    nisi ut aliquip ex ea commodo consequat. Duis aute\n    irure dolor in reprehenderit in voluptate velit esse.`\n```\n\n## 强制参数简写\n\nJavaScript中如果没有向函数参数传递值，则参数为`undefined`。为了增强参数赋值，可以使用`if`语句来抛出异常，或使用强制参数简写方法。\n```javascript\nfunction foo(bar) {\n    if (bar === undefined) {\n        throw new Error(\"Missing parameter!\");\n    }\n    return bar;\n}\n```\n简写：\n```javascript\nmandatory = () => {\n    throw new Error(\"Missing parameter!\");\n}\nfoo = (bar = mandatory()) => {\n    return bar;\n}\n```\n\n## `Array.find`简写\n\n想从数组中查找某个值，则需要循环。在ES6中，`find()`函数能实现同样效果。\n```javascript\nconst pets = [\n    { type: \"Dog\", name: \"Max\" },\n    { type: \"Cat\", name: \"Karl\" },\n    { type: \"Dog\", name: \"Tommy\" },\n]\nfunction findDog(name) {\n    for (let i = 0; i < pets.length; ++i) {\n        if (pets[i].type === \"Dog\" && pets[i].name === name) {\n            return pets[i];\n        }\n    }\n}\n```\n简写：\n```javascript\npet = pets.find(pet => pet.type ===\"Dog\" && pet.name === \"Tommy\");\nconsole.log(pet); // { type: \"Dog\", name: \"Tommy\" }\n```\n\n## `Object[key]`简写\n\n考虑一个验证函数\n```javascript\nfunction validate(values) {\n    if (!values.first)\n        return false;\n    if (!values.last)\n        return false;\n    return true;\n}\nconsole.log(validate({first:\"Bruce\",last:\"Wayne\"})); // true\n```\n\n假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？\n```javascript\n// 对象验证规则\nconst schema = {\n    first: {\n        required: true\n    },\n    last: {\n        required: true\n    }\n}\n// 通用验证函数\nconst validate = (schema, values) => {\n    for (field in schema) {\n        if (schema[field].required) {\n            if (!values[field]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconsole.log(validate(schema, {first:\"Bruce\"})); // false\nconsole.log(validate(schema, {first:\"Bruce\",last:\"Wayne\"})); // true\n```\n现在可以有适用于各种情况的验证函数，不需要为了每个而编写自定义验证函数了\n\n## 双重非位运算简写\n\n有一个有效用例用于双重非运算操作符。可以用来代替`Math.floor()`，其优势在于运行更快，可以阅读[此文章](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)了解更多位运算。\n```javascript\nMath.floor(4.9) === 4  //true\n```\n简写\n```javascript\n~~4.9 === 4  //true\n```\n\n## 扩展运算符简写\n\n扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。\n```javascript\n// joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2 ,4 , 6].concat(odd);\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = arr.slice()\n```\n简写：\n```javascript\n// joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2 ,4 , 6, ...odd];\nconsole.log(nums); // [ 2, 4, 6, 1, 3, 5 ]\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = [...arr];\n```\n不像`concat()`函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。\n```javascript\nconst odd = [1, 3, 5 ];\nconst nums = [2, ...odd, 4 , 6];\n```\n也可以使用扩展运算符解构：\n```javascript\nconst { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };\nconsole.log(a) // 1\nconsole.log(b) // 2\nconsole.log(z) // { c: 3, d: 4 }\n```\n也可以不使用`apply`方法呼叫函数：这里指的是`Function.prototype.apply`，它允许我们将实参以数组形式传入函数并依次对应到形参上。\n```javascript\nfunction doStuff (x, y, z) {}\nvar args = [0, 1, 2];\n// Call the function, passing args\ndoStuff.apply(null, args);\n```\n通过扩展运算符我们可以避免使用`apply`并且轻松地使用它呼叫函数。\n```javascript\ndoStuff(...args);\n```\n代码更少，更干净，而且不需要使用多余的`null`！\n\n很多Emoji字符不是独立的Unicode字符，而是由多个Emoji组合而成。最常见的就是家庭Emoji和有肤色的Emoji，例如👪和👨‍👩‍👧‍👧。\n神奇的事情是，如果使用扩展运算符的话，它们是可以拆散的！\n\n![](/images/2018-01/spread-operator-emoji.jpg)\n\n这些复合emoji字符甚至还允许做替换，形成新的emoji字符。\n\n![](/images/2018-01/emoji-replace.jpg)\n\n不得不说这是一种绝妙的使用方式。\n\n---\n\n本文转载自：[19 个 JavaScript 常用的简写技术](https://juejin.im/post/5948db9661ff4b006c061b2b)\n\n拓展阅读：\n[19+ JavaScript Shorthand Coding Techniques](https://www.sitepoint.com/shorthand-javascript-techniques)\n[[译] 6 种 JavaScript 展开操作符的绝妙使用](http://lightcss.com/6-spread-operator)\n","tags":["JavaScript"],"categories":["Web开发"]},{"title":"MCPE地图的正确使用方式","url":"/2018-01/MCPE地图的正确使用方式/","content":"\n在我的世界中，制作不同区域的地图后，可以使用物品展示框将它们挂起来，这样便能拼出一幅巨大的高分辨率地图。这是博主对一个经营了多年的存档拍摄的『卫星图』：\n\n![](/images/2018-01/IMG_4541.png)\n\n效果还是挺不错的。\n","tags":["我的世界"],"categories":["电子游戏"]},{"title":"为了联盟","url":"/2018-01/为了联盟/","content":"\n![](/images/2018-01/IMG_4186.jpg)\n\n> 为了荣耀！\n","categories":["电子游戏"]},{"title":"将电键变为鼠标和键盘——实现篇","url":"/2018-01/将电键变为鼠标和键盘——实现篇/","content":"\n[上一篇文章](/2018-01/将摩尔斯电键改造为USB键盘/)介绍了使用Teensy 3.2将摩尔斯电键变为键盘的方法。经过研究，博主决定使用Arduino Leonardo实现之。相比Teensy 3.2，Arduino Leonardo成本更低，并且实现起来也较为简单。电键则采用全新产品，无需手动走线、打磨底座等，避免了使用二战时期古董带来的种种问题。\n\n![](/images/2018-01/IMG_4488.jpg)\n\nArduino Leonardo是基于ATmega32U4微控制器的开发板。它有20个输入/输出引脚（在写入程序时可以定义各个引脚的作用，其中最多有7个可用于PWM输出、12个可用于模拟输入），一个16 MHz的晶体振荡器，一个Micro USB接口，一个DC接口，一个ICSP接口，一个复位按钮。它包含了支持微控制器所需的一切，你可以简单地通过把它连接到计算机的USB接口来驱动它。\nLeonardo不同于之前所有的Arduino控制器，他直接使用了ATmega32U4的USB通信功能，取消了USB转UART芯片。这使得Leonardo不仅可以作为一个虚拟的（CDC）串行/COM端口，还可以作为鼠标或者键盘连接到计算机。更多内容可以[参考文档](https://store.arduino.cc/usa/arduino-leonardo-with-headers)（在DOCUMENTATION选单中包含完整电路图）。\n\n<!-- more -->\n## 硬件准备工作\n\n需要准备\n- Arduino Leonardo开发板1一块\n- 摩尔斯电键一个（例如K4型重型电键）\n- 面包板、导线（杜邦头连接线）及USB线\n\n取决于摩尔斯电键的输出方式，可能还需要一个3.5mm/6.5mm音频接口\n有必要的话，还可以准备万用表等辅助工具\n\n## 软件准备工作\n\n- [Arduino IDE](https://www.arduino.cc/en/Main/Software)\n- [准备烧录的程序源代码](/files/MimiMorse.zip)\n- [Bounce2库](https://playground.arduino.cc/Code/Bounce)\n\n理论上Arduino Leonardo在Mac下可以无需驱动，即插即用；如果出现系统无法识别设备（串口）的情况，可以到相关论坛寻求帮助。出现这种情况，常见的可能是FTDI驱动冲突，或者是由macOS系统完整性保护造成的问题。你可以试试重启Arduino Leonardo并等待几秒、外接9V电源或者检查驱动问题。Windows下情况暂未测试。\n\n## 操作步骤\n\n- 打开Arduino IDE，导入下载的Bounce2库。\n\n![](/images/2018-01/ArduinoLeonardo1.png)\n\n- 将Arduino Leonardo开发板通过USB线连接到电脑上，在Arduino IDE的『工具』菜单下设置正确的开发板和端口，如图所示。\n\n![](/images/2018-01/ArduinoLeonardo3.png)\n![](/images/2018-01/ArduinoLeonardo4.png)\n\n- 如果是初次使用，在『文件』菜单下选择示例，找到Blink，打开后，依次点击编译、上传。如果出现未响应、无法找到端口等现象，请点击开发板上的按钮重启。如果上传成功，并且二极管L以0.5Hz的频率闪烁，则说明配置正确。\n\n![](/images/2018-01/ArduinoLeonardo2.png)\n\n- 解压并打开下载的源代码文件。其中Keyboard文件能够将摩尔斯电键变为虚拟键盘，通过敲击字符的摩尔斯电码输入；Mouse文件能够将摩尔斯电键变为虚拟鼠标，按下即触发一次鼠标点击。选择你需要的文件，使用Arduino IDE打开，然后依次点击编译、上传。\n- 请使用物理方法将摩尔斯电键的两端分别连到Arduino Leonardo的GND和12端口，如图所示（当然，你可以更改源代码来使用别的端口）。如果是虚拟键盘模式，连接GND和8端口可以输入大写字母，不连接则输入小写字母。\n\n![](/images/2018-01/IMG_4490.jpg)\n\n- 如果一切就绪，那么，当你按下电键或输入摩尔斯电码，电脑就会作出正确的反应。\n\n![](/images/2018-01/IMG_4491.jpg)\n\n以上就是用摩尔斯电键作鼠标和键盘的教程。当然，Arduino Leonardo开发板的作用远远不止这些，如果发现更为有趣的应用，博主会继续分享出来。\n","tags":["Morse Code","Arduino"],"categories":["技术"]},{"title":"将摩尔斯电键改造为USB键盘","url":"/2018-01/将摩尔斯电键改造为USB键盘/","content":"\n![](/images/2018-01/Vi93ahx.jpg)\n\nThe finished Morse key sitting happily on my laptop. Full project details below.\n最终完成的莫尔斯键盘与笔记本电脑的合影～整个项目的细节如下：\n\nBackground: I can just about remember growing up around beautifully designed analogue devices like rotary dial phones, typewriters, and record players. I've always like the idea of converting these largely defunct objects into digital devices, and my Dad's old Morse key seemed like a simple project to get started on.\n背景：打从记事以来，我就生活在设计精美的模拟设备的环境中，比如旋转式拨号电话，打字机和唱片机。我一直有把这些大部分现在不常用的东西转换成数字设备的想法，而这其中，老爸的旧莫尔斯电键看起来像是一个简单的项目。\n\n<!-- more -->\nMorse code is an internationally recognised way of representing letters of the alphabet (a-z) and numbers (0–9) as a series of dots and dashes. During WW1 and WW2, it became a handy way of sending encrypted messages across long distances and quite possibly sent carrier pigeon unemployment rates skyrocketing. A conventional Morse key acts like a switch, making and breaking a circuit connection to transmit these dots and dashes as short and long beeps over radio waves.\n莫尔斯电码是一种将国际公认的字母表（a-z）和数字（0-9）字母表示为一系列点和破折号的方式。在一战和二战期间，它变成了一个十分方便发送加密的信息的方式。传统的莫尔斯电键就像一个开关，联通和断开电路连接就能通过无线电波传播这些点和点的音长。\n\nThe idea was that the Morse key would behave like a keyboard when plugged into any laptop or PC's USB 3.0 port; the user could key in messages in Morse code, and the corresponding English alphanumeric characters would appear on screen. Code for the project is here ([https://github.com/nomblr/morse/](https://github.com/nomblr/morse)) and full details are below.\n所以我就想到当插入任何笔记本电脑或PC的USB 3.0端口时，莫尔斯键的行为就像一个键盘；用户可以用莫尔斯电码键入信息，并在屏幕上出现相应的英文字母数字字符。这个项目的代码我po到了Github上，有心人都可以去尝试一下。\n\n![](/images/2018-01/wb72Pzy.jpg)\n\nThe Morse key was incredibly dusty and attached to a nasty plastic base, so I took the whole thing apart, scrapped the base, and gave the Morse key a good clean.\n莫尔斯电键积了很多灰尘，而且装在一个很丑的塑料基地上，因此我准备把所有东西都拆开，把莫尔斯电键清洁干净。\n\n![](/images/2018-01/k8vNI65.jpg)\n\nSome wet wipes did the job nicely, and I also sanded down the two metal contacts (the 'switch') a tiny bit to improve the electrical connection and remove some of the accumulated gunk.\n使用湿纸巾，这项工作完成的很出色。并且我还仔细打磨了两个金属触点（即『开关』），改善电路连接的情况并去除一些沉积的脏东西。\n\n![](/images/2018-01/4kpenAM.jpg)\n\nConverting the (VERY analogue) Morse key into a digital device was the next step. To do this I used a tiny, cheap micro-controller aptly named a Teensy 3.2 ([https://www.pjrc.com/teensy/](https://www.pjrc.com/teensy)). The Teensy has 28 pins, each of which can be configured as an input or an output; because I wanted to the Teensy to receive signals from the Morse key, I configured Pin 7 of the Teensy as an input and wired it to one connection on Morse key. (This was an arbitrary choice, any of the I/O pins would have worked just fine.) I then wired the ground pin of the Teensy to the other connection on the Morse key.\n接下来就是将电键转换为数字设备。为了实现这一点，我使用一个小巧，便宜的微型控制器——Teensy 3.2。\n\nThis was my first foray into working with electronics or microcomputers so feel free to imagine a progress montage punctuated by thoughtful moustache stroking scenes, eighties music and gratuitous but entirely pointless shots of the terminal.\n这是我第一次尝试做这种事，你可以想象当我点亮并且成功运行的时候，我的内心是多么喜悦。\n\nI wrote some test code for the Teensy to make sure it was working with the Morse key as expected; I expected to see 'KEY PRESS' printed out once every time I pressed the Morse key down once. This is where I hit my first problem. Mechanical switches don't make perfect physical or electrical contact when they're pressed; they'll typically oscillate between being 'open' and 'closed' a few times over ～1ms before settling down to a stable 'closed' state. Microcomputers are fast enough to detect these oscillations so when I pressed my Morse key down just once, the Teensy detected several rapid key presses as shown in the photo. This effect is called 'bounce' and luckily there's a built-in Teensy library ([https://playground.arduino.cc/Code/Bounce](https://playground.arduino.cc/Code/Bounce)) that compensates for it.\n为了确保Teensy正确按照预期『翻译』莫尔斯密码，我为Teensy写了一些测试代码。因此每当按下莫尔斯电键一次，我就会看到电脑端有字符输出。然而很快我就遇到了一个问题：机械开关按下时不能形成完美的物理接触（通常在『通路』和『断路』之间摆动几次，持续约1ms，然后稳定到『通路』状态）。计算机能够快速检测到这些振荡，所以当我按下我的莫尔斯电键时，Teensy检测到照片中显示的几个快速按键。这种效应称为『反弹』，幸好内置的Teensy库能够补偿它。\n\nOnce the Teensy could successfully detect single Morse key presses, I needed a way to differentiate the pauses between dots, dashes, letters, and words. Implementing a method for the Teensy to figure out relative timings for individual users would've involved a fair amount of faff, so I used absolute timings based on my own keying speeds. A threshold of 150ms was used to differentiate dots from dashes, and pauses between letters and words were set to 500ms and 3000ms. Of course, this configuration will break down with a faster or slower Morse operator, but as my old engineering tutor used to say, \"good engineers are smart but lazy\", which for the purposes of this project I will choose to interpret as \"good engineers are lazy\".\n为了Teensy能够成功检测到每次点击莫尔斯电键的不同，来区分点、破折号、字母和单词之间的停顿。我在绝对时间的基础上结合自己的键控速度。用150ms的阈值来区分短划线，并且字母和单词之间的时间间隔被设置为500ms和3000ms。当然，每个人的习惯都不一样，这个就要自己把握了。\n\n![](/images/2018-01/hncjuCW.jpg)\n\nWith the Teensy fully programmed, I was ready to build a wooden base to hide the electronics underneath the Morse key, with holes to feed through the two wires connecting the Morse key to the Teensy. I'd like to say I chose wood for aesthetic reasons, but in reality all my attempts at 3D printing a base failed so abysmally that I decided to try my luck with a plank I found lying around at my local Hackspace, of approximate width 130mm and depth 20mm.\nTeensy编程完后，我准备制作一个隐藏莫尔斯电键下方的电子设备的木质底座，并且底座上有两个孔，用于连接Teensy到莫尔斯电键的电线。为啥选木材而不是3D打印呢？其实不是美观不美观的问题，而是因为用3D打印出来的底座都适配失败了。\n\n![](/images/2018-01/WjlHEcO.jpg)\n\nI sawed the plank down to 110x90mm so the Morse key would fit nicely on top, and chiselled out an indentation of approximate dimensions 50x40x10mm on the underside, so fit the Teensy and wiring.\n我把木板锯成110x90mm，这样莫尔斯电键可以很恰当地放在上面。在下方我凿出了一个尺寸约为50x40x10mm的凹痕，用于放置微控制器Teensy和布线。\n\n![](/images/2018-01/ocVQDyq.jpg)\n\nI sanded the whole thing down and connected it to my laptop. You can see it in action here: [https://www.youtube.com/watch?v=qh_apYcr4xI](https://www.youtube.com/watch?v=qh_apYcr4xI)\n最后我打磨了一下新的键盘，并将其连接到我的笔记本电脑上。\n\n---\n\n本文翻译自：[I Turned my Dad's 1950s Morse Key into a USB Keyboard](https://imgur.com/gallery/lNAtQ)\n","tags":["Morse Code"],"categories":["技术"]},{"title":"2017——生命中的一年","url":"/2017-12/2017——生命中的一年/","content":"\n> 标题来自纪录片《J.K.罗琳——生命中的一年》。\n\n不知不觉就到了2017年的最后一天。由于没有写日记的习惯，总感觉还是需要做些什么，以免一些事情太快被遗忘。于是决定写篇文章，记录一下这一年里的经历（实际上只是些流水账）。\n\n<!-- more -->\n在2016年11月的CPhO，我幸运地进入了国家集训队，这意味着2017年我不再有来自高考的压力；有大量闲暇时时间，去探索未知、追寻自我。\n2016年12月24日，结束了在北大的集训，回到武汉。2017年上半年的生活节奏，大概从这时就奠定了。\n2017年1月6日，公布了IPhO与CPhO国家队的名单，我并没有入选。这是意料之中的，毕竟量子考试做错了一道大题。虽然还有再战一年的机会，但已经对物理竞赛感到疲倦的我无心恋战；也许是时候做些更有意义的事情。\n2月18日，我开始进行物理竞赛及自主招生的辅导工作，对象主要是高中的学弟学妹。这是一个不错的工作，也有助于提高自己的水平。\n3月很平常，偶尔是帮竞赛老师讲课、改卷子。\n4月收到了到培尖教育做助教的邀请。4月25日，抵达杭州，开始了为期两周的助教生涯。在此期间，得知了APhO八位同学全部夺金的消息。\n5月初，培尖的课程结束后，到宋城、西湖游玩了一天，于5月11日返回武汉。比较遗憾的是，在杭州时错过了高中拍摄毕业照。\n\n![](/images/2017-12/IMG_3493.jpg)\n\n> 过去两年，由于忙于学习物理竞赛的知识，假期往往是在培训机构和大学的实验室里度过的，抑或是宅在家里刷题。这次才算是一场真正的旅行。\n\n5月19日，与高中同学一起游览了九真山。这是高考之前全班进行的最后一次大型集体活动。\n\n![](/images/2017-12/IMG_3548.jpg)\n\n> 『从此天各一方』\n\n6月5日，在B站上投稿了炉石传说游戏视频，并取得了不错的播放量。希望未来能坚持下来，定期更新一些游戏测试等内容。\n7月开始，继续在物理竞赛上指导了几位学弟学妹。我对自己的教学水平还是很有信心的。\n在暑假期间，试图养成每天健身、学英语的习惯，从结果上来看失败了。\n8月21日，在国子学做了一天助教，这段时间要准备去北大旁听的事宜了。\n8月28日，北大分班，大学生活即将开始。这也意味着，要准备去迎接新的挑战了。\n9月8日，生日，也是北京大学开学典礼的日子。\n9月15日，围观隔壁军训，与高中同学谈笑风生。顺便到隔壁食堂蹭了顿饭。生活还是轻松愉快而惬意的。\n9月17日，复赛与北大力免考试同在这一天。我选择了免修力学。\n10月1日，在国庆放假回家的火车上搭建了个人博客，同时开始自学HTML、CSS和JavaScript。虽然多年前就已经有此计划，但是当时比较naive，从未接触Web开发，对程序设计也一窍不通，故未能实施。\n10月18日，设计并制作了两面旗帜，挂在寝室增加气氛。于是又入了Illustrator这个大坑。\n11月18日，和同学去围观了新生杯篮球赛决赛，见证了物院篮球队夺冠。\n11月27日，基本完成了JavaScript游戏Play Coins!的制作。同时，为了找学长抄代码，重拾了多年前注册但一直没有动静的GitHub账号。\n12月3日，听了潘建伟院士的报告。这坚定了我成为一名科研工作者的决心。\n\n![](/images/2017-12/IMG_4361.jpg)\n\n> 『格物路修远，一生物理人』\n\n12月11日，重回华师一参加2018高考报名，见到了初中时的挚友，感慨万千。\n12月16日，参与制作了《情系华一》北大部分的宣传片，负责后期特效，并且制作了一个漫威风的片头。\n12月19日，因为队友全部划水，一人完成了计算概论课大作业一个小组的全部内容。这是我做的第一个较为完整的C语言项目。\n\n如果简要地回顾2017年，它似乎并不如2016年那样令人激动、充满精彩与高光的时刻。这一年的经历，更加平凡，更为低调。这一年，我学到了很多，见识了很多，感悟了很多。相比高中时，我更深切地体会到，人外有人，天外有天：在北大，身边的每一个人都是奆佬，每天我都在经历着神仙打架。我似乎始终是一个追逐者，尝试着跟上他们的步伐，就如我高中时所做的那样。\n2018年，继续前行吧。\n","categories":["其他"]},{"title":"下载70年代美帝拍摄的卫星图","url":"/2017-12/下载70年代美帝拍摄的卫星图/","content":"\n![](/images/2017-12/kh1.jpg)\n\n这是1972年5月29日美国间谍卫星拍摄的北京大学。这张照片来自美国地质调查局（USGS）图片数据库。美国于90年代以及21世纪初分几批解密了冷战时期美国间谍卫星拍摄的照片。作为冷战时期的敌国，间谍卫星记录下了当时几乎中国全境的高清卫星照片，这里分享一下照片下载的具体方法。\n\n<!-- more -->\n首先登录美国地质调查局（USGS）EarthExplorer网站：[Earth Explorer](https://earthexplorer.usgs.gov)\n由于该网站调用了Google提供的验证码和地图服务，可能需要翻墙才能正确使用。\n下载图片必须要登录，先点击右上角的Register注册。推荐使用Gmail邮箱注册，如果用QQ邮箱等国内邮箱注册可能会收不到验证邮件。完成注册、登录后，就可以搜索并下载图片了。\n首先，我们在右侧的地图上通过点选，划定需要搜索的区域，或者通过输入经纬度坐标确定位置。\n接下来我们就可以点击Data Sets来进行下一步，选择数据库。\n\n![](/images/2017-12/kh2.jpg)\n\n被解密的冷战时期照片主要集中在Declassified Data数据库中，我们展开它，勾选Declass 1 (1996)，这一组数据库主要是长条状推扫式卫星照片，拍摄年代集中在60年代末期。Declass 2 (2002)则大多是框幅式的照片，拍摄年代集中在70年代初。Declass 3 (2013)则照片较少。\n\n![](/images/2017-12/kh3.png)\n\n我们以Declass 1 (1996)为例。点击Additional Criteria进入下一步，然后来选择一些参数进行进一步筛选。因为不是所有的照片都提供免费下载，而且分辨率较低的照片没有必要去看，因此我们通过设置把需要付费和低分辨率的照片剔除掉。如图，我们将Camera Resolution限定为Stereo High，将Download Available限定为Yes，这样我们就可以直接筛选出高清、可下载的照片了。点击Results来获得结果。\n\n![](/images/2017-12/kh4.png)\n\n如下图所示，在左侧列表中我们看到了筛选结果，列表中会显示每一个照片的拍摄时间等信息。\n\n![](/images/2017-12/kh5.png)\n\n每一个搜索结果上都有一个工具栏。其中，点击脚印图标可以获取该照片在地球上的位置（照片覆盖范围）。比如下图中，我点选了两张图片的脚印图标，就可以预览显示他们分别覆盖了地球上的哪块区域。\n\n![](/images/2017-12/kh6.jpg)\n\n这样的好处是，如果发现你需要搜索的区域和该照片仅仅是有一丁点儿交集，那么就可以优先下载其他的照片了，因为在区域的边界处，照片总是不那么清晰，尤其是需要查看的区域出现在照片两端时，镜头畸变会造成图片极为不清晰。\n另外值得一提的是，照片覆盖区域只是一个参考，并不能精确地和右侧的谷歌地图重合。为了避免这种情况，你可以点击第四个图标。页面上会弹出窗口显示图片的Meta Data，并且提供了一张低分辨率的缩略图。根据缩略图，你可以大致识别一些地理特征，并确定这张图片是不是你需要的，避免下载下来的照片和想象的有误差。\n\n点击每一个项目第五个带绿色箭头的图标就可以下载了。每个照片包从几百M到几个G不等，十分庞大。有时候需要等待很长时间才能开始下载。\n下载照片包以后进行解压。因为每张照片太大，大多数都被切分成了3至4张照片，每个文件依然有几百M。需要注意的是，有的照片是南北相反的，需要通过手动进行翻转。\n\n在我首次打开这些资料时，我比较好奇在没有发现巨磁阻效应的年代，美帝如何保存和传输的这些资料，毕竟磁带啥的并不现实。结果事实证明我还是too young，美帝的间谍卫星直接拍照保存到胶片上，然后将胶片仓抛回地球，而这些数码图片都是后来重新扫描的。依靠胶片而非无线电传输数据的间谍卫星工作寿命都非常有限，例如初代的锁眼侦查卫星。\n\n---\n\n参考文章：[如何下载 50 年前自己家乡的高清卫星照片 - 知乎](https://zhuanlan.zhihu.com/p/30953275)\n\n拓展阅读：[Key Hole - 维基百科](https://en.wikipedia.org/wiki/Key_Hole)\n","categories":["技术"]},{"title":"JavaScript运算符","url":"/2017-12/JavaScript运算符/","content":"\n按优先级排列：\n\n运算符 | 描述\n- | -\n. \\[\\] \\(\\) | 字段访问、数组下标、函数调用以及表达式分组\n++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值\n* / % | 乘法、除法、取模\n+ - + | 加法、减法、字符串连接\n<< >> >>> | 移位\n< <= > >= instanceof | 小于、小于等于、大于、大于等于、instanceof\n== != === !== | 等于、不等于、严格相等、非严格相等\n& | 按位与\n^ | 按位异或\n&#124; | 按位或\n&& | 逻辑与\n&#124;&#124; | 逻辑或\n?: | 条件\n= oP= | 赋值、运算赋值\n, | 多重求值\n","tags":["JavaScript"],"categories":["Web开发"]},{"title":"近期完成的数个游戏及应用","url":"/2017-12/近期完成的数个游戏及应用/","content":"\n最近这段时间，博主沉迷编程，除了课内的作业需要肝DDL之外，也做了一些娱乐项目。下面一一道来。\n\n## 生命游戏\n\n康威生命游戏（Conway's Game of Life）是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。它最初于1970年10月在《科学美国人》杂志上马丁·葛登能的『数学游戏』专栏出现。\n\n### 概述\n\n生命游戏是一个零玩家游戏。它包括一个二维矩形世界，这个世界中的每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的或死了的细胞的数量。如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；相反，如果周围活细胞过少，这个细胞会因太孤单而死去。实际中，玩家可以设定周围活细胞的数目怎样时才适宜该细胞的生存。如果这个数目设定过高，世界中的大部分细胞会因为找不到太多的活的邻居而死去，直到整个世界都没有生命；如果这个数目设定过低，世界中又会被生命充满而没有什么变化。\n实际中，这个数目一般选取2或者3；这样整个生命世界才不至于太过荒凉或拥挤，而是一种动态的平衡。这样的话，游戏的规则就是：当一个方格周围有2或3个活细胞时，方格中的活细胞在下一个时刻继续存活；即使这个时刻方格中没有活细胞，在下一个时刻也会『诞生』活细胞。\n\n### 规则\n\n根据前面的描述，在生命游戏中，对于任意细胞，一种典型的规则如下：\n- 每个细胞有两种状态——存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动。\n- 当前细胞为存活状态时，当周围低于2个存活细胞时，该细胞变成死亡状态。（模拟生命数量稀少）\n- 当前细胞为存活状态时，当周围有2个或3个存活细胞时，该细胞保持原样。\n- 当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）\n- 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。（模拟繁殖）\n\n### 实现\n\n可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。\n在这个游戏中，还可以设定一些更加复杂的规则，例如当前方格的状况不仅由父一代决定，而且还考虑祖父一代的情况。玩家还可以作为这个世界的『上帝』，随意设定某个方格细胞的死活，以观察对世界的影响。\n在游戏的进行中，杂乱无序的细胞会逐渐演化出各种精致、有形的结构；这些结构往往有很好的对称性，而且每一代都在变化形状。一些形状已经锁定，不会逐代变化。有时，一些已经成形的结构会因为一些无序细胞的『入侵』而被破坏。但是形状和秩序经常能从杂乱中产生出来。\n这个游戏被许多计算机程序实现了。Unix世界中的许多黑客喜欢玩这个游戏，他们用字符代表一个细胞，在一个计算机屏幕上进行演化。比较著名的例子是，GNU Emacs编辑器中就包括这样一个小游戏。\n查看更多信息：[ConwayLife.com](http://www.conwaylife.com)\n多平台元胞自动机模拟软件Golly，下载地址：[Golly - sourceforge](https://sourceforge.net/projects/golly)\n访问地址：[ZSQ.IM > 应用 > 小游戏 > Life](https://zsq.im/game/life.html)\n\n<!-- more -->\n## Bad Apple!!\n\n这是一个二次开发的项目，能够在HTML页面中播放Bad Apple!!字符画。实现方式比较naive，通过Ajax请求不断地获取新画面，然后播放出来，并与音轨保持同步。可以改进的地方有很多，比如请求的文件含有大量相同符号，可以进行压缩来增加缓冲效率。\n访问地址：[ZSQ.IM > 应用 > 魔改项目 > BadApple](https://zsq.im/game/badapple)\n\n## Play Coins!\n\n这个弹硬币的游戏来自于高中时在教室里进行的娱乐活动。本项目于2017年11月23日晚开始构思，11月24日完成了框架，包括物理引擎的相关计算，11月25日完成了跨平台适配，11月26日加入了背景音乐，修复了大量bug，11月27日加入了欢呼音效和音频的跨浏览器适配。现在，它已经可以流畅地在全平台运行了。\n访问地址：[ZSQ.IM > 应用 > 原创游戏 > Coin](https://zsq.im/game/coin/)\n\n## 任意位整数计算器\n\n这个项目被命名为MHC - MHC Hyper Calculator，是一个用C语言编写的计算器，作为本学期计算概论课程大作业的成果。该计算器支持任意大数字的加减乘除求余乘方阶乘运算，拓展功能则是RSA加密和中文输出。\n虽然在这个项目上耗费了不少时间，算是摸清楚了RSA算法的门道，但由于只是完成作业，就不把项目源代码贴出来献丑了。这种重复造轮子的工作，还是应该以提升自己的水平为主要目的。\n\n---\n\n拓展阅读：\n[【果壳网专访】斯蒂芬·沃尔夫勒姆：宇宙的本质是计算](https://www.guokr.com/article/439770)\n[RSA算法之实现篇](https://blog.csdn.net/qmickecs/article/details/39676655)\n","tags":["JavaScript"],"categories":["程序设计"]},{"title":"游戏圈的鄙视链","url":"/2017-12/游戏圈的鄙视链/","content":"\n![](/images/2017-12/IMG_4370.jpg)\n","categories":["电子游戏"]},{"title":"潘建伟院士莅临我校讲座","url":"/2017-12/潘建伟院士莅临我校讲座/","content":"\n![](/images/2017-12/IMG_4364.jpg)\n\n2017年12月3日晚，潘建伟院士莅临我校，向数百位学校师生以及大量民间科学爱好者作了关于量子通信的报告。在听众提问环节，众多民间科学爱好者抛出了诸如『由量子计算机和人工智能能否计算暗物质』『我去年9月就听了您的报告，还送了您一本（我写的民科）书，您评价如何』『听到您的讲座，我很欣慰，您能否详细介绍……』这样的问题，讲堂里充满了快活的空气。潘院士始终面带微笑，与民间科学爱好者们谈笑风生，并耐心地解答他们提出的问题。看来，中国基础教育还有很长的路要走。\n","categories":["物理"]},{"title":"炉石传说真尼玛好玩","url":"/2017-11/炉石传说真尼玛好玩/","content":"\n![](/images/2017-11/AstralDruid.jpg)\n\n> 炉石传说真尼玛好玩！\n","tags":["炉石传说"],"categories":["电子游戏"]},{"title":"开源软件授权协议详解","url":"/2017-11/开源软件授权协议详解/","content":"\n开源在今天的软件业已经很普遍，但开源是否意味着使用者可以对开源后的代码为所欲为呢?\n答案当然是否定的。开源运动同样有自己的游戏规则和道德准则。不遵行这些规则不但损害开源运动的健康发展，也会对违规者造成名誉和市场上的损失，更可能陷入法律纠纷和赔偿。现今存在的开源协议很多，而经过[Open Source Initiative](https://www.opensource.org/licenses/alphabetical)组织通过批准的开源协议目前有58种。我们在常见的开源协议如BSD，GPL，LGPL，MIT等都是OSI批准的协议。如果要开源自己的代码，最好也是选择这些被批准的开源协议。首先借用一张相当直观清晰的图来划分各种协议：\n\n![](/images/2017-11/free_software_licenses.png)\n\n<!-- more -->\n以下是上述协议的简单介绍：\n\n## 强开源约束授权\n\n[GPL（GNU General Public License）](https://www.gnu.org/licenses/gpl-3.0.en.html)\n我们很熟悉的Linux就是采用了GPL。GPL协议和BSD，Apache Licence等鼓励代码重用的许可很不一样。\nGPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码作为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。\nGPL协议的主要内容是只要在一个软件中使用(『使用』指类库引用，修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的『传染性』。\nGPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。\n\n## 弱开源约束授权\n\n[MPL License（Mozilla Public License）](https://www.mozilla.org/MPL/MPL-1.1.html)\nMPL是The Mozilla Public License的简写，是1998年初Netscape的Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处：\n- MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL许可证中对『发布』的定义是『以源代码方式发布的文件』，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。\n- MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。\n- 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他博主是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。\n- 对源代码的定义。在MPL（1.1版本）许可证中，对源代码的定义是：『源代码指的是对作品进行修改最优先择取的形式，它包括:\n所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的原本（原文为Script），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。』\n- MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。\n\nMPL允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码得版权都集中在发起开发人得手中。但MPL是允许修改，无偿使用的。\nMPL软件对链接没有要求。(要求假如你修改了一个基于MPL协议的源代码，则必须列入或公开你所做的修改，假如其他源代码不是基于MPL则不需要公开其源代码)\n\n[LGPL（GNU Lesser General Public License）](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html)\nLGPL是GPL的一个为主要为类库使用设计的开源协议。\n和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。\n因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。\nGPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。\n\n[MIT（MIT）](https://mit-license.org)\nMIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他了限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。\n\n## 无开源约束授权\n\n[BSD开源协议](http://www.bsdcertification.org)\nBSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以『为所欲为』，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但『为所欲为』的前提当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：\n- 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。\n- 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。\n- 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。\n\nBSD代码鼓励代码共享，但需要尊重代码作者的著作权。\nBSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。\n而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。\n\n[Apache Licence](https://www.apache.org/licenses/LICENSE-2.0.html)\nApache Licence是著名的非盈利开源组织Apache采用的协议。\n该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：\n- 需要给代码的用户一份Apache Licence\n- 如果你修改了代码，需要再被修改的文件中说明。\n- 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。\n- 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。\n\nApache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。\n\n## 其他开源约束授权\n\n[Creative Commons（CC）](https://creativecommons.org)\n您在自己的作品上使用知识共享许可协议，并不意味着放弃您的著作权，而是在特定的条件下将您的部分权利授予公共领域内的使用者。\n哪些特定的条件呢？您可以在此处看到所有知识共享许可协议及其简单的介绍。\n所有的许可协议都要求您以作者或者许可人的名义署名。您可以将以下的选项进行组合、搭配，由此将构成我们的六套核心知识共享许可协议。\n- 是否允许他人对自己享有著作权的作品及演绎作品进行复制、发行、展览、表演、放映、广播或通过信息网络向公众传播，但在这些过程中对方必须保留您对原作品的署名。\n- 是否允许他人对您享有著作权的作品及演绎作品进行复制、发行、展览、表演、放映、广播或通过信息网络向公众传播，但仅限于非商业性目的。\n- 是否允许他人对您的作品原封不动地进行复制、发行、展览、表演、放映、广播或通过信息网络向公众传播，但不得进行演绎创作。\n- 只有在他人对演绎作品使用与您的原作品相同的许可协议的情况下，您才允许他人发行其演绎作品。\n\n---\n\n文章来源：《开源时代》2010.02第十七期\n\n相关文章：\n[开源软件授权协议详解（GPL/MPL/LGPL/BSD/Apache Licence/Creative Commons/MIT）](http://wenbois2000.iteye.com/blog/905850)\n[开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别](http://www.geek-workshop.com/thread-1860-1-1.html)\n\n图片来源：[如何选择开源许可证？](https://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html)\n\n拓展阅读：\n[由psp破解谈到中国伸手党式网民的心理](http://news.duowan.com/YD/ctm32)\n[專有軟體常是惡意軟體](https://www.gnu.org/proprietary/proprietary.html)  \n[自由软件现在更加重要](https://www.gnu.org/philosophy/free-software-even-more-important.html)\n","categories":["程序设计"]},{"title":"细思恐极","url":"/2017-11/细思恐极/","content":"\n![](/images/2017-11/IMG_4263.jpg)\n![](/images/2017-11/6592b5f47ee61115f25057554223beb3.jpg)\n","categories":["其他"]},{"title":"WordPress 3.x版本中的彩蛋","url":"/2017-11/WordPress 3.x版本中的彩蛋/","content":"\n今天博主在进行WordPress博客考古活动时，得知了一个彩蛋。来源见：[WordPress的彩蛋](http://www.kaisir.com/2010/02/the-egg-wordpress.html)。\n在WordPress文章中使用Compare Revisions功能，如果两个相比较的文章ID一致，就会触发彩蛋。其效果是显示文字：\n> Wake up XXX… The matrix has you. Follow the white rabbit. Don’t let this happen again.\n\n这是一个致敬《黑客帝国》的彩蛋。经过对[WordPress历史版本](https://cn.wordpress.org/releases)的分析，发现该彩蛋已在4.x版本移除。通过分析3.0.2版本的文件，找到了该版本的`revision.php`和`revision-js.php`文件，并大致研究出了其实现方法。在`revision.php`中有这样一串代码：\n```php\n// If we're comparing a revision to itself, redirect to the 'view' page for that revision or the edit page for that post\nif ( $left_revision->ID == $right_revision->ID ) {\n    $redirect = get_edit_post_link( $left_revision->ID );\n    include( './js/revisions-js.php' );\n    break;\n}\n```\n而在`revision-js.php`中，有一串经过了`eval`混淆的代码，用于向用户输出彩蛋内容。 目前博主正在尝试反混淆代码，并复现这个彩蛋。如果你有兴趣，也可以下载`revision-js.php`进行研究。\n\n本文更新于2017年11月11日：\n由于博主并不准备搭建旧版本WordPress的运行环境，于是决定从代码入手，分析这个彩蛋。\n在`revisions-js.php`中定义的函数`dvortr()`作用是使用一对一的替换来加密字符串，该文件中有两次调用此函数：\n```php\ndvortr( \"Erb-y n.y ydco dall.b aiacbv Wa ce]-irxajt- dp.u]-$-VIr XajtWzaVv\" )\n```\n和\n```php\ndvortr( 'Eabi.p!' )\n```\n经过解密，其输出分别为\n```xml\nDon't let this happen again. <a id='goback' href='$'>Go Back</a>\n```\n和`Danger!`。\n而定义的变量`$j`作用是包含jQuery库，`$n`是获取的当前用户名，`$d`是noscript时的输出。通过替换掉一些WordPress中定义的函数，博主成功地使部分解码后的PHP文件在本地Apache服务器成功运行。并且，博主还重新制作了这个彩蛋，现在它已经可以在[ZSQ.IM](https://zsq.im)以某种方式触发～\n下面附上整个解密过程中所用到的文件。其中`revision.php`和`revisions-js.php`是原文件，`decode.php`是部分解密后的文件，`decode.js`是浏览器获取的匿名js文件，`decoder.html`是根据原文件的加密算法编写的加密、解密脚本。\n[WordPressEasterEgg](/files/WordPressEasterEgg.zip)\n","tags":["WordPress"],"categories":["程序设计"]},{"title":"在WordPress博客中使用LaTeX","url":"/2017-11/在WordPress博客中使用LaTeX/","content":"\n上帝说，要有\n\\begin{eqnarray\\*}\n\\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n\\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n\\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n\\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n\\end{eqnarray\\*}\n于是就有了光。\n**注：以上文字旨在测试$\\LaTeX$兼容情况。**\n使用方法：在HTML页面中，通过\n```xml\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n<!--config后的参数可以根据需求自定义，默认为?config=default-->\n```\n即可加载MathJax，该脚本将会把所有$\\LaTeX$公式正确显示出来。尽情的按照$\\LaTeX$语法插入公式就好啦！\n如果要在WordPress中使用，可以通过在编辑文章界面，选择『文本』（如果使用『可视化』，字符将被转义，导致脚本无法加载），输入以上内容达到相同效果。\n\n使用时还需要注意的是，根据官方文档，标记行内公式的`$`符号默认不会被识别。你可以在HTML页面中加入以下配置以启用之：\n```xml\n<script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config({\n    tex2jax: {\n        inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"]  ],\n        processEscapes: true,\n        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n    },\n    TeX: {equationNumbers: { autoNumber: \"AMS\" }},\n    \"HTML-CSS\": { linebreaks: { automatic: true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },\n    SVG: { linebreaks: { automatic: true }}\n});\n</script>\n```\n其中`inlineMath`项启用了`$`符号标记的行内公式，而`linebreaks`项则会在屏幕宽度较小时自动使公式换行。\n\n更多信息可以访问官方网站：[MathJax](https://www.mathjax.org)\n\n---\n\n本文更新于2018年5月20日：\n在Hexo中，如果使用了NexT主题，可以通过配置主题目录下的`_config.yml`简单地使用MathJax。在`_config.yml`中找到`mathjax`选项，将其子选项设置为`enable: true`，并在需要加载MathJax的文章的Front-matter中添加`mathjax: true`即可。\n\n本文更新于2018年10月3日：\n还有一种解决方案是调用知乎的API：`https://www.zhihu.com/equation?tex=`，通过GET请求，就可以将你的$\\LaTeX$表达式转换为公式的图片。\n","tags":["LaTeX","WordPress"],"categories":["物理"]},{"title":"在Mac上通过Sublime和Skim编辑LaTeX","url":"/2017-11/在Mac上通过Sublime和Skim编辑LaTeX/","content":"\nSublime Text是一款非常优秀的编辑器：速度快，界面简洁，插件众多；并且能够跨平台使用，在Mac和Windows上都发挥完美。虽然是一款付费软件，但作者很厚道地给了无限期的试用期限。这一切正如其官网广告词说的那样：The text editor you'll fall in love with.\nSkim是一款免费轻量的PDF阅读、标注工具，布局贴心友好，与OS X自带的Previewer相比，Skim能更好的注释PDF文件。\n$\\LaTeX$是一款权威的科技论文排版系统，不仅可以写论文，也可以处理日常的各种文档工作，甚至是做幻灯片。相比于Microsoft Word，$\\LaTeX$最大的优势是对于复杂公式的编辑与排版非常漂亮，并且用简单的命令就可以生成脚注、索引、目录和参考文献等复杂的结构。这一切优点都使得世界上众多的科学家们不再需要身兼作者与排版工两职，从而将更多的精力集中于文章内容本身。\n本文的目的是将上述三种软件综合部署在Mac上。完成之后，你将可以在Sublime Text里面进行$\\LaTeX$代码编辑，用Skim预览生成的PDF文件。更重要的是，让你觉得，写论文也可以是一件很优美的事。\n\n<!-- more -->\n## 准备工作\n\n- Mac上至少4GiB的空余空间\n- 高速的互联网连接\n\n## 安装MacTeX\n\n- 进入[MacTeX官网](https://www.tug.org/mactex)下载`MacTeX.pkg`文件。文件大约3GB，需要一段时间才能完成下载，趁现在去喝杯咖啡吧。\n- 下载完成之后，双击`MacTeX.pkg`进行安装。\n- 安装完成之后，会看到许多与TeX有关的程序图标，暂时忽略它们。\n\n## 安装Sublime Text\n\n- 进入[Sublime Text官网](https://www.sublimetext.com)下载最新版本的Sublime Text 3。\n- 下载完成之后，将文件拖入应用程序文件夹安装。\n\n## 在Sublime Text中安装Package Control\n\n我们需要在Sublime Text中下载插件以便能够很好地操作与$\\LaTeX$有关的文件。而插件是通过Package Control下载的。\n\n- 进入[Package Control官网](https://packagecontrol.io/installation)，复制灰色区块的代码（或者直接复制下面的代码）。\n对于Sublime Text 3：\n```python\nimport urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n对于Sublime Text 2：\n```python\nimport urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation')\n```\n- 打开Sublime Text。\n- 使用快捷键<kbd>Ctrl</kbd>+<kbd>~</kbd>打开控制台（Console）。你会在Sublime Text的底部看到弹出一个白色窗口。\n- 将刚才复制的代码粘贴到控制面板。\n- 按下<kbd>Enter</kbd>回车键，等待安装。\n- 安装完成后，退出并重启Sublime Text。\n\n## 安装LaTeXBox\n\n- Sublime Text重启后，按下`Command+Shift+P`打开命令托盘（Command pallet），这一步也可以通过点击Tools下拉菜单完成。\n- 在命令托盘里输入`Install Package`，按下<kbd>Enter</kbd>回车建。\n- 完成之后，输入`LaTeXBox`，找到这一项并回车安装。\n- 退出并重启Sublime Text。\n\n## 安装Skim\n\n- 进入[Skim官网](https://skim-app.sourceforge.io)下载Skim并安装。\n- 打开Skim，在菜单栏中点击`Skim > Preference(选项) > Sync(同步)`。\n- 在预设菜单中选择`Sublime Text`。\n- 关闭上面这个窗口。\n\n## 修改编译和中文环境\n\n现在，我们已经做完了所有的步骤✌️，可以打开Sublime Text，`Command+N`新建文件并在里面编写$\\LaTeX$代码了，完成编辑之后，`Command+S`保存文件，`Command+B`编译并运行，这时就可以在Skim里面看到PDF预览了。\n如果你使用了ctex，使用默认的编译配置可能会出现中文不正常的问题，这时需要进行手动设置（将默认的引擎设置为`xelatex`）。如图所示打开：\n![](/images/2017-11/tex.png)\n然后输入以下内容：\n```json\n{\n\t\"bring_forward_on_success\": true,\n\t\"cmd\": [\n\t\t\"latexmk\", \"-quiet\", \"-pdf\", \"-e\",\n\t\t\"$pdflatex='xelatex -synctex=1 --shell-escape %O %S'\"\n\t],\n}\n```\n如果使用LaTeXBox编译出现了其它问题，可以尝试在命令行中直接进行编译：在第一步完成后，打开终端，进入到tex所在到文件夹，使用`xelatex *.tex`，编译tex文件为pdf。如果成功，你可以将它添加到Sublime Text的Build System中，或者通过设置LaTeXBox的编译引擎，也可以实现一键编译。除此之外，还可以使用Pandoc等命令行工具将tex转为其他格式的文档。\n在Windows上可以通过安装TexLive的方法配置TeX环境，过程是类似的。需要注意的是，tex文件应采用UTF-8编码。\n\n---\n\n参考文章：[在Mac OS X下搭建Latex编辑环境](https://blog.csdn.net/songrotek/article/details/46457571)\n\n本文更新于2019年5月：\n使用VSCode和$\\LaTeX$插件，可以获得更加友好的写作体验，不妨试一试。\n","tags":["Mac","LaTeX"],"categories":["物理"]},{"title":"一些HTML与JS的小技巧","url":"/2017-10/一些HTML与JS的小技巧/","content":"\n最近博主在学习前端设计的时候，知道了很多实用的小技巧，于是决定写一篇文章总结一下。\n\n## `use strict`\n\n在一些脚本中，你或许会在最前面看到单独的一行`\"use strict\"`，这是严格模式的声明。\n严格模式对正常的JavaScript语义做了一些更改：\n- 严格模式通过抛出错误来消除了一些原有静默错误。\n- 严格模式修复了一些导致JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。\n- 严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。\n\n## JavaScript传递参数\n\n这是一种向外部JS文件传入参数的方法。在HTML中写入\n```xml\n<script tag1=\"1\" src=\"example.js\"></script>\n```\n在`example.js`中写入\n```javascript\nvar scripts = document.getElementsByTagName(\"script\"),\n    script_len = scripts.length,\n    script = scripts[script_len - 1],\n    tag1 = script.getAttribute(\"tag1\");\n```\n这样即可获取tag1的值，可以说是非常的巧妙了。\n\n## `document.write`\n\n这个函数可以直接向HTML文档写入任何内容。比如，你需要根据屏幕宽度来加载不同js时，如果希望写入的内容是`<script src=\"main.js\"></script>`，那么只要这样就可以了：\n```xml\n<script> if (screen.width >= 1200) document.write('<script src=\"main.js\"><\\/script>'); </script> \n```\nJavaScript的字符串可以使用单引号或双引号表示，但是由于要写入的内容里有双引号，使用`document.write`时应该用单引号括起来，否则需要将双引号转义为`\\\"`，避免造成错误。如果有多层引号，应将最内层的引号改为HTML转义字符`&quot;`。而对于这里出现的`/`，将其改写为了`\\/`，原因是浏览器会认为`</script>`是闭合标签，造成代码解析错误。\n通过`document.write`可以实现根据不同的条件向HTML写入不同的内容，但是要注意，如果这个时候页面已经加载完毕，`document.write`会导致页面的内容被清空、覆盖。因此，这个方法不被推荐使用，应该通过其它方式代替。\n\n## `<noscript>`标签\n\n对于某些不支持JavaScript的上古浏览器，以及对于停用了JavaScript的用户，`<noscript>`标签可能非常有用。\n```xml\n<noscript> \n<div style=\"background-color: #5C5C5C; position: fixed; bottom: 50px; left: 80px; opacity: 0.95; border-radius: 15px; color: #FFFFFF;\">\n    <p style=\"margin: 15px; max-width: 400px;\">系统检测到您的浏览器禁用了或不支持JavaScript。为了保障您的浏览体验，请启用JavaScript或<a target=\"_blank\" href=\"http://browsehappy.com\" class=\"a\" style=\"color: rgba(239,178,75,1)\">升级浏览器</a></p>\n</div>\n</noscript> \n```\n\n## `<a>`标签的`download`属性\n\n设置`<a>`标签的`download`属性，可以在点击该链接时下载目标，即href属性指向的超链接。\n该属性也可以设置一个值来规定下载文件的名称。所允许的值没有限制，浏览器将自动检测正确的文件扩展名并添加到文件。例如：\n```xml\n<a href=\"https://www.example.com//images/2017-10/example.jpg\" download=\"logo\">\n```\n正常情况下，浏览器会将其保存为logo.jpg。\n\n<!-- more -->\n## IE条件注释\n\n以下类型的注释会被IE9及更早的版本读取，而被其他浏览器忽略：\n```xml\n<!-- Since Conditional Comments have been deprecated since Internet Explorer 10, the following script will be ignored, so only Internet Explorer 9 (and below) users will be redirected to a page asking to upgrade their browsers. -->\n<!--[if IE]>\n    <script type=\"text/javascript\" src=\"./js/upgrade_your_fucking_browser.js\"></script>\n<![endif]-->\n```\n或者\n```xml\n<!--[if lt IE 9]>\n    <div class=\"notice chromeframe\">您的浏览器版本<strong>很旧很旧</strong>，为了正常地访问网站，请升级您的浏览器<a target=\"_blank\" href=\"http://browsehappy.com\">立即升级</a></div>\n<![endif]--> \n```\n在『现代』浏览器占主导的今天，这种条件注释的一个用处是提醒IE用户升级浏览器。不过，IE10及更新的IE不会读取这些条件注释。如果想要所有IE都看到提醒，可能还要靠别的办法，比如用JavaScript判断User Agent。可以看看微软的文档：[Conditional comments are no longer supported](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/hh801214%28v=vs.85%29)。\n\n## 阻止非法操作\n\n### 屏蔽IE浏览器\n\n前面讲到的IE条件注释，可以针对IE浏览器做一些适配。但如果网页中使用了大量的HTML5和CSS3标准的内容，那么任何版本的IE都是招架不住的。为了一劳永逸地解决问题，可以屏蔽IE浏览器的访问，甚至直接重定向到[Browse Happy](https://browsehappy.com/)。\n```javascript\n//Kill XP and IE8\n(function(){\n    var ua = navigator.userAgent;\n    var res = /Windows NT (\\d+\\.\\d+)/.exec(ua);\n    var xpOrLower = res && JSON.parse(res[1]) < 6;\n    res = /MSIE (\\d+\\.\\d+)/.exec(ua);\n    var ie8OrLower = res && JSON.parse(res[1]) < 9;\n    if (xpOrLower || ie8OrLower) {\n        alert(\"请不要用XP及之前的Windows系统，和IE8及之前的IE浏览器访问本站！\");\n        location.href = \"about:blank\";\n    }\n})();\n```\n\n### 屏蔽百度搜索\n\n```javascript\nvar fromBaiduSE = /^https?:\\/\\/www.baidu.com/.test(document.referrer);\nif (fromBaiduSE) {\n    alert(\"检测到你还在使用百度搜索，作为一个程序员，这是一种自暴自弃！\\n\\n做不作恶的程序员，从不用百度开始！\")\n    location.href = \"about:blank\";\n}\n```\n\n### 防盗链\n\n如果是视频、图片等静态资源的防盗链，通过服务器判断`referer`即可阻止非法访问。而要防止自己的页面被其他网站用作`<iframe>`，则可以通过以下JavaScript代码来实现：\n```javascript\nif (top.location != self.location) top.location = self.location;\nif (document.location.search.match(/type=embed/gi)) {\n    window.parent.postMessage(\"resize\", \"*\");\n}\n```\n\n### 禁止选中复制\n\n监听`onselectstart`事件，即可阻止用户的拖拽选择行为：\n```javascript\ndocument.onselectstart = function(event) {\n    event.preventDefault();\n    return false;\n}\n```\n\n## 其它的一些技巧\n\n如果需要调用`getElementById`之类的函数，务必把`<script>`标签放到对应的元素后面，否则会找不到对象。\n将body标签写为`<body onload=\"main()\">`，那么main函数会在页面加载完成后直接运行，通过`window.addEventListener(\"load\", main)`也能达到类似的效果。\n\n---\n\n文末，再写一些博主关于Safari 4.0的一些回忆吧。\n为了测试网站对不同浏览器的友好程度，博主下载了Oracle和Firefox，看到首次打开Firefox的欢迎动画时，突然想到多年之前，在Windows上首次运行Safari时看到的极为惊艳的欢迎动画。这段动画展示了HTML5的诸多新特性。经过推断，那是2010年左右，版本是Safari 4.0。查找各大论坛后，找到了这个Safari欢迎动画的网址：`http://www.apple.com/safari/welcome/`。可惜年代久远，它可能已经永远地从苹果的服务器上消失了。非常遗憾，那个时候的我还too young，沉迷于制作逐帧flash动画，丝毫没有了解html的奇妙世界。当今天我的回忆再一次被唤起时，Safari for Windows已经凉了，[Flash也快凉了](https://www.apple.com/hotnews/thoughts-on-flash)，Safari for macOS已经是11.0版本。互联网时代的高速发展实在是令人感慨万千。\n\n拓展阅读：\n[CSS3 Filter Effects](https://www.bestagencies.com/tools/filter-effects-css-generator)\n[JavaScript 实例](https://www.runoob.com/js/js-examples.html)\n\n本文更新于2018年6月21日\n","tags":["HTML","JavaScript"],"categories":["Web开发"]},{"title":"伟安生，不玩蛇","url":"/2017-10/伟安生，不玩蛇/","content":"\n![](/images/2017-10/SNAKE.jpg)\n\n> 安德罗妮：这不是我说的。\n","tags":["炉石传说"],"categories":["电子游戏"]},{"title":"MacBook使用一块移动硬盘做Win To Go及Time Machine备份","url":"/2017-10/MacBook使用一块移动硬盘做Win To Go及Time Machine备份/","content":"\n## 前言\n\n博主使用的MacBook Air，256G闪存，可用空间约251G，曾经的分区表为：\n\n![](/images/2017-10/diskutillist-old.png)\n\n（这是使用`diskutil list`命令输出的结果）\n\nGUID分区表，共四个分区，分别是EFI引导分区、APFS的Mac主分区（在更新macOS 10.13之前为HFS+）、NTFS的Bootcamp分区以及Windows Recovery分区。\n在最初安装Bootcamp时，考虑到Windows系统只是用来运行某些没有macOS版本或无法移植到macOS的程序（例如《红色警戒2》），Bootcamp分区的大小仅分配了35G。然而，在8月中旬昆特牌国服开启公测后，入坑的博主发现Bootcamp分区的大小似乎不够用了。\n\n![](/images/2017-10/maxresdefault.jpg)\n\n由于Bootcamp是磁盘上靠后的分区，并不能用常规操作向前扩充，吞并APFS分区的空间（DiskGenius使用计算器+手动改分区表数据似乎属于非常规操作，且面临着分区出现问题的危险），所以只能考虑备份Bootcamp分区内容，然后将其移除，并在主硬盘上重新划分Bootcamp分区。\n不过，新的问题又产生了：Mac主分区的大小也很有限（毕竟是安装了Adobe全家桶、Autodesk Maya、XCode等程序的），并不足以重新划分出较大的Bootcamp分区以安装Windows。于是只得寻求其他解决方案。比较显而易见的解决方案有：\n- 换个Mac（没有了信仰灯和MagSafe）\n- 换个硬盘（MacBook Air的闪存是BGA封装的，并不能像SATA的SSD那样直接拆）\n- 装个SD卡（高性能大容量的SD卡价格感人，并且不适合NTFS文件系统）\n\n这些都不是最优解。在综合了各方面的考虑后，最终选定了如下方案：\n- 使用移动硬盘，一个分区做Win To Go，另一个分区做Time Machine备份。其中移动硬盘选择的是西数Elements 500G。\n\n<!-- more -->\n## 安装方法\n\n### 准备必要的硬件\n\n- MacBook Air\n- 移动硬盘（安装时会全盘格式化，请务必备份好全部数据）\n- 可以运行Windows的PC\n\n### 下载必要的文件\n\n- [Windows镜像](https://msdn.itellyou.cn)（请选择最新Windows 10的ISO镜像文件）\n- [Win To Go安装工具](https://bbs.luobotou.org/thread-761-1-1.html)\n- [Bootcamp驱动程序](https://pan.baidu.com/s/1jIJ0hfS)\n\n### 创建Win To Go\n\n使用系统自带工具或下载第三方软件，将Windows镜像装载到虚拟光驱。将移动硬盘连接到PC上。在PC上打开Win To Go安装工具，如图所示。\n\n![](/images/2017-10/4500.png)\n\n点击『浏览』，在虚拟光驱中找到`install.wim`文件并选中；在下方选择目标磁盘，即需要安装的移动硬盘。右侧高级选项中，『常用』栏下选择VHD，以及UEFI+GPT，『分区』栏下手动输入第二个分区的大小，单位为MB；程序会自动调整第一个分区的大小；第三个分区若无需要，填0即可。第一个分区即作为Win To Go分区，第二个分区作为Time Machine备份分区。请再次确认移动硬盘上所有分区的文件都已备份。接下来点击『创建』，就将进行全盘格式化，并建立引导，创建Win To Go相关文件。\n\n### 配置Windows\n\n完成上一步后，将移动硬盘接入Mac。重新启动系统，按住<kbd>Option</kbd>/<kbd>alt</kbd>键，进入引导磁盘选项。选择EFI分区，启动后按照提示完成Windows系统的配置即可。配置完Windows系统后，安装Bootcamp驱动。重新启动后即可应用更改。\n注：在macOS与Windows下，触控板滚动方向是相反的，这一点可能会使用户感到不适，解决方案是修改注册表：\n在Windos下通过<kbd>Win</kbd>+<kbd>R</kbd>打开『运行』，输入regedit，在打开的注册表编辑器中，依次选择`\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\HID`，即可查看所有可用的键盘、鼠标。对于每个输入设备，点开下级目录，查看其Device Parameters下是否具有属性`FlipFlopWheel`和`FlipFlopHScroll`，若有，将其数据值由0改为1即可。\n\n![](/images/2017-10/FlipFlopWheel.png)\n\n### 配置Time Machine\n\n此时再进入macOS系统，使用磁盘工具（在应用程序-实用工具目录中），选择移动硬盘，将其第二个分区（如果显示了EFI引导分区，则是第三个分区）格式化为macOS日志式。如果已经开启了Time Machine，系统将会提示你将此硬盘作为Time Machine备份硬盘。接下来打开Time Machine进行初次备份即可。\n完成这些操作后，便成功地使一块移动硬盘成为Win To Go启动盘及Time Machine备份盘。\n\n附现在的分区表：\n\n![](/images/2017-10/diskutillist.png)\n\n---\n\n本文更新于2019年6月：\n根据微软官方的说法，Windows To Go将不再开发。事实上，它确实存在很多不便之处，例如无法通过常规方式升级系统。所以，如果条件允许，建议还是通过Bootcamp方法安装Windows。\n","tags":["Mac"],"categories":["技术"]},{"title":"C语言控制台程序清除输入缓冲区","url":"/2017-10/C语言控制台程序清除输入缓冲区/","content":"\n编写C语言控制台程序时，如果使用`scanf()`函数作为输入，往往需要解决非法输入的问题。比如以下情况：\n```c\nprintf(\"输入一个0~9的整数a\\n\");\nint a;\nscanf(\"%d\", &a);\n```\n此时可能出现如下几种典型的非法输入：\n- 123\n- 123xyz\n- xyz123\n\n对于第一种，使用if判断a的范围是否满足要求即可。第二种和第三种则较为复杂，因为其中涉及到了字符的输入。第二种情况，`scanf()`会将123存入a，而xyz留在了输入缓冲区；第三种情况，`scanf()`不会读取任何数据，xyz123都留在了输入缓冲区。\n如果只是判断这一次输入的合法性，可以利用`scanf()`的返回值。如果输入有效，`scanf()`会返回1，否则返回0。由此可以排除`scanf()`无法读取的输入。\n\n<!-- more -->\n然而，仅仅这样做是不够的。假设之后继续运行如下代码：\n```c\nprintf(\"输入一个整数b\\n\");\nint b;\nscanf(\"%d\", &b);\n```\n如果在输入a时，非法输入的xyz或xyz123留在了输入缓冲区，那么当`scanf()`再次执行时，并不会直接读取你第二次输入的数据，而是从上一次输入在输入缓冲区留下的数据开始。即使你在输入b时给出了合法的输入，也不会被正确读取。同理，使用`getchar()`得到的也是缓冲区中的第一个字符。\n所以，问题的本质是：如果有多次输入，需要在每次输入之前，清除输入缓冲区。否则，之前由于非法输入导致留在输入缓冲区中的数据，会直接影响到这次输入。\n而解决办法，通过查找各类论坛，总结出来有如下几种：\n- `setbuf(stdin, NULL)`\n- `fflush(stdin)`\n- `scanf(\"%*[^\\n]%*c\")`\n- `rewind(stdin)`\n\n其原理各不相同，但经过测试，像`fflush(stdin)`这样的函数，在VC中可以清除输入缓冲区，但在XCode（或gcc）中不起作用。而`scanf(\"%*[^\\n]%*c\")`原理是读取输入缓冲区的所有字符，达到清除输入缓冲区的目的；这似乎也不能解决某些形式的非法输入。\n经研究，最为有效的办法是在每次接受输入前加一句`rewind(stdin)`，其效果是坠吼的。\n","tags":["C"],"categories":["程序设计"]},{"title":"Minecraft存档Galaxy City地铁图（前瞻版）","url":"/2017-10/Minecraft存档Galaxy City地铁图（前瞻版）/","content":"\n![](/images/2017-10/GalaxyCity.svg)\n","tags":["我的世界"],"categories":["电子游戏"]},{"title":"C语言程序Power of Logic","url":"/2017-10/C语言程序Power of Logic/","content":"\nPower of Logic是一个推理游戏，玩家的任务是用尽可能少的时间和步骤解开密码序列。当你输入不同的数字序列时，系统会给出提示，指示你输入的数字序列中，有多少个数字正确但位置错误，又有多少个数字和位置都正确。可惜这一游戏已经不再维护和更新了，最新的iOS设备上甚至无法下载。不过考虑到它的核心逻辑并不复杂，博主用C语言写了一个低配版。\n\n运行效果如图：\n\n![](/images/2017-10/PoL.png)\n\n下面附上最终版本的代码。\n<!-- more -->\n```c\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n\nvoid print() {\n    printf(\"Power of Logic for Macintosh,Powered by Mimi 1984,Copyright(C)Mimi 1984\\n\");\n    printf(\"Version 0.9.0Beta2 CHEAT 0000 DEBUG 1111 INFO 2222\\n\");\n    printf(\"Thanks for using the Beta version!\\n\\n\");\n}\nint game() {\n    int i, j, n, ref[8], a[4], b[4], times = 0;\n    srand((unsigned int) time(0));\n    for (i = 0; i < 8; i++) ref[i] = i;\n    i = 0;\n    while (1) {\n        n = rand() % 8;\n        if (ref[n] != -1) {\n            a[i] = n;\n            ref[n] = -1;\n            if (++i == 4) break;\n        }\n    } //随机数生成，存入a[4]作为答案\ninput: printf(\"Input your answer\\n\"); //返回点input\n    int x = 0, y = 0, error = 0;\n    rewind(stdin); //清除键盘缓冲区\n    for (i = 0; i < 4; i++) {\n        int check = scanf(\"%d\", &b[i]); //输入数据b[4]\n        if (check != 1) error += 1;\n    }\n    if (error != 0) {\n        printf(\"ERROR:Invalid input.\\n\");\n        goto input;\n    } //判断b[4]是否合法(整数)\n    if (b[0] == 0 && b[1] == 0 && b[2] == 0 && b[3] == 0) {\n        printf(\"The correct answer is:\");\n        for (i = 0; i < 4; i++) {\n            printf(\" %d\", a[i]);\n            if (i == 3) printf(\"\\n\");\n        }\n        goto output;\n    } //输入作弊码0000，输出答案a[4]，结束程序\n    if (b[0] == 1 && b[1] == 1 && b[2] == 1 && b[3] == 1) {\n        printf(\"DEBUG MODE.\\nThe correct answer is:\");\n        for (i = 0; i < 4; i++) {\n            printf(\" %d\", a[i]);\n            if (i == 3) printf(\"\\n\");\n        }\n        goto input;\n    } //输入调试码1111，输出答案a[4],进入调试模式\n    if (b[0] == 2 && b[1] == 2 && b[2] == 2 && b[3] == 2) {\n        printf(\"Sorry.No English Version Provided.\\n\");\n        goto input;\n    } //输入帮助码2222，查看帮助\n    for (i = 0; i < 3; i++) {\n        for (j = i + 1; j < 4; j++) {\n            if (b[i] == b[j]) {\n                printf(\"ERROR:No duplicate numbers allowed.\\n\");\n                goto input;\n            }\n        }\n    } //判断b[4]是否合法(重复数)\n    for (i = 0; i < 3; i++) {\n        if (b[i] <= -1 || b[i] >= 8) {\n            printf(\"ERROR:Only number 0~7 are allowed.\\n\");\n            goto input;\n        }\n    } //判断b[4]是否合法(范围0~7)\n    for (i = 0; i < 4; i++) {\n        if (a[i] == b[i]) x++;\n    }\n    printf(\"%d \", x); //数字正确，位置正确的个数x\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            if (a[i] == b[j]) y++;\n        }\n    }\n    y -= x;\n    printf(\"%d\\n\", y); //数字正确，位置不正确的个数y\n    if (times == 10) printf(\"Come On!You have guessed for too many times!\\n\");\n    if (times == 15) {\n        printf(\"Oh Fuck!You have guessed for TOO many times!\\nThe correct answer is:\");\n        for (i = 0; i < 4; i++) {\n            printf(\" %d\", a[i]);\n            if (i == 3) printf(\"\\n\");\n        }\n        goto output;\n    } //猜测次数检查\n    if (x == 4) {\n        printf(\"Bingo!\\n\");\n        times += 1;\n    }\n    else {\n        times += 1;\n        goto input;\n    } //全部猜对，结束程序，否则重猜\noutput: printf(\"Have Fun!\\n\"); //返回点output\n    return times; //猜测次数作为返回值\n}\nint main(void) {\n    time_t start, end;\n    int cost, times, score; //花费时间，猜测次数，得分\n    print();\n    while (1) {\n        printf(\"Press Enter To Start The Game.\\n\");\n        getchar();\n        time(&start); //计时开始\n        times = game();\n        time(&end); //计时结束\n        cost = difftime(end, start);\n        score = 100 - cost / 10 - times * 2;\n        if (score <= 0) score = 0; //负分归零系统\n        printf(\"Run Time:%d Seconds\\n\", cost);\n        printf(\"Times You Guessed:%d\\n\", times);\n        printf(\"Your Score:%d\\n\\n\", score);\n    }\n    return 0;\n}\n```\n\n---\n\n本文更新于2017年10月21日：\n得益于C与JavaScript的某些相似性，博主成功将Power of Logic移植到Web端，制作了JavaScript版本。目前该游戏已经可以通过[ZSQ.IM > 应用 > 原创游戏 > Logic](https://zsq.im/game/logic/)访问。移植过程全面深化了博主对于JavaScript与HTML5某些机制的理解，包括从网页实时读取内容与输出内容、通过按钮触发函数实现响应以及`setInterval()`和`clearInterval()`的用法等。\n\n![](/images/2017-10/poweroflogic.png)\n","tags":["C"],"categories":["程序设计"]},{"title":"Hello World","url":"/2017-10/Hello World/","content":"\nWelcome to [Hexo](https://hexo.io)! This is your very first post. Check [documentation](https://hexo.io/docs) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["系统日志"],"categories":["其他"]}]